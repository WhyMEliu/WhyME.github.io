<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python正则表达式]]></title>
    <url>%2F2020%2F03%2F01%2FPython%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[感觉重学Python，太久不用。。幸好有笔记 正则表达式是什么 正则表达式是一个特殊的字符序列，一个字符串是否与我们所设定的这的字符序列，相匹配快速检索文本，实现一些替换文本的操作 使用简单示例12345678910111213import rea = 'python|java|C#'#print(a.index('java')&gt;-1)r = re.findall('python',a)print(r)# 规则if len(r) &gt; 0: print('字符串中包含python~')else: print('No') 正则表达式使用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import re# a = 'python0java2C#'# r = re.findall('\d',a)# print(r)# 'Python' 普通字符 '\d' 元字符#[] [cdef] [^cdef] [a-f]# s = 'abc, acc, adc, afc, ahc'# r = re.findall('a[^fc]c',s)# print(r)# 概括字符集# \d \D [0-9]# \w [A-Z,a-z,0-9,_] \W [&amp;,\t,\n,\r,' '] # \s 空白字符 \S 非空白字符# . 匹配除换行符\n以外的所有字符# a = 'python1111java678php'# r = re.findall('[0-9]',a)# print(r)# 数量词# a = 'python 1111java678php'# r = re.findall('[a-z]&#123;3,6&#125;?',a)# 贪婪 与 非贪婪(?加)# python(贪婪)# print(r)# * 匹配0次或无限多次# a = 'pytho0python1pythonn2'# r = re.findall('python*',a)# print(r)# + 匹配1次或无限多次# a = 'pytho0python1pythonn2'# r = re.findall('python+',a)# print(r)# ? 匹配0次或1次# a = 'pytho0python1pythonn2'# r = re.findall('python?',a)# print(r)# 边界匹配# qq = '10000000001'# 4~8 # r = re.findall('^\d&#123;4,8&#125;$',qq)# r = re.findall('000$',qq)# print(r)# 组# a = 'pythonpythonpythonpython'# r = re.findall('(python)&#123;3&#125;',a)# print(r)# I 忽略大小写# S 匹配所有字符# langue = 'PythonC#JavaPHP'# r = re.findall('c#',langue, re.I)langue = 'PythonC#\nJavaPHP'r = re.findall('c#.&#123;1&#125;',langue, re.I | re.S)print(r) 字符串替换函数使用12345678910111213141516171819202122232425262728import re# count 0:全部替换 1:一次替换# langue = 'PythonC#JavaPHP'# r = re.sub('C#','GO',langue,0)# print(r)# print(langue)# def convert(value):# print(value) # &lt;_sre.SRE_Match object; span=(6, 8), match='C#'&gt;# matched = value.group()# return '!!'+matched+'!!'# langue = 'PythonC#JavaPHP'# r = re.sub('C#',convert,langue,0)# print(r) # Python!!C#!!JavaPHPs = 'A8C37232D86'def convert(value): matched = value.group() if int(matched) &gt;= 6: return '9' else: return '0' r = re.sub('\d',convert,s)print(r) search(),match()函数使用1234567891011121314151617181920212223242526272829303132import re# s = '8C37232D86'# 从首字符开始匹配# r = re.match('\d', s);# print(r)# print(r.span()) # 获取匹配的位置# 从全部字符开始匹配# r1 = re.search('\d', s);# print(r1)# print(r1.group()) # 获取匹配的字符# # 匹配所有的字符# r2 = re.findall('\d',s);# print(r2)# s1 = 'life is short,i use python'# r3 = re.search('life(.*)python',s1)# print(r3.group(1)) # 0 代表完整匹配# r4 = re.findall('life(.*)python',s1)# print(r4)# s2 = 'life is short,i use python,i love python'# r5 = re.search('life(.*)python(.*)python',s2)# print(r5.group(0))# print(r5.group(1))# print(r5.group(2))# print(r5.group(0,1,2))# print(r5.groups()) # 打印各组的数据]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式全]]></title>
    <url>%2F2020%2F03%2F01%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%85%A8%2F</url>
    <content type="text"><![CDATA[比较全~保存下 校验数字的表达式12345678910111213141516171819数字：^[0-9]*$n位的数字：^\d&#123;n&#125;$至少n位的数字：^\d&#123;n,&#125;$m-n位的数字：^\d&#123;m,n&#125;$零和非零开头的数字：^(0|[1-9][0-9]*)$非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]&#123;1,2&#125;)?$带1-2位小数的正数或负数：^(\-)?\d+(\.\d&#123;1,2&#125;)?$正数、负数、和小数：^(\-|\+)?\d+(\.\d+)?$有两位小数的正实数：^[0-9]+(.[0-9]&#123;2&#125;)?$有1~3位小数的正实数：^[0-9]+(.[0-9]&#123;1,3&#125;)?$非零的正整数：^[1-9]\d*$ 或 ^([1-9][0-9]*)&#123;1,3&#125;$ 或 ^\+?[1-9][0-9]*$非零的负整数：^\-[1-9][]0-9"*$ 或 ^-[1-9]\d*$非负整数：^\d+$ 或 ^[1-9]\d*|0$非正整数：^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$非负浮点数：^\d+(\.\d+)?$ 或 ^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$非正浮点数：^((-\d+(\.\d+)?)|(0+(\.0+)?))$ 或 ^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$正浮点数：^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$ 或 ^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$负浮点数：^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$ 或 ^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$浮点数：^(-?\d+)(\.\d+)?$ 或 ^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$ 校验字符的表达式123456789101112汉字：^[\u4e00-\u9fa5]&#123;0,&#125;$英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]&#123;4,40&#125;$长度为3-20的所有字符：^.&#123;3,20&#125;$由26个英文字母组成的字符串：^[A-Za-z]+$由26个大写英文字母组成的字符串：^[A-Z]+$由26个小写英文字母组成的字符串：^[a-z]+$由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$由数字、26个英文字母或者下划线组成的字符串：^\w+$ 或 ^\w&#123;3,20&#125;$中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$中文、英文、数字但不包括下划线等符号：^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]&#123;2,20&#125;$可以输入含有^%&amp;',;=?$\"等字符：[^%&amp;',;=?$\x22]+禁止输入含有~的字符：[^~\x22]+ 特殊需求表达式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237Email地址：^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$域名：[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(/.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+/.?InternetURL：[a-zA-z]+://[^\s]* 或 ^http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]*)?$手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d&#123;8&#125;$电话号码("XXX-XXXXXXX"、"XXXX-XXXXXXXX"、"XXX-XXXXXXX"、"XXX-XXXXXXXX"、"XXXXXXX"和"XXXXXXXX)：^(\(\d&#123;3,4&#125;-)|\d&#123;3.4&#125;-)?\d&#123;7,8&#125;$国内电话号码(0511-4405222、021-87888822)：\d&#123;3&#125;-\d&#123;8&#125;|\d&#123;4&#125;-\d&#123;7&#125;身份证号(15位、18位数字)：^\d&#123;15&#125;|\d&#123;18&#125;$短身份证号码(数字、字母x结尾)：^([0-9])&#123;7,18&#125;(x|X)?$ 或 ^\d&#123;8,18&#125;|[0-9x]&#123;8,18&#125;|[0-9X]&#123;8,18&#125;?$帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w&#123;5,17&#125;$强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).&#123;8,10&#125;$ 日期格式：^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$钱的输入格式：1.有四种钱的表示形式我们可以接受:"10000.00" 和 "10,000.00", 和没有 "分" 的 "10000" 和 "10,000"：^[1-9][0-9]*$2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符"0"不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$5.必须说明的是,小数点后面至少应该有1位数,所以"10."是不通过的,但是 "10" 和 "10.2" 是通过的：^[0-9]+(.[0-9]&#123;2&#125;)?$6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]&#123;1,2&#125;)?$7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*(.[0-9]&#123;1,2&#125;)?$8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*)(.[0-9]&#123;1,2&#125;)?$备注：这就是最终结果了,别忘了"+"可以用"*"替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$中文字符的正则表达式：[\u4e00-\u9fa5]双字节字符：[^\x00-\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))28 空白行的正则表达式：\n\s*\r (可以用来删除空白行)HTML标记的正则表达式：&lt;(\S*?)[^&gt;]*&gt;.*?&lt;/\1&gt;|&lt;.*? /&gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)30 首尾空白字符的正则表达式：^\s*|\s*$或(^\s*)|(\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)腾讯QQ号：[1-9][0-9]&#123;4,&#125; (腾讯QQ号从10000开始)中国邮政编码：[1-9]\d&#123;5&#125;(?!\d) (中国邮政编码为6位数字)IP地址：\d+\.\d+\.\d+\.\d+ (提取IP地址时有用)34 IP地址：((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.)&#123;3&#125;(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)) "^\d+$" //非负整数（正整数 + 0） "^[0-9]*[1-9][0-9]*$" //正整数 "^((-\d+)|(0+))$" //非正整数（负整数 + 0） "^-[0-9]*[1-9][0-9]*$" //负整数 "^-?\d+$" //整数 "^\d+(\.\d+)?$" //非负浮点数（正浮点数 + 0） "^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$" //正浮点数 "^((-\d+(\.\d+)?)|(0+(\.0+)?))$" //非正浮点数（负浮点数 + 0） "^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$" //负浮点数 "^(-?\d+)(\.\d+)?$" //浮点数 "^[A-Za-z]+$" //由26个英文字母组成的字符串 "^[A-Z]+$" //由26个英文字母的大写组成的字符串 "^[a-z]+$" //由26个英文字母的小写组成的字符串 "^[A-Za-z0-9]+$" //由数字和26个英文字母组成的字符串 "^\w+$" //由数字、26个英文字母或者下划线组成的字符串 "^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$" //email地址 "^[a-zA-z]+://(\w+(-\w+)*)(\.(\w+(-\w+)*))*(\?\S*)?$" //url 整数或者小数：^[0-9]+\.&#123;0,1&#125;[0-9]&#123;0,2&#125;$ 只能输入数字："^[0-9]*$"。 只能输入n位的数字："^\d&#123;n&#125;$"。 只能输入至少n位的数字："^\d&#123;n,&#125;$"。 只能输入m~n位的数字：。"^\d&#123;m,n&#125;$"只能输入零和非零开头的数字："^(0|[1-9][0-9]*)$"。 只能输入有两位小数的正实数："^[0-9]+(.[0-9]&#123;2&#125;)?$"。 只能输入有1~3位小数的正实数："^[0-9]+(.[0-9]&#123;1,3&#125;)?$"。 只能输入非零的正整数："^\+?[1-9][0-9]*$"。 只能输入非零的负整数："^\-[1-9][]0-9"*$。 只能输入长度为3的字符："^.&#123;3&#125;$"。 只能输入由26个英文字母组成的字符串："^[A-Za-z]+$"。 只能输入由26个大写英文字母组成的字符串："^[A-Z]+$"。 只能输入由26个小写英文字母组成的字符串："^[a-z]+$"。 只能输入由数字和26个英文字母组成的字符串："^[A-Za-z0-9]+$"。 只能输入由数字、26个英文字母或者下划线组成的字符串："^\w+$"。 验证用户密码："^[a-zA-Z]\w&#123;5,17&#125;$"正确格式为：以字母开头，长度在6~18之间，只能包含字符、数字和下划线。 验证是否含有^%&amp;'',;=?$\"等字符："[^%&amp;'',;=?$\x22]+"。 只能输入汉字："^[\u4e00-\u9fa5]&#123;0,&#125;$"验证Email地址："^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$"。 验证InternetURL："^http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]*)?$"。 验证电话号码："^(\(\d&#123;3,4&#125;-)|\d&#123;3.4&#125;-)?\d&#123;7,8&#125;$"正确格式为："XXX-XXXXXXX"、"XXXX-XXXXXXXX"、"XXX-XXXXXXX"、"XXX-XXXXXXXX"、"XXXXXXX"和"XXXXXXXX"。 验证身份证号（15位或18位数字）："^\d&#123;15&#125;|\d&#123;18&#125;$"。 验证一年的12个月："^(0?[1-9]|1[0-2])$"正确格式为："01"～"09"和"1"～"12"。 验证一个月的31天："^((0?[1-9])|((1|2)[0-9])|30|31)$"正确格式为；"01"～"09"和"1"～"31"。整数或者小数：^[0-9]+\.&#123;0,1&#125;[0-9]&#123;0,2&#125;$ 只能输入数字："^[0-9]*$"。 只能输入n位的数字："^\d&#123;n&#125;$"。 只能输入至少n位的数字："^\d&#123;n,&#125;$"。 只能输入m~n位的数字：。"^\d&#123;m,n&#125;$"只能输入零和非零开头的数字："^(0|[1-9][0-9]*)$"。 只能输入有两位小数的正实数："^[0-9]+(.[0-9]&#123;2&#125;)?$"。 只能输入有1~3位小数的正实数："^[0-9]+(.[0-9]&#123;1,3&#125;)?$"。 只能输入非零的正整数："^\+?[1-9][0-9]*$"。 只能输入非零的负整数："^\-[1-9][]0-9"*$。 只能输入长度为3的字符："^.&#123;3&#125;$"。 只能输入由26个英文字母组成的字符串："^[A-Za-z]+$"。 只能输入由26个大写英文字母组成的字符串："^[A-Z]+$"。 只能输入由26个小写英文字母组成的字符串："^[a-z]+$"。 只能输入由数字和26个英文字母组成的字符串："^[A-Za-z0-9]+$"。 只能输入由数字、26个英文字母或者下划线组成的字符串："^\w+$"。 验证用户密码："^[a-zA-Z]\w&#123;5,17&#125;$"正确格式为：以字母开头，长度在6~18之间，只能包含字符、数字和下划线。 验证是否含有^%&amp;'',;=?$\"等字符："[^%&amp;'',;=?$\x22]+"。 只能输入汉字："^[\u4e00-\u9fa5]&#123;0,&#125;$"验证Email地址："^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$"。 验证InternetURL："^http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]*)?$"。 验证电话号码："^(\(\d&#123;3,4&#125;-)|\d&#123;3.4&#125;-)?\d&#123;7,8&#125;$"正确格式为："XXX-XXXXXXX"、"XXXX-XXXXXXXX"、"XXX-XXXXXXX"、"XXX-XXXXXXXX"、"XXXXXXX"和"XXXXXXXX"。 验证身份证号（15位或18位数字）："^\d&#123;15&#125;|\d&#123;18&#125;$"。 验证一年的12个月："^(0?[1-9]|1[0-2])$"正确格式为："01"～"09"和"1"～"12"。 验证一个月的31天："^((0?[1-9])|((1|2)[0-9])|30|31)$"正确格式为；"01"～"09"和"1"～"31"。"^\d+$" //非负整数（正整数 + 0） "^[0-9]*[1-9][0-9]*$" //正整数 "^((-\d+)|(0+))$" //非正整数（负整数 + 0） "^-[0-9]*[1-9][0-9]*$" //负整数 "^-?\d+$" //整数 "^\d+(\.\d+)?$" //非负浮点数（正浮点数 + 0） "^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$" //正浮点数 "^((-\d+(\.\d+)?)|(0+(\.0+)?))$" //非正浮点数（负浮点数 + 0） "^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$" //负浮点数 "^(-?\d+)(\.\d+)?$" //浮点数 "^[A-Za-z]+$" //由26个英文字母组成的字符串 "^[A-Z]+$" //由26个英文字母的大写组成的字符串 "^[a-z]+$" //由26个英文字母的小写组成的字符串 "^[A-Za-z0-9]+$" //由数字和26个英文字母组成的字符串 "^\w+$" //由数字、26个英文字母或者下划线组成的字符串 "^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$" //email地址 "^[a-zA-z]+://(\w+(-\w+)*)(\.(\w+(-\w+)*))*(\?\S*)?$" //url 整数或者小数：^[0-9]+\.&#123;0,1&#125;[0-9]&#123;0,2&#125;$ 只能输入数字："^[0-9]*$"。 只能输入n位的数字："^\d&#123;n&#125;$"。 只能输入至少n位的数字："^\d&#123;n,&#125;$"。 只能输入m~n位的数字：。"^\d&#123;m,n&#125;$"只能输入零和非零开头的数字："^(0|[1-9][0-9]*)$"。 只能输入有两位小数的正实数："^[0-9]+(.[0-9]&#123;2&#125;)?$"。 只能输入有1~3位小数的正实数："^[0-9]+(.[0-9]&#123;1,3&#125;)?$"。 只能输入非零的正整数："^\+?[1-9][0-9]*$"。 只能输入非零的负整数："^\-[1-9][]0-9"*$。 只能输入长度为3的字符："^.&#123;3&#125;$"。 只能输入由26个英文字母组成的字符串："^[A-Za-z]+$"。 只能输入由26个大写英文字母组成的字符串："^[A-Z]+$"。 只能输入由26个小写英文字母组成的字符串："^[a-z]+$"。 只能输入由数字和26个英文字母组成的字符串："^[A-Za-z0-9]+$"。 只能输入由数字、26个英文字母或者下划线组成的字符串："^\w+$"。 验证用户密码："^[a-zA-Z]\w&#123;5,17&#125;$"正确格式为：以字母开头，长度在6~18之间，只能包含字符、数字和下划线。 验证是否含有^%&amp;'',;=?$\"等字符："[^%&amp;'',;=?$\x22]+"。 只能输入汉字："^[\u4e00-\u9fa5]&#123;0,&#125;$"验证Email地址："^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$"。 验证InternetURL："^http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]*)?$"。 验证电话号码："^(\(\d&#123;3,4&#125;-)|\d&#123;3.4&#125;-)?\d&#123;7,8&#125;$"正确格式为："XXX-XXXXXXX"、"XXXX-XXXXXXXX"、"XXX-XXXXXXX"、"XXX-XXXXXXXX"、"XXXXXXX"和"XXXXXXXX"。 验证身份证号（15位或18位数字）："^\d&#123;15&#125;|\d&#123;18&#125;$"。 验证一年的12个月："^(0?[1-9]|1[0-2])$"正确格式为："01"～"09"和"1"～"12"。 验证一个月的31天："^((0?[1-9])|((1|2)[0-9])|30|31)$"正确格式为；"01"～"09"和"1"～"31"。整数或者小数：^[0-9]+\.&#123;0,1&#125;[0-9]&#123;0,2&#125;$ 只能输入数字："^[0-9]*$"。 只能输入n位的数字："^\d&#123;n&#125;$"。 只能输入至少n位的数字："^\d&#123;n,&#125;$"。 只能输入m~n位的数字：。"^\d&#123;m,n&#125;$"只能输入零和非零开头的数字："^(0|[1-9][0-9]*)$"。 只能输入有两位小数的正实数："^[0-9]+(.[0-9]&#123;2&#125;)?$"。 只能输入有1~3位小数的正实数："^[0-9]+(.[0-9]&#123;1,3&#125;)?$"。 只能输入非零的正整数："^\+?[1-9][0-9]*$"。 只能输入非零的负整数："^\-[1-9][]0-9"*$。 只能输入长度为3的字符："^.&#123;3&#125;$"。 只能输入由26个英文字母组成的字符串："^[A-Za-z]+$"。 只能输入由26个大写英文字母组成的字符串："^[A-Z]+$"。 只能输入由26个小写英文字母组成的字符串："^[a-z]+$"。 只能输入由数字和26个英文字母组成的字符串："^[A-Za-z0-9]+$"。 只能输入由数字、26个英文字母或者下划线组成的字符串："^\w+$"。 验证用户密码："^[a-zA-Z]\w&#123;5,17&#125;$"正确格式为：以字母开头，长度在6~18之间，只能包含字符、数字和下划线。 验证是否含有^%&amp;'',;=?$\"等字符："[^%&amp;'',;=?$\x22]+"。 只能输入汉字："^[\u4e00-\u9fa5]&#123;0,&#125;$"验证Email地址："^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$"。 验证InternetURL："^http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]*)?$"。 验证电话号码："^(\(\d&#123;3,4&#125;-)|\d&#123;3.4&#125;-)?\d&#123;7,8&#125;$"正确格式为："XXX-XXXXXXX"、"XXXX-XXXXXXXX"、"XXX-XXXXXXX"、"XXX-XXXXXXXX"、"XXXXXXX"和"XXXXXXXX"。 验证身份证号（15位或18位数字）："^\d&#123;15&#125;|\d&#123;18&#125;$"。 验证一年的12个月："^(0?[1-9]|1[0-2])$"正确格式为："01"～"09"和"1"～"12"。 验证一个月的31天："^((0?[1-9])|((1|2)[0-9])|30|31)$"正确格式为；"01"～"09"和"1"～"31"。 "^\d+$" //非负整数（正整数 + 0） "^[0-9]*[1-9][0-9]*$" //正整数 "^((-\d+)|(0+))$" //非正整数（负整数 + 0） "^-[0-9]*[1-9][0-9]*$" //负整数 "^-?\d+$" //整数 "^\d+(\.\d+)?$" //非负浮点数（正浮点数 + 0） "^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$" //正浮点数 "^((-\d+(\.\d+)?)|(0+(\.0+)?))$" //非正浮点数（负浮点数 + 0） "^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$" //负浮点数 "^(-?\d+)(\.\d+)?$" //浮点数 "^[A-Za-z]+$" //由26个英文字母组成的字符串 "^[A-Z]+$" //由26个英文字母的大写组成的字符串 "^[a-z]+$" //由26个英文字母的小写组成的字符串 "^[A-Za-z0-9]+$" //由数字和26个英文字母组成的字符串 "^\w+$" //由数字、26个英文字母或者下划线组成的字符串 "^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$" //email地址 "^[a-zA-z]+://(\w+(-\w+)*)(\.(\w+(-\w+)*))*(\?\S*)?$" //url 整数或者小数：^[0-9]+\.&#123;0,1&#125;[0-9]&#123;0,2&#125;$ 只能输入数字："^[0-9]*$"。 只能输入n位的数字："^\d&#123;n&#125;$"。 只能输入至少n位的数字："^\d&#123;n,&#125;$"。 只能输入m~n位的数字：。"^\d&#123;m,n&#125;$"只能输入零和非零开头的数字："^(0|[1-9][0-9]*)$"。 只能输入有两位小数的正实数："^[0-9]+(.[0-9]&#123;2&#125;)?$"。 只能输入有1~3位小数的正实数："^[0-9]+(.[0-9]&#123;1,3&#125;)?$"。 只能输入非零的正整数："^\+?[1-9][0-9]*$"。 只能输入非零的负整数："^\-[1-9][]0-9"*$。 只能输入长度为3的字符："^.&#123;3&#125;$"。 只能输入由26个英文字母组成的字符串："^[A-Za-z]+$"。 只能输入由26个大写英文字母组成的字符串："^[A-Z]+$"。 只能输入由26个小写英文字母组成的字符串："^[a-z]+$"。 只能输入由数字和26个英文字母组成的字符串："^[A-Za-z0-9]+$"。 只能输入由数字、26个英文字母或者下划线组成的字符串："^\w+$"。 验证用户密码："^[a-zA-Z]\w&#123;5,17&#125;$"正确格式为：以字母开头，长度在6~18之间，只能包含字符、数字和下划线。 验证是否含有^%&amp;'',;=?$\"等字符："[^%&amp;'',;=?$\x22]+"。 只能输入汉字："^[\u4e00-\u9fa5]&#123;0,&#125;$"验证Email地址："^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$"。 验证InternetURL："^http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]*)?$"。 验证电话号码："^(\(\d&#123;3,4&#125;-)|\d&#123;3.4&#125;-)?\d&#123;7,8&#125;$"正确格式为："XXX-XXXXXXX"、"XXXX-XXXXXXXX"、"XXX-XXXXXXX"、"XXX-XXXXXXXX"、"XXXXXXX"和"XXXXXXXX"。 验证身份证号（15位或18位数字）："^\d&#123;15&#125;|\d&#123;18&#125;$"。 验证一年的12个月："^(0?[1-9]|1[0-2])$"正确格式为："01"～"09"和"1"～"12"。 验证一个月的31天："^((0?[1-9])|((1|2)[0-9])|30|31)$"正确格式为；"01"～"09"和"1"～"31"。整数或者小数：^[0-9]+\.&#123;0,1&#125;[0-9]&#123;0,2&#125;$ 只能输入数字："^[0-9]*$"。 只能输入n位的数字："^\d&#123;n&#125;$"。 只能输入至少n位的数字："^\d&#123;n,&#125;$"。 只能输入m~n位的数字：。"^\d&#123;m,n&#125;$"只能输入零和非零开头的数字："^(0|[1-9][0-9]*)$"。 只能输入有两位小数的正实数："^[0-9]+(.[0-9]&#123;2&#125;)?$"。 只能输入有1~3位小数的正实数："^[0-9]+(.[0-9]&#123;1,3&#125;)?$"。 只能输入非零的正整数："^\+?[1-9][0-9]*$"。 只能输入非零的负整数："^\-[1-9][]0-9"*$。 只能输入长度为3的字符："^.&#123;3&#125;$"。 只能输入由26个英文字母组成的字符串："^[A-Za-z]+$"。 只能输入由26个大写英文字母组成的字符串："^[A-Z]+$"。 只能输入由26个小写英文字母组成的字符串："^[a-z]+$"。 只能输入由数字和26个英文字母组成的字符串："^[A-Za-z0-9]+$"。 只能输入由数字、26个英文字母或者下划线组成的字符串："^\w+$"。 验证用户密码："^[a-zA-Z]\w&#123;5,17&#125;$"正确格式为：以字母开头，长度在6~18之间，只能包含字符、数字和下划线。 验证是否含有^%&amp;'',;=?$\"等字符："[^%&amp;'',;=?$\x22]+"。 只能输入汉字："^[\u4e00-\u9fa5]&#123;0,&#125;$"验证Email地址："^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$"。 验证InternetURL："^http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]*)?$"。 验证电话号码："^(\(\d&#123;3,4&#125;-)|\d&#123;3.4&#125;-)?\d&#123;7,8&#125;$"正确格式为："XXX-XXXXXXX"、"XXXX-XXXXXXXX"、"XXX-XXXXXXX"、"XXX-XXXXXXXX"、"XXXXXXX"和"XXXXXXXX"。 验证身份证号（15位或18位数字）："^\d&#123;15&#125;|\d&#123;18&#125;$"。 验证一年的12个月："^(0?[1-9]|1[0-2])$"正确格式为："01"～"09"和"1"～"12"。 验证一个月的31天："^((0?[1-9])|((1|2)[0-9])|30|31)$"正确格式为；"01"～"09"和"1"～"31"。 可输入形如2008、2008-9、2008-09、2008-9-9、2008-09-09. ^(\d&#123;4&#125;|(\d&#123;4&#125;-\d&#123;1,2&#125;)|(\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;))$ 邮箱验证正则表达式 \w+([-+.']\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)* System.Text.RegularExpressions.Match m = System.Text.RegularExpressions.Regex.Match(s, @"您的IP：(?&lt;IP&gt;[0-9\.]*)"); 网络验证应用技巧1234567891011121314151617181920212223242526272829303132331. 验证 E-mail格式 public bool IsEmail(string str_Email) &#123; return System.Text.RegularExpressions.Regex.IsMatch(str_Email,@"^([\w-\.]+)@(([−9]1,3\.[−9]1,3\.[−9]1,3\.)|(([\w−]+\.)+))([a−zA−Z]2,4|[−9]1,3)(?)$"); &#125; 2. 验证 IP 地址 public bool IPCheck(string IP) &#123; string num = "(25[0-5]|2[0-4]\\d|[0-1]\\d&#123;2&#125;|[1-9]?\\d)"; return Regex.IsMatch(IP,("^" + num + "\\." + num + "\\." + num + "\\." + num + "$")); &#125; 3. 验证 URL public bool IsUrl(string str_url) &#123; return System.Text.RegularExpressions.Regex.IsMatch(str_url, @"http(s)?://([\w-]+\.)+[\w-]+(/[\w- ./?%&amp;=]*)?"); &#125; 常用数字验证技巧1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091. 验证电话号码 public bool IsTelephone(string str_telephone) &#123; return System.Text.RegularExpressions.Regex.IsMatch(str_telephone, @"^(\d&#123;3,4&#125;-)?\d&#123;6,8&#125;$"); &#125; 2. 输入密码条件(字符与数据同时出现) public bool IsPassword(string str_password) &#123; return System.Text.RegularExpressions.Regex.IsMatch(str_password, @"[A-Za-z]+[0-9]"); &#125; 3. 邮政编号 public bool IsPostalcode(string str_postalcode) &#123; return System.Text.RegularExpressions.Regex.IsMatch(str_postalcode, @"^\d&#123;6&#125;$"); &#125; 4. 手机号码 public bool IsHandset(string str_handset) &#123; return System.Text.RegularExpressions.Regex.IsMatch(str_handset, @"^[1]+[3,5]+\d&#123;9&#125;$"); &#125; 5. 身份证号 public bool IsIDcard(string str_idcard) &#123; return System.Text.RegularExpressions.Regex.IsMatch(str_idcard, @"(^\d&#123;18&#125;$)|(^\d&#123;15&#125;$)"); &#125; 6. 两位小数 public bool IsDecimal(string str_decimal) &#123; return System.Text.RegularExpressions.Regex.IsMatch(str_decimal, @"^[0-9]+(.[0-9]&#123;2&#125;)?$"); &#125; 7. 一年的12个月 public bool IsMonth(string str_Month) &#123; return System.Text.RegularExpressions.Regex.IsMatch(str_Month, @"^(0?[[1-9]|1[0-2])$"); &#125; 8. 一个月的31天 public bool IsDay(string str_day) &#123; return System.Text.RegularExpressions.Regex.IsMatch(str_day, @"^((0?[1-9])|((1|2)[0-9])|30|31)$"); &#125; 9. 数字输入 public bool IsNumber(string str_number) &#123; return System.Text.RegularExpressions.Regex.IsMatch(str_number, @"^[0-9]*$"); &#125; 10. 密码长度 (6-18位) public bool IsPasswLength(string str_Length) &#123; return System.Text.RegularExpressions.Regex.IsMatch(str_Length, @"^\d&#123;6,18&#125;$"); &#125; 11. 非零的正整数 public bool IsIntNumber(string str_intNumber) &#123; return System.Text.RegularExpressions.Regex.IsMatch(str_intNumber, @"^\+?[1-9][0-9]*$"); &#125; 常用字符验证技巧1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051. 大写字母 public bool IsUpChar(string str_UpChar) &#123; return System.Text.RegularExpressions.Regex.IsMatch(str_UpChar, @"^[A-Z]+$"); &#125; 2. 小写字母 public bool IsLowChar(string str_UpChar) &#123; return System.Text.RegularExpressions.Regex.IsMatch(str_UpChar, @"^[a-z]+$"); &#125; 3. 检查字符串重复出现的词 private void btnWord_Click(object sender, EventArgs e) &#123; System.Text.RegularExpressions.MatchCollection matches = System.Text.RegularExpressions.Regex.Matches(label1.Text, @"\b(?&lt;word&gt;\w+)\s+(\k&lt;word&gt;)\b", System.Text.RegularExpressions.RegexOptions.Compiled | System.Text.RegularExpressions.RegexOptions.IgnoreCase); if (matches.Count != 0) &#123; foreach (System.Text.RegularExpressions.Match match in matches) &#123; string word = match.Groups["word"].Value; MessageBox.Show(word.ToString(),"英文单词"); &#125; &#125; else &#123; MessageBox.Show("没有重复的单词"); &#125; &#125; 4. 替换字符串 private void button1_Click(object sender, EventArgs e) &#123; string strResult = System.Text.RegularExpressions.Regex.Replace(textBox1.Text, @"[A-Za-z]\*?", textBox2.Text); MessageBox.Show("替换前字符:" + "\n" + textBox1.Text + "\n" + "替换的字符:" + "\n" + textBox2.Text + "\n" + "替换后的字符:" + "\n" + strResult,"替换"); &#125; 5. 拆分字符串 private void button1_Click(object sender, EventArgs e) &#123; //实例: 甲025-8343243乙0755-2228382丙029-32983298389289328932893289丁 foreach (string s in System.Text.RegularExpressions.Regex.Split(textBox1.Text,@"\d&#123;3,4&#125;-\d*")) &#123; textBox2.Text+=s; //依次输出 "甲乙丙丁" &#125; &#125; 6. 验证输入字母 public bool IsLetter(string str_Letter) &#123; return System.Text.RegularExpressions.Regex.IsMatch(str_Letter, @"^[A-Za-z]+$"); &#125; 7. 验证输入汉字 public bool IsChinese(string str_chinese) &#123; return System.Text.RegularExpressions.Regex.IsMatch(str_chinese, @"^[\u4e00-\u9fa5],&#123;0,&#125;$"); &#125; 8. 验证输入字符串 (至少8个字符) public bool IsLength(string str_Length) &#123; return System.Text.RegularExpressions.Regex.IsMatch(str_Length, @"^.&#123;8,&#125;$"); &#125; 转载地址：http://my.oschina.net/lichaoqiang/blog/425595]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python对象]]></title>
    <url>%2F2020%2F02%2F29%2FPython%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[太久没写了~补上补上 类和对象是什么 类是现实世界或思维世界中的实体在计算机中的反映 它将数据以及这些数据上的操作封装在一起 类的定义12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576# 面向对象# 有意义的面向对象# 类 = 面向对象# 类，对象# 类最基本的作用：封装class Student(): # 一个班级的总数 sum = 0 # 类变量 实例变量 name = 'liupeng' # 特征 age = 0 # 私有变量 __ __score = 0 # 构造函数 # self显胜于隐 def __init__(self,name,age): # 初始化对象的属性 self.age = age self.name = name # 输出的为行参 print(age) print(name) # 访问类变量 self.__class__.sum += 1 print('当前班级总人数为：' + str(self.__class__.sum)) # print(Student.sum) # 行为 # 实例方法 def do_homework(self): print('name:'+ self.name) print('age:'+ str(self.age)) print('homework') # 类方法 # 装饰器 @classmethod def plus_sum(cls): cls.sum +=1 print(cls.sum) # 静态方法 @staticmethod def add(x,y): print(Student.sum) print('This is a static methond') # 私有方法 def __myGirl(): print('WhyME~')# 实例化student1 = Student('石敢当',18)student2 = Student('喜来乐',19)print(student1.name)print(student2.name)print(Student.name)student1.do_homework()# 类方法调用Student.plus_sum()student1.plus_sum()# 静态方法调用Student.add(1,2)student1.add(1,2)# 私有方法直接调用(报错)student1.__myGirl()# 私有变量直接调用(报错)print(student1.__score)print(student1._Student__score) # 跳过私有 可以直接访问。。。这机制也是没谁了# 直接调用(添加实例变量)student1.__score = -1print(student1.__score)# 打印类中的实例变量字典print(student1.__dict__) 类的继承12345678910111213141516171819202122from python5 import Personclass Student(Person): def __init__(self,school,name,age): self.school = school #Person.__init__(self,name,age) super(Student,self).__init__(name,age) def do_homework(self): super(Student,self).do_homework() print('english homework ~')# 继承测试print(Student.sum)student1 = Student('人民路小学','石敢当',18)student1.getName()student1.getAge()student1.do_homework()# print(Student.__dict__)# print(Person.__dict__) 1234567891011121314class Person(): sum = 0 def __init__(self,name,age): self.name = name self.age = age def getName(self): print(self.name) def getAge(self): print(self.age) def do_homework(self): print('parent homework ~')]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python的包，模块及作用域]]></title>
    <url>%2F2019%2F11%2F18%2FPython%E7%9A%84%E5%8C%85%EF%BC%8C%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[简单写写~ 工程的组织结构 包 》模块 》类 》函数，变量 包与模块 包从物理意义上来说就是文件夹(文件夹下面需要包含__init__.py) 模块就是.py文件 导入模块相对应的目录结构~就不贴图了 123456# python文件夹下demo.py文件# 模块的内置属性(这个是只对外导出提供A,B)__all__=['A','B']A = 1B = 2C = 3 12345678910111213141516171819202122# import python.dome as ti# print(ti.A)# from python.dome import A# print(A)# from python import dome# print(dome.A)from python.dome import *print(A)print(B)print(C)# 一行无法写下代码的方式~ 不过一行最好不要超过 80个字符# from python.dome import A,\# B# print(B)# from python.dome import (A,# B)# print(B) __init__.py的使用 每个包文件夹下都有一个__init__.py文件 __init__.py文件 1234567891011# 导入包时的必定的首次执行# a = 'This __init__.py file'# print(a)# 控制可以导出的模块#__all__=['dome1']# 初始化包import sysimport datetimeimport io 使用文件 12345678910# 导包必定执行 __init__.py# import python __init__.py# 利用__init__.py进行导出包限制# from python import *# print(dome1.E)# 利用__init__.py初始化导包import pythonprint(python.sys.path) 包和模块的常见错误 包和模块是不会被重复导入 避免循环导入 导入模块的时候，所导入的模块会执行一遍代码 模块的内置变量 双下划线变量，系统内置 123# 打印当前模块的所有变量infos = dir()print(infos) 常用的系统内置变量 __name__ 非入口文件：包名+模块名 入口文件：__main__ __package__ 非入口文件：包名 入口文件：无 __doc__ 模块的文档说明 __file__ 入口文件：磁盘上的绝对路径 非入口文件：当前文件名 1234567891011# 入口文件print('name:' + __name__)print('package:' + (__package__ or '当前模块不属于任何包'))print('doc:' + (__doc__ or '当前模块无文档注释' ) )print('file:' + __file__)&gt;&gt;&gt;name:__main__package:当前模块不属于任何包doc:当前模块无文档注释file:f:/Python学习/PythonProject/Python3/demo11.py 123456789# 非入口文件# demo1.py""" 我是注释"""print('name:' + __name__)print('package:' + (__package__ or '当前模块不属于任何包'))print('doc:' + (__doc__ or '当前模块无文档注释' ) )print('file:' + __file__) 12345678910# 非入口文件import python.dome1&gt;&gt;&gt;name:python.dome1package:pythondoc: 我是注释file:f:\Python学习\PythonProject\Python3\python\dome1.py 相对导入 相对导入（子模块引入时可用 . .. …） 入口文件不能使用 绝对导入 绝对导入（以入口文件为顶级目录） 变量的作用域1234a = 2def temp(): a = 1 print(a) for循环不算单独的作用域1234567b = &#123;1,2,3&#125;def temp2(b): for c in b: print(c) d = 4 print(d)temp2(b) global使变量升级为全局变量12345def temp3(): global a a = 1temp3()print(a)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python函数]]></title>
    <url>%2F2019%2F11%2F08%2FPython%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[简单认识Python函数~ 认识函数12a = 1.123456print(round(a,2)) 查找函数的用法12b = help(round)print(b) python之禅1python this 函数的好处 功能性 隐藏细节 避免编写重复代码 自定义函数 函数的定义及运行特点123456789101112131415161718192021def funcname(parameter_list): pass# 参数列表可以没有 # return value None(如果不返回)# 实现两个数字的相加# 打印输入的参数def add(x, y): result = x+y return resultprint(add(1,2))# 死循环 (本电脑运行995次便会报错)# import sys# sys.setrecursionlimit(10000000)# 不要用python内置的函数def print_code(code): print(code)print(print_code('hello world')) 函数返回多个结果123456789101112# 函数返回多个值def damage(skill1, skill2): damage1 = skill1 * 3 damage2 = skill2 * 2 + 1 return damage1,damage2# 类型为元组print(type(damage(3,5)))# 利用多值进行接收，有意义的参数接收# 序列解包damage_skill1,damage_skill2 = damage(3,5)print(damage_skill1,damage_skill2) 序列解包及链式赋值1234567891011121314# a = 1# b = 2# c = 3# a,b,c = 1,2,3# 序列解包d = 1,2,3print(type(d))a,b,c = dprint(a,b,c)a=b=c=1print(a,b,c) 函数参数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# 函数参数# 必须参数 def add(x,y): result = x/y return result;# 关键字参数c = add(y=2,x=1)print(c)# 默认参数def students(name, age=18): print('我是'+name+',今年'+str(age))students('鹏')students('鹏',99)# 可变参数print('1','2','3','4')# (),[]def demo(*param): print(param) print(type(param))demo('q','w','e','h')a = (1,2,3,4,5)# 二维元组demo(a)# 非二维元组demo(*a)# 参数组合的复杂性def demo1(param1, param2=2, *param): print(param1) print(param2) print(param)# 关键字 可变参数# 参数的使用def squsum(*param): sum = 0 for i in param: sum+=i*i print(sum)squsum(1,2,4,5,3)#任意关键字参数def city_temp(**param): print(param) print(type(param)) for key,value in param: print(key,value)city_temp(bj='30',sh='20',hz='10')]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杭州景点推荐]]></title>
    <url>%2F2019%2F10%2F18%2F%E6%9D%AD%E5%B7%9E%E6%99%AF%E7%82%B9%E6%8E%A8%E8%8D%90%2F</url>
    <content type="text"><![CDATA[杭州。。。。还是有东西可以玩的嘛~ 景致拱宸桥 可以从武林门码头坐水上巴士去 3元一个人 周末水上巴士时间营业时间会长点 夜景还可以 地址 胜利河美食街 这个要晚上去 然而门店不如从前了 特意去就没必要 地址 河坊街 购买纪念品好去处 哈哈哈 里面有几家厉害的珠宝工作室书店茶馆 不在正街 靠你慢慢找 地址 北山街 各种名人老宅 西湖博物馆在这条街 地址 纯真年代书吧 这个书店在半山腰 要爬上去 不建议特意去 去西湖玩有空时准备去转转 地址 中国美术学院 浙江美术馆 国美 恒庐美术馆在这条街 地址 西溪国家湿地公园 风景区 可以坐摇橹船 有几家不错的酒店在内 里面河渚街有些小吃 美食街有一两家味道尚可 叫什么小镇 店名一时半会忘了 地址 西兴古镇 尚未开发的城中镇 整体居民为主 地址 良渚博物院 今年刚申遗成功 ～ 地址 杭州万科良良渚文化艺术中心 大屋顶 微信号：vankeletters 晓书馆、以及电影、小话剧还有一些活动 上这个公众号预约就是 地址 杭州菩提谷 杭州菩提谷 微信号：boutiquehouse 这家做的还不错 在周边山上 风景好的地方 感受原生态大自然优选这家 文艺塘栖古镇 这边有家老粮仓倒值得去看看 不过挺远 可以的话 自己租车去 地址 玉皇山 建议开车去 茶博物馆 琴谷在这边 地址 梅家坞 龙井一般去这买一块买 不过建议熟人陪着去 现在是老茶了 新茶清明节那阵买 买明前茶 地址 上天竺，中天竺，三天竺 烧香拜佛吃斋 推荐 地址 九溪烟树 适合步行拍照的美美哒的地方 地址 茅以升先生像 旁边的钱塘江大桥可以走一走。茅以升先生设计的 一百多年了 中日战争时 还被炸断过 旁边还有个六合塔 地址 城市阳台 这边比较洋气了 周末看灯光秀的地方。。。 跟西湖的喷泉秀不一样 地址 滨江樱花大道 樱花三四五月才有 空气好的时候可以从复兴桥段 起跑 至西兴桥段，骑单车也可以，早晨或晚上跑跑，白天有点吵 ，如果很早很早也不错，建议晚上吧，看看夜景，这一条吃宵夜的地方不少。 地址 金铂湾 一线江景这一片宵夜挺多, 滨江萧山那边比较现代 老城区保留了很多遗迹 城西景区空气相对好些 植物多些 比如西溪 比如良渚 地址 南湖路 老余杭也可以住个一两天 风景有南湖 遗迹运河南端 老桥 生活气息浓厚。吃的有家黄牛肉锅炒鸡好吃 地址 中国凉都黄牛肉馆 仓前羊锅村 有车的话 周末可以安排羊锅 良渚这边去羊锅村也近 地址]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python的分支，循环与条件]]></title>
    <url>%2F2019%2F10%2F17%2FPython%E7%9A%84%E5%88%86%E6%94%AF%EF%BC%8C%E5%BE%AA%E7%8E%AF%E4%B8%8E%E6%9D%A1%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[了解条件，循环语句~ 什么是表达式 表达式（Expression）就是运算符（operator）和操作数（operand）所构成的序列 表达式的优先级 请自行百度~ 贴图太多网页卡 常用的Python开发软件 vscode sublime pycharm 条件控制语句1234567891011121314151617181920212223""" 一段小程序"""account = 'liupeng'password = '123456'print('please input account')user_account = input()print('please input password')user_password = input()if (user_account == account) and (password == user_password): print('验证通过~')else: print('验证失败~')if True: pass # pass 占位符elif: passelse: pass 循环语句1234567891011121314151617181920212223242526con = 0# 适用于递归while con &lt;= 10 : con += 1 print(con)else: print('nb~') # 主要是用来遍历/循环 序列或者集合,字典x = [[1,2,3,4],('a','b','c')]for a in x: for b in a: if b == 2: # continue break print(b)else: print('结束~') # for(i=1; i&lt;10; i++)&#123;&#125;# range() 起始，结束，步长for a in range(0,10,2): print(a,end=' | ')for a in range(10,0,-2): print(a,end=' | ')]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python的变量与运算符]]></title>
    <url>%2F2019%2F10%2F15%2FPython%E7%9A%84%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[了解变量与运算符~ 变量什么是变量我认为是对各种数据的一种命名（便于管理，运算，赋予意义） 变量的命名规则 只能字母，数字，下划线 12&gt;&gt;&gt; 1A =1 //不能以数字开头SyntaxError: invalid syntax 系统的关键字 不能用在变量名中 保留关键字 1234&gt;&gt;&gt; and = 1SyntaxError: invalid syntax&gt;&gt;&gt; if =2SyntaxError: invalid syntax 不要用函数名做变量(建议) 12345678&gt;&gt;&gt; type(1)&lt;class 'int'&gt;&gt;&gt;&gt; type = 1&gt;&gt;&gt; type(1)Traceback (most recent call last): File "&lt;pyshell#38&gt;", line 1, in &lt;module&gt; type(1)TypeError: 'int' object is not callable 值类型与引用类型 值类型：int str tuple (不可变) 123456789101112&gt;&gt;&gt; a = 1&gt;&gt;&gt; b = a&gt;&gt;&gt; a = 3&gt;&gt;&gt; print(b)1&gt;&gt;&gt; a = 1&gt;&gt;&gt; b = 1&gt;&gt;&gt; id(a)1752811184&gt;&gt;&gt; id(b) //id() 内存地址1752811184 引用类型：list set dict (可变) 123456789101112&gt;&gt;&gt; a = [1,2,3]&gt;&gt;&gt; b = a&gt;&gt;&gt; a[0] = '10'&gt;&gt;&gt; print(b)['10', 2, 3]&gt;&gt;&gt; a = [1,2,3]&gt;&gt;&gt; b = [1,2,3]&gt;&gt;&gt; id(a)3120947373384&gt;&gt;&gt; id(b)3120947373704 列表的可变与元组的不可变 列表 ：list (可变) 123456&gt;&gt;&gt; a = [1,2,3]&gt;&gt;&gt; id(a)3120947372936&gt;&gt;&gt; a[0] = '3'&gt;&gt;&gt; id(a)3120947372936 元组：tuple（不可变） 12345678&gt;&gt;&gt; a = (1,2,3)&gt;&gt;&gt; id(a)3120947366000&gt;&gt;&gt; a[0] = '3'Traceback (most recent call last): File "&lt;pyshell#105&gt;", line 1, in &lt;module&gt; a[0] = '3'TypeError: 'tuple' object does not support item assignment 有意思的事例 1234&gt;&gt;&gt; a = (1,2,3,[1,2,4])&gt;&gt;&gt; a[3][1] = '66'&gt;&gt;&gt; print(a)(1, 2, 3, [1, '66', 4]) 运算符运算符号 + - * / //(整除) %(取余) **(平方，立方) 12345678910111213141516&gt;&gt;&gt; 'hello '+'world''hello world'&gt;&gt;&gt; [1,2,3]*3[1, 2, 3, 1, 2, 3, 1, 2, 3]&gt;&gt;&gt; 3-12&gt;&gt;&gt; 3/21.5&gt;&gt;&gt; 3//21&gt;&gt;&gt; 5%21&gt;&gt;&gt; 2**24&gt;&gt;&gt; 2**532 赋值运算符 = += -= *= /= %= **= //= 12345678910111213141516&gt;&gt;&gt; a = 1&gt;&gt;&gt; a += 1&gt;&gt;&gt; print(a)2&gt;&gt;&gt; a -= 1&gt;&gt;&gt; print(a)1&gt;&gt;&gt; a *= 2&gt;&gt;&gt; print(a)2&gt;&gt;&gt; a /= 4&gt;&gt;&gt; print(a)0.5&gt;&gt;&gt; a %= 1&gt;&gt;&gt; print(a)0.5 比较运算符 == != &gt; &lt; &gt;= &lt;= 123456789101112131415161718192021222324252627282930313233&gt;&gt;&gt; 1 == 1True&gt;&gt;&gt; 1 &gt; 1False&gt;&gt;&gt; 1 &gt;= 1True&gt;&gt;&gt; a = 1&gt;&gt;&gt; b = 2&gt;&gt;&gt; a != bTrue&gt;&gt;&gt; b = 1&gt;&gt;&gt; b+=b&gt;=1&gt;&gt;&gt; print(b)2&gt;&gt;&gt; 1 &gt; 1False&gt;&gt;&gt; 2 &gt; 3False&gt;&gt;&gt; 'a' &gt; 'b'False&gt;&gt;&gt; ord('a')97&gt;&gt;&gt; ord('b')98&gt;&gt;&gt; 'abc' &gt; 'abd'False&gt;&gt;&gt; [1,2,3] &lt; [2,3,4]True&gt;&gt;&gt; (1,2,3) &lt; (1,3,2)True 逻辑运算符 and(且) or(或) not(非) 12345678910111213141516&gt;&gt;&gt; True and TrueTrue&gt;&gt;&gt; True and FalseFalse&gt;&gt;&gt; True or TrueTrue&gt;&gt;&gt; True or FalseTrue&gt;&gt;&gt; False or FalseFalse&gt;&gt;&gt; not FalseTrue&gt;&gt;&gt; not TrueFalse&gt;&gt;&gt; not not TrueTrue int float 0被认为是Flase，非0表示True 12345678910&gt;&gt;&gt; 1 and 11&gt;&gt;&gt; 'a' and 'b''b'&gt;&gt;&gt; 'a' or 'b''a'&gt;&gt;&gt; not 'a'False&gt;&gt;&gt; not TrueFalse 空字符串被认为False，非空表示True 1234&gt;&gt;&gt; not ''True&gt;&gt;&gt; not 'gt'False 空的列表，元组，字典被认为是Flase，非空表示True 1234&gt;&gt;&gt; not []True&gt;&gt;&gt; not [1,2]False 结果的返回(有些绕~需要详解的请留言) 12345678910111213141516171819202122232425&gt;&gt;&gt; not 1False&gt;&gt;&gt; [1] or [][1]&gt;&gt;&gt; [] or [1][1]&gt;&gt;&gt; 'a' and 'b''b'&gt;&gt;&gt; '' and 'b'''&gt;&gt;&gt; 1 and 00&gt;&gt;&gt; 0 and 10&gt;&gt;&gt; 1 and 22&gt;&gt;&gt; 2 and 11&gt;&gt;&gt; 0 or 11&gt;&gt;&gt; 1 or 01&gt;&gt;&gt; 1 or 21 成员运算符 in not in 列表，元组，字典（key） 都是一样的使用 1234567891011&gt;&gt;&gt; a = 1&gt;&gt;&gt; a in [1,2,3,4,5]True&gt;&gt;&gt; b = 6&gt;&gt;&gt; b in [1,2,3,4,5]False&gt;&gt;&gt; b not in [1,2,3,4,5]True&gt;&gt;&gt; b = 'h'&gt;&gt;&gt; b in 'hello'True 身份运算符 is not is == 和 is ==比较的是值 is比较的是内存地址 123456789101112131415161718192021&gt;&gt;&gt; a = 1&gt;&gt;&gt; b = 1&gt;&gt;&gt; id(a)1752811184&gt;&gt;&gt; id(b)1752811184&gt;&gt;&gt; a == bTrue&gt;&gt;&gt; a is bTrue&gt;&gt;&gt; a = [1,2,3]&gt;&gt;&gt; b = [1,2,3]&gt;&gt;&gt; id(a)3120947373448&gt;&gt;&gt; id(b)3120947374280&gt;&gt;&gt; a == bTrue&gt;&gt;&gt; a is bFalse 值，身份，类型判断 值：== 判断 身份：is 判断 类型：isinstance() 12345678&gt;&gt;&gt; a = 1&gt;&gt;&gt; b = 2&gt;&gt;&gt; a == bFalse&gt;&gt;&gt; a is bFalse&gt;&gt;&gt; isinstance(a,int)True 位运算符 &amp;(按位与) |(按位或) ^(按位异或) ~(按位取反) &lt;&lt;(左移动) &gt;&gt;(右移动) 把数字当做二进制进行运算 123456&gt;&gt;&gt; a = 2&gt;&gt;&gt; b = 3&gt;&gt;&gt; a &amp; b2&gt;&gt;&gt; a | b3 总结]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python的基本数据类型]]></title>
    <url>%2F2019%2F10%2F14%2FPython%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[基本数据类型介绍~ Number：数字整数（int）12345&gt;&gt;&gt; 11&gt;&gt;&gt; type(1)&lt;class 'int'&gt; 浮点数（float）12345&gt;&gt;&gt; 1.51.5&gt;&gt;&gt; type(1.5)&lt;class 'float'&gt; 布尔类型（bool） 非空，非0大部分都为true 123456bool(-1) //truebool(1) //truebool('aa') //truebool(0) //falsebool('') //falsebool(None) //false 复数（complex）136j 进制转换问题12345678910111213Ob10 //2进制0o10 //8进制0x10 //16进制0x1F //16进制 31&gt;&gt;&gt; bin(10) //(任何进制)转2进制'0b1010' &gt;&gt;&gt; oct(0b111) //(任何进制)转8进制'0o7' &gt;&gt;&gt; int(0b111) //(任何进制)转10进制7 &gt;&gt;&gt; hex(0o77) //(任何进制)转16进制'0x3f' 组序列字符串（str）引号 单引号 : 包裹则为字符串 双引号：内部可以包裹单引号 三引号：可以换行(79建议换行) 12345678&gt;&gt;&gt;"let's go""let's go"&gt;&gt;&gt; """hello worldliupeng"""'\nhello world\nliupeng\n' 转义字符 \n 换行 \‘ 单引号 \t 横向制表符 \r 回车 12345678&gt;&gt;&gt;'let\'s go'&gt;&gt;&gt;print('hello \n world')'hello world'&gt;&gt;&gt;print(r'c:\nhello\nworld') //原始字符串'c:\nhello\nworld' 字符串的计算 按步长进行计算，尾部截取需要大一位 1234567891011121314&gt;&gt;&gt;"hello " + "world"'hello world'&gt;&gt;&gt;"hello"*3'hellohellohello'&gt;&gt;&gt;"hello world"[0]'h'&gt;&gt;&gt;"hello world"[-1]'d'&gt;&gt;&gt;"hello world"[0:5]'hello' 列表（list）1234567891011121314151617181920212223&gt;&gt;&gt; [1,2,3,4][1, 2, 3, 4]&gt;&gt;&gt; type([1,2,3,4])&lt;class 'list'&gt;&gt;&gt;&gt; type([1,2,3,4,True,False,'world'])&lt;class 'list'&gt;&gt;&gt;&gt; type([1,2,3,[5,1],True,False,'world'])&lt;class 'list'&gt;&gt;&gt;&gt; [1,2,3,4][0]1&gt;&gt;&gt; [1,2,3,4][0:2][1, 2]&gt;&gt;&gt; [1,2,3,4]*3[1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]&gt;&gt;&gt; [1,2,3,4]+[7,8][1, 2, 3, 4, 7, 8] 元组（tuple）数据操作和list没区别（不过引用不可变） 1234567891011&gt;&gt;&gt; (1,2,3,4,5)(1, 2, 3, 4, 5)&gt;&gt;&gt; type((1,2,4,5))&lt;class 'tuple'&gt;&gt;&gt;&gt; type((1))&lt;class 'int'&gt;&gt;&gt;&gt; type(())&lt;class 'tuple'&gt; 常用函数序列的都可以用 12345678910111213141516171819&gt;&gt;&gt; 3 in [1,2,3,4,5]True&gt;&gt;&gt; 3 not in [1,2,3,4,5]False&gt;&gt;&gt; len([1,2,3,4,5])5&gt;&gt;&gt; max([1,2,3,4,5])5&gt;&gt;&gt; min([1,2,3,4,5])1&gt;&gt;&gt; ord('a')97&gt;&gt;&gt; ord(' ')32 集合（set）无序，不可重复 1234567891011121314151617181920212223242526&gt;&gt;&gt; &#123;1,2,3&#125;&#123;1, 2, 3&#125;&gt;&gt;&gt; type(&#123;1,2,3,4&#125;)&lt;class 'set'&gt;&gt;&gt;&gt; &#123;1,2,1,5,2&#125;&#123;1, 2, 5&#125;&gt;&gt;&gt; 1 in &#123;1,2,3,4&#125;True&gt;&gt;&gt; 1 not in &#123;1,2,3,4&#125;False&gt;&gt;&gt; &#123;1,2,3,4&#125; - &#123;1,2&#125;&#123;3, 4&#125;&gt;&gt;&gt; &#123;1,2,3,4&#125; &amp; &#123;1,2&#125;&#123;1, 2&#125;&gt;&gt;&gt; &#123;1,2,3,4&#125; | &#123;1,2,8&#125;&#123;1, 2, 3, 4, 8&#125;&gt;&gt;&gt; type(set())&lt;class 'set'&gt; 字典（dict）key - value (key不可以重复，引用不可改变) 1234567891011&gt;&gt;&gt; &#123;1:1,2:2&#125;&#123;1: 1, 2: 2&#125;&gt;&gt;&gt; type(&#123;1:1,2:2&#125;)&lt;class 'dict'&gt;&gt;&gt;&gt; &#123;'q':1,'w':2&#125;['q']1&gt;&gt;&gt; type(&#123;&#125;)&lt;class 'dict'&gt; 总结]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python导学及安装]]></title>
    <url>%2F2019%2F10%2F14%2FPython%E5%AF%BC%E5%AD%A6%E5%8F%8A%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[了解Python~ 导学Python是一个动态的解释型语言。 Python能做什么？ 爬虫 大数据与数据分析（spark） 自动化运维与自动化测试 Web开发：Flask,Django 机器学习：Tensor Flow 胶水语言：混合其他如C++，Java等来编程。能够把用其他语言制作的各种模块联结在一起。 当你遇到问题时，随手拿起Python,编写一个工具，这才是Python的正确打开方式~ 安装window安装地址 安装的时候，一定要勾选环境变量。。改下安装地址，其它的默认就行 打开IDLE（window应用直接搜索） 1print('hello world')]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue组件]]></title>
    <url>%2F2019%2F10%2F11%2FVue%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[了解Vue组件 is12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;title&gt;组件使用中的细节点&lt;/title&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;script src=&quot;./vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;table&gt; &lt;tbody&gt; &lt;tr is=&quot;row&quot;&gt;&lt;/tr&gt; &lt;tr is=&quot;row&quot;&gt;&lt;/tr&gt; &lt;tr is=&quot;row&quot;&gt;&lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt;&lt;script&gt; //html5语法table下面必须有tr,不然我们的模板无法处于table内 Vue.component(&quot;row&quot;,&#123; template:&apos;&lt;tr&gt;&lt;td&gt;This is a row&lt;/td&gt;&lt;/tr&gt;&apos; &#125;); var vm = new Vue(&#123; el: &quot;#root&quot; &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; ref及子组件data12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;组件使用中的细节点&lt;/title&gt; &lt;script src=&apos;./vue.js&apos;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;counter ref=&quot;one&quot; @change=&quot;handleChange&quot;&gt;&lt;/counter&gt; &lt;counter ref=&quot;two&quot; @change=&quot;handleChange&quot;&gt;&lt;/counter&gt; &lt;div&gt;&#123;&#123;total&#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; //子组件data必须是函数，保证多个相同子组件数据互不干涉 Vue.component(&apos;counter&apos;, &#123; template: &apos;&lt;div @click=&quot;handleClick&quot;&gt;&#123;&#123;number&#125;&#125;&lt;/div&gt;&apos;, data: function() &#123; return &#123; number: 0 &#125; &#125;, methods: &#123; handleClick: function() &#123; this.number ++ this.$emit(&apos;change&apos;) &#125; &#125; &#125;) var vm = new Vue(&#123; el: &apos;#root&apos;, data: &#123; total: 0 &#125;, methods: &#123; handleChange: function() &#123; //写在html上是获取文档 //在组件上是获取整个实例 this.total = this.$refs.one.number + this.$refs.two.number &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 父子组件的数据传递123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;父子组件传值&lt;/title&gt; &lt;script src=&apos;./vue.js&apos;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;counter :count=&quot;3&quot; @inc=&quot;handleIncrease&quot;&gt;&lt;/counter&gt; &lt;counter :count=&quot;2&quot; @inc=&quot;handleIncrease&quot;&gt;&lt;/counter&gt; &lt;div&gt;&#123;&#123;total&#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var counter = &#123; props: [&apos;count&apos;], data: function() &#123; return &#123; number: this.count &#125; &#125;, template: &apos;&lt;div @click=&quot;handleClick&quot;&gt;&#123;&#123;number&#125;&#125;&lt;/div&gt;&apos;, methods: &#123; handleClick: function() &#123; this.number = this.number + 2; this.$emit(&apos;inc&apos;, 2) &#125; &#125; &#125; var vm = new Vue(&#123; el: &apos;#root&apos;, data: &#123; total: 5 &#125;, components: &#123; counter: counter &#125;, methods: &#123; handleIncrease: function(step) &#123; this.total += step &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 组件参数校验与非props特性1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;组件参数校验与非Props特性&lt;/title&gt; &lt;script src=&apos;./vue.js&apos;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;child content=&quot;hell&quot;&gt;&lt;/child&gt; &lt;/div&gt; &lt;script&gt; Vue.component(&apos;child&apos;, &#123; //父给子组件传递数据,不接收(非props特性) // props: &#123; //父给子组件传递数据，进行接收(props特性) // content: &#123; // type: String, //类型接收限制，多类型用数组 // // required: false, // // default: &apos;default value&apos;, //参数必须传递 // // validator: function(value) &#123; //函数自定义检验 // // return (value.length &gt; 5) // // &#125; // &#125; // &#125;, template: &apos;&lt;div&gt;hello&lt;/div&gt;&apos; &#125;) var vm = new Vue(&#123; el: &apos;#root&apos; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 组件绑定原生事件12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;给组件绑定原生事件&lt;/title&gt; &lt;script src=&apos;./vue.js&apos;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;child @click.native=&quot;handleClick&quot;&gt;&lt;/child&gt; &lt;!--.native 绑定原生事件--&gt; &lt;/div&gt; &lt;script&gt; Vue.component(&apos;child&apos;, &#123; template: &apos;&lt;div&gt;Child&lt;/div&gt;&apos;, &#125;) var vm = new Vue(&#123; el: &apos;#root&apos;, methods: &#123; handleClick: function() &#123; alert(&apos;click&apos;) &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 非父子组件间的传值1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;非父子组件的传值&lt;/title&gt; &lt;script src=&quot;./vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;child content=&quot;childOne&quot;&gt;&lt;/child&gt; &lt;child content=&quot;childTwo&quot;&gt;&lt;/child&gt; &lt;/div&gt; &lt;script&gt; // bus 总线 进行非父子组件的传值 Vue.prototype.bus = new Vue() Vue.component(&apos;child&apos;, &#123; props: [&apos;content&apos;], data: function() &#123; return &#123; myContent: this.content &#125; &#125;, template: &apos;&lt;div @click=&quot;handleClick&quot;&gt;&#123;&#123;myContent&#125;&#125;&lt;/div&gt;&apos;, methods: &#123; handleClick: function() &#123; this.bus.$emit(&apos;change&apos;, this.myContent) &#125; &#125;, mounted: function() &#123; var this_ = this; this.bus.$on(&apos;change&apos;, function(content) &#123; this_.myContent = content &#125;) &#125; &#125;) var vm = new Vue(&#123; el: &quot;#root&quot; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 插槽单个插槽12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;插槽 - 单个插槽&lt;/title&gt; &lt;script src=&quot;./vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;child&gt; &lt;h1&gt;hello&lt;/h1&gt; &lt;/child&gt; &lt;/div&gt; &lt;script&gt; var child = &#123; template: &apos;&lt;div&gt;&lt;slot&gt;默认插槽的内容&lt;/slot&gt;&lt;/div&gt;&apos; &#125; var vm = new Vue(&#123; components: &#123; child: child &#125;, el: &quot;#root&quot; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 具名插槽1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;插槽 - 具名插槽&lt;/title&gt; &lt;script src=&quot;./vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;child&gt; &lt;h1 slot=&quot;header&quot;&gt;header&lt;/h1&gt; &lt;h1 slot=&quot;footer&quot;&gt;footer&lt;/h1&gt; &lt;/child&gt; &lt;/div&gt; &lt;script&gt; var child = &#123; template: `&lt;div&gt; &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt; &lt;div&gt; &lt;h2&gt;content&lt;/h2&gt; &lt;/div&gt; &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt; &lt;/div&gt;` &#125; var vm = new Vue(&#123; components: &#123; child: child &#125;, el: &quot;#root&quot; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 作用域插槽123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Vue中的作用域插槽&lt;/title&gt; &lt;script src=&apos;./vue.js&apos;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;child&gt; &lt;template slot-scope=&quot;props&quot;&gt; &lt;h1&gt;&#123;&#123;props.item&#125;&#125;&lt;/h1&gt; &lt;/template&gt; &lt;/child&gt; &lt;/div&gt; &lt;script&gt; Vue.component(&apos;child&apos;, &#123; data: function() &#123; return &#123; list: [1, 2, 3, 4] &#125; &#125;, template: `&lt;div&gt; &lt;ul&gt; &lt;slot v-for=&quot;item of list&quot; :item=item &gt;&lt;/slot&gt; &lt;/ul&gt; &lt;/div&gt;` &#125;) var vm = new Vue(&#123; el: &apos;#root&apos; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 动态组件与v-once指令1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;动态组件与v-once指令&lt;/title&gt; &lt;script src=&apos;./vue.js&apos;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;!-- &lt;component :is=&quot;type&quot;&gt;&lt;/component&gt; --&gt; &lt;child-one v-if=&quot;type ===&apos;child-one&apos;&quot;&gt;&lt;/child-one&gt; &lt;child-two v-if=&quot;type ===&apos;child-two&apos;&quot;&gt;&lt;/child-two&gt; &lt;button @click=&quot;handleBtnClick&quot;&gt;change&lt;/button&gt; &lt;/div&gt; &lt;script&gt; Vue.component(&apos;child-one&apos;, &#123; template: &apos;&lt;div v-once&gt;child-one&lt;/div&gt;&apos; &#125;) Vue.component(&apos;child-two&apos;, &#123; template: &apos;&lt;div v-once&gt;child-two&lt;/div&gt;&apos; &#125;) var vm = new Vue(&#123; el: &apos;#root&apos;, data: &#123; type: &apos;child-one&apos; &#125;, methods: &#123; handleBtnClick: function() &#123; this.type = (this.type === &apos;child-one&apos; ? &apos;child-two&apos;: &apos;child-one&apos;); &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue基础]]></title>
    <url>%2F2019%2F09%2F30%2FVue%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[基础使用~ 生命周期函数介绍生命周期函数就是vue实例在某个时间点会自动执行的函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Vue实例生命周期函数&lt;/title&gt; &lt;script src=&quot;./vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;script&gt; // 生命周期函数就是vue实例在某一个时间点会自动执行的函数 var vm = new Vue(&#123; el: &quot;#app&quot;, template: &quot;&lt;div&gt;&#123;&#123;test&#125;&#125;&lt;/div&gt;&quot;, data: &#123; test: &quot;hello world&quot; &#125;, beforeCreate: function() &#123; console.log(&quot;beforeCreate&quot;); &#125;, created: function() &#123; console.log(&quot;created&quot;); &#125;, beforeMount: function() &#123; console.log(this.$el); console.log(&quot;beforeMount&quot;); &#125;, mounted: function() &#123; console.log(this.$el); console.log(&quot;mounted&quot;); &#125;, beforeDestroy: function() &#123; console.log(&quot;beforeDestroy&quot;); &#125;, destroyed: function() &#123; console.log(&quot;destroyed&quot;); &#125;, beforeUpdate: function() &#123; console.log(&quot;beforeUpdate&quot;); &#125;, updated: function() &#123; console.log(&quot;updated&quot;); &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 模板语法后续会继续增加~ 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;模版语法&lt;/title&gt; &lt;script src=&quot;./vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;div&gt;&#123;&#123;name + &apos; Lee&apos;&#125;&#125;&lt;/div&gt; &lt;div v-text=&quot;name + &apos; Lee&apos;&quot;&gt;&lt;/div&gt; &lt;!--不做html解析--&gt; &lt;div v-html=&quot;name + &apos; Lee&apos;&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: &quot;#app&quot;, data: &#123; name: &quot;Dell&quot; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 计算属性，方法和侦听器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;计算属性，方法，侦听器&lt;/title&gt; &lt;script src=&quot;./vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &#123;&#123;fullName&#125;&#125; &#123;&#123;age&#125;&#125; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: &quot;#app&quot;, data: &#123; firstName: &quot;Dell&quot;, lastName: &quot;Lee&quot;, fullName: &quot;Dell Lee&quot;, age: 28 &#125;, //侦听器 watch: &#123; firstName: function() &#123; console.log(&quot;计算了一次&quot;); this.fullName = this.firstName + &quot; &quot; + this.lastName; &#125;, lastName: function() &#123; console.log(&quot;计算了一次&quot;); this.fullName = this.firstName + &quot; &quot; + this.lastName; &#125; &#125; // 方法 // methods: &#123; // fullName: function() &#123; // console.log(&quot;计算了一次&quot;); // return this.firstName + &quot; &quot; + this.lastName; // &#125; // &#125; // 计算属性 // computed: &#123; // fullName: function() &#123; // console.log(&quot;计算了一次&quot;); // return this.firstName + &quot; &quot; + this.lastName // &#125; // &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 计算属性的setter和getter1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;计算属性的setter和getter&lt;/title&gt; &lt;script src=&quot;./vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &#123;&#123;fullName&#125;&#125; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: &quot;#app&quot;, data: &#123; firstName: &quot;Dell&quot;, lastName: &quot;Lee&quot; &#125;, computed: &#123; fullName: &#123; get: function() &#123; return this.firstName + &quot; &quot; + this.lastName &#125;, set: function(value) &#123; var arr = value.split(&quot; &quot;); this.firstName = arr[0]; this.lastName = arr[1]; &#125; &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 样式绑定两种：对象语法，数组语法 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Vue中的样式绑定&lt;/title&gt; &lt;script src=&quot;./vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;div :style=&quot;[styleObj, &#123;fontSize: &apos;20px&apos;&#125;]&quot; @click=&quot;handleDivClick&quot;&gt; Hello world &lt;/div&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: &quot;#app&quot;, data: &#123; styleObj: &#123; color: &quot;black&quot; &#125; &#125;, methods: &#123; handleDivClick: function() &#123; this.styleObj.color = this.styleObj.color === &quot;black&quot; ? &quot;red&quot; : &quot;black&quot;; &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 条件渲染12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Vue中的条件渲染&lt;/title&gt; &lt;script src=&quot;./vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;div v-if=&quot;show&quot;&gt; 用户名：&lt;input key=&quot;username&quot; /&gt; &lt;!--key防止vue复用--&gt; &lt;/div&gt; &lt;div v-else&gt; 邮箱名：&lt;input key=&quot;password&quot;/&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: &quot;#app&quot;, data: &#123; show: false, &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 列表渲染数组123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Vue中的列表渲染&lt;/title&gt; &lt;script src=&quot;./vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;template v-for=&quot;(item,index) of list&quot;&gt; &lt;div &gt; &#123;&#123;item.text&#125;&#125; ---- &#123;&#123;index&#125;&#125; &lt;/div&gt; &lt;span&gt; &#123;&#123;item.text&#125;&#125; &lt;/span&gt; &lt;/template&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; //push pop shift unshift splice sort reverse 动态改变数据直接页面生效 //或者改变list引用 //Vue.set()或vm.$set() var vm = new Vue(&#123; el:&quot;#app&quot;, data:&#123; list:[ &#123; id:&quot;1&quot;, text:&quot;hello&quot; &#125;, &#123; id:&quot;2&quot;, text:&quot;world&quot; &#125;, &#123; id:&quot;3&quot;, text:&quot;emmmmm&quot; &#125; ] &#125; &#125;)&lt;/script&gt;&lt;/html&gt; 对象12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Vue中的列表渲染&lt;/title&gt; &lt;script src=&quot;./vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;div v-for=&quot;(item, key, index) of userInfo&quot;&gt; &#123;&#123;item&#125;&#125; --- &#123;&#123;key&#125;&#125; -- &#123;&#123;index&#125;&#125; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; //Vue动态改变，Vue.set(vm.userInfo,&quot;&quot;,&quot;&quot;) //vm.$set(vm.userInfo,&quot;&quot;,&quot;&quot;) var vm = new Vue(&#123; el: &quot;#app&quot;, data: &#123; userInfo: &#123; name: &quot;Dell&quot;, age: 28, gender: &quot;male&quot;, salary: &quot;secret&quot; &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue入门]]></title>
    <url>%2F2019%2F09%2F29%2FVue%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[简介及使用方式~中文社区 简单介绍刚开始学习vue建议直接下载js包进行引入学习 开发版下载 vue.放在当前目录 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;script src=&apos;./vue.js&apos;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt;&#123;&#123;content&#125;&#125;&lt;/div&gt; &lt;div&gt;&#123;&#123;content&#125;&#125;&lt;/div&gt; &lt;script&gt; //以前js的写法 //var dom = document.getElementById(&apos;app&apos;); //dom.innerHTML= &apos;Hello World&apos;; /*setTimeout(function() &#123; var dom = document.getElementById(&apos;app&apos;); dom.innerHTML= &apos;bye world&apos;; &#125;)*/ //vue的写法 //创建一个实例 var app = new Vue(&#123; el: &apos;#app&apos;, //实例所管理的区域（id为app的区域） data: &#123; content: &apos;Hello World&apos; //区域中所管理的数据 &#125; &#125;); setTimeout(function() &#123; app.$data.content = &apos;bye world&apos; &#125;, 2000); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; ToDoList简单练习123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;TodoList&lt;/title&gt; &lt;script src=&quot;./vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;inputValue&quot;/&gt; //模型双向绑定 &lt;button v-on:click=&quot;handleBtnClick&quot;&gt;提交&lt;/button&gt; //事件的触发 &lt;ul&gt; &lt;li v-for= &quot;item in list&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; //循环 &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; var app = new Vue(&#123; el: &apos;#app&apos;, data: &#123; list: [], inputValue: &apos;&apos; &#125;, methods: &#123; handleBtnClick: function () &#123; this.list.push(this.inputValue); this.inputValue =&apos;&apos;; &#125; &#125; &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 组件化父组件向子组件传值12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;TodoList&lt;/title&gt; &lt;script src=&quot;./vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;inputValue&quot;/&gt; &lt;button v-on:click=&quot;handleBtnClick&quot;&gt;提交&lt;/button&gt; &lt;ul&gt; &lt;!--v-bind 向组件传递数 父-&gt;子组件 --&gt; &lt;todo-item v-bind:content=&quot;item&quot; v-for= &quot;item in list&quot;&gt;&lt;/todo-item&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; //全局组件 /*Vue.component(&quot;TodoItem&quot;,&#123; props:[&apos;content&apos;], //接收父组件的传值 template: &quot;&lt;li&gt;&#123;&#123;content&#125;&#125;&lt;/li&gt;&quot; //模板 &#125;)*/ //局部组件 var TodoItem = &#123; props:[&apos;content&apos;], //接收父组件的传值 template: &quot;&lt;li&gt;&#123;&#123;content&#125;&#125;&lt;/li&gt;&quot; //模板 &#125; var app = new Vue(&#123; el: &apos;#app&apos;, components: &#123; //局部组件注册 TodoItem: TodoItem &#125;, data: &#123; list: [], inputValue: &apos;&apos; &#125;, methods: &#123; handleBtnClick: function () &#123; this.list.push(this.inputValue); this.inputValue =&apos;&apos;; &#125; &#125; &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 子组件向父组件传值12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;TodoList&lt;/title&gt; &lt;script src=&quot;./vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;inputValue&quot;/&gt; &lt;button v-on:click=&quot;handleBtnClick&quot;&gt;提交&lt;/button&gt; &lt;ul&gt; &lt;!--v-bind 向组件传递数 父-&gt;子组件 --&gt; &lt;todo-item v-bind:content=&quot;item&quot; v-bind:index=&quot;index&quot; v-for= &quot;(item,index) in list&quot; @delete=&quot;handleItemDelete&quot;&gt; &lt;!--接收子组件的触发事件--&gt; &lt;/todo-item&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; //全局组件 /*Vue.component(&quot;TodoItem&quot;,&#123; props:[&apos;content&apos;], //接收父组件的传值 template: &quot;&lt;li&gt;&#123;&#123;content&#125;&#125;&lt;/li&gt;&quot; //模板 &#125;)*/ //局部组件 var TodoItem = &#123; props:[&apos;content&apos;,&apos;index&apos;], //接收父组件的传值 template: &quot;&lt;li @click=&apos;handleBtnClickItemClick&apos;&gt;&#123;&#123;content&#125;&#125;&lt;/li&gt;&quot;, //模板 methods:&#123; handleBtnClickItemClick: function()&#123; this.$emit(&quot;delete&quot;,this.index); //子组件通过事件触发传给父组件 &#125; &#125; &#125; var app = new Vue(&#123; el: &apos;#app&apos;, components: &#123; //局部组件注册 TodoItem: TodoItem &#125;, data: &#123; list: [], inputValue: &apos;&apos; &#125;, methods: &#123; handleBtnClick: function () &#123; this.list.push(this.inputValue); this.inputValue =&apos;&apos;; &#125;, handleItemDelete: function(index)&#123; this.list.splice(index,1) &#125; &#125; &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ElasticSearch入门]]></title>
    <url>%2F2019%2F09%2F20%2FElasticSearch%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[简介及使用方式~ 官方文档 中文社区 什么是ElasticSearch 基于Apache Lucene构建的开源搜索引擎 采用Java编写，提供简单易用的RESTFul API 轻松的横向扩展，支持PB级别的结构化或非结构化数据 常见术语文档 Document 用户存储在es中的数据 Json Object,由字段（Field）组成，常见数据类型如下 字符串：text,keyword 数值类型：long,integer,short,byte,double,float,half_float,scaled_float 布尔：boolean 日期：date 二进制：binary 范围类型：integer_range,float_range,long_range,double_range,date_range 每个文档有唯一的id标识 自行生成 es自动生成 Document MetaData 元数据，用于标注文档的相关信息 _index：文档所在的索引名 _type：文档所在的类型名 _id：文档唯一id _uid：组合id，由 _type和 _id组成（6.x _type不再起作用，同 _id一样） _source：文档的原始Json数据，可以从这里获取每个字段的内容 _all：整合所有字段内容到该字段，默认禁用 索引 Index 由具有相同字段的文档列表组成 索引中存储具有相同结构的文档 每个索引都有自己的mapping定义，用于定义字段名和类型 一个集群可以有多个索引 节点 Node 一个Elasticsearch的运行实例 集群 Cluster 由一个或多个节点组成，对外服务 Rest API REST - REpresentational State Transfer URI指定资源，如Index，Document等 Http Method 指明资源操作类型，如GET，POST，PUT，DELETE等 API基本格式 http://:/&lt;索引&gt;/&lt;类型&gt;/&lt;文档id&gt; 常用HTTP动词GET/PUT/POST/DELETE 常见的交互方式 Curl命令行 Kibana DevTools 索引 API es有专门的Index API，用于创建，更新，删除索引配置等 创建索引123456789//requestPUT /test_index//response&#123; &quot;acknowledged&quot;: true, &quot;shards_acknowledged&quot;: true, &quot;index&quot;: &quot;test_index&quot;&#125; 查看现有索引12345//requestGET _cat/indices//responsegreen open test_index qnsE8tAgTFW6oJlYfRKh9A 5 1 0 0 2.2kb 1.1kb 删除索引1234567//requestDELETE /test_index//response&#123; &quot;acknowledged&quot;: true&#125; 文档 API创建文档如果索引不存在则会自动创建 12345678910111213141516171819202122//requestPUT /test_index/doc/1 //PUT/index/type/id&#123; &quot;username&quot;:&quot;liupeng&quot;, &quot;age&quot;:1&#125;//response&#123; &quot;_index&quot;: &quot;test_index&quot;, &quot;_type&quot;: &quot;doc&quot;, &quot;_id&quot;: &quot;1&quot;, &quot;_version&quot;: 1, &quot;result&quot;: &quot;created&quot;, &quot;_shards&quot;: &#123; &quot;total&quot;: 2, &quot;successful&quot;: 1, &quot;failed&quot;: 0 &#125;, &quot;_seq_no&quot;: 0, &quot;_primary_term&quot;: 1&#125; 查询文档12345678910111213141516171819202122232425262728293031323334353637//requestGET /test_index/doc/_search&#123; &quot;query&quot;: &#123; &quot;term&quot;: &#123; &quot;_id&quot;: &quot;1&quot; &#125; &#125;&#125;//response&#123; &quot;took&quot;: 33, //查询耗时 &quot;timed_out&quot;: false, &quot;_shards&quot;: &#123; &quot;total&quot;: 5, &quot;successful&quot;: 5, &quot;skipped&quot;: 0, &quot;failed&quot;: 0 &#125;, &quot;hits&quot;: &#123; &quot;total&quot;: 1, //符合条件总数 &quot;max_score&quot;: 1, &quot;hits&quot;: [ //返回的文档详情数据数组，默认前10个文档 &#123; &quot;_index&quot;: &quot;test_index&quot;, //索引名 &quot;_type&quot;: &quot;doc&quot;, &quot;_id&quot;: &quot;1&quot;, //文档id &quot;_score&quot;: 1, //文档得分 &quot;_source&quot;: &#123; //文档详情 &quot;username&quot;: &quot;liupeng&quot;, &quot;age&quot;: 1 &#125; &#125; ] &#125;&#125; 批量创建文档 es一次创建多个文档，从而减少网络传输开销，提升写入速率 endpoint 为_bulk 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//requestPOST _bulk&#123;&quot;index&quot;:&#123;&quot;_index&quot;:&quot;test_index&quot;,&quot;_type&quot;:&quot;doc&quot;,&quot;_id&quot;:&quot;3&quot;&#125;&#125;&#123;&quot;username&quot;:&quot;alfred&quot;,&quot;age&quot;:&quot;10&quot;&#125;&#123;&quot;delete&quot;:&#123;&quot;_index&quot;:&quot;test_index&quot;,&quot;_type&quot;:&quot;doc&quot;,&quot;_id&quot;:&quot;1&quot;&#125;&#125;&#123;&quot;update&quot;:&#123;&quot;_id&quot;:&quot;2&quot;,&quot;_index&quot;:&quot;test_index&quot;,&quot;_type&quot;:&quot;doc&quot;&#125;&#125;&#123;&quot;doc&quot;:&#123;&quot;age&quot;:&quot;20&quot;&#125;&#125;//response&#123; &quot;took&quot;: 441, &quot;errors&quot;: true, //结果 &quot;items&quot;: [ &#123; &quot;index&quot;: &#123; &quot;_index&quot;: &quot;test_index&quot;, &quot;_type&quot;: &quot;doc&quot;, &quot;_id&quot;: &quot;3&quot;, &quot;_version&quot;: 1, &quot;result&quot;: &quot;created&quot;, &quot;_shards&quot;: &#123; &quot;total&quot;: 2, &quot;successful&quot;: 2, &quot;failed&quot;: 0 &#125;, &quot;_seq_no&quot;: 0, &quot;_primary_term&quot;: 1, &quot;status&quot;: 201 &#125; &#125;, &#123; &quot;delete&quot;: &#123; &quot;_index&quot;: &quot;test_index&quot;, &quot;_type&quot;: &quot;doc&quot;, &quot;_id&quot;: &quot;1&quot;, &quot;_version&quot;: 1, &quot;result&quot;: &quot;not_found&quot;, &quot;_shards&quot;: &#123; &quot;total&quot;: 2, &quot;successful&quot;: 1, &quot;failed&quot;: 0 &#125;, &quot;_seq_no&quot;: 0, &quot;_primary_term&quot;: 1, &quot;status&quot;: 404 &#125; &#125;, &#123; &quot;update&quot;: &#123; &quot;_index&quot;: &quot;test_index&quot;, &quot;_type&quot;: &quot;doc&quot;, &quot;_id&quot;: &quot;2&quot;, &quot;status&quot;: 404, &quot;error&quot;: &#123; &quot;type&quot;: &quot;document_missing_exception&quot;, &quot;reason&quot;: &quot;[doc][2]: document missing&quot;, &quot;index_uuid&quot;: &quot;yfEfCn2cSrKb0qCX8Ide4g&quot;, &quot;shard&quot;: &quot;2&quot;, &quot;index&quot;: &quot;test_index&quot; &#125; &#125; &#125; ]&#125; 批量查询文档 es允许一次查询多个文档 endpoint为 _maget 123456789101112131415161718192021222324252627282930313233343536373839//requestGET /_mget&#123; &quot;docs&quot;:[ &#123; &quot;_index&quot;:&quot;test_index&quot;, &quot;_type&quot;:&quot;doc&quot;, &quot;_id&quot;:&quot;1&quot; &#125;, &#123; &quot;_index&quot;:&quot;test_index&quot;, &quot;_type&quot;:&quot;doc&quot;, &quot;_id&quot;:&quot;2&quot; &#125; ]&#125;//response&#123; &quot;docs&quot;: [ &#123; &quot;_index&quot;: &quot;test_index&quot;, &quot;_type&quot;: &quot;doc&quot;, &quot;_id&quot;: &quot;1&quot;, &quot;_version&quot;: 1, &quot;found&quot;: true, &quot;_source&quot;: &#123; &quot;username&quot;: &quot;liupeng&quot;, &quot;age&quot;: 1 &#125; &#125;, &#123; &quot;_index&quot;: &quot;test_index&quot;, &quot;_type&quot;: &quot;doc&quot;, &quot;_id&quot;: &quot;2&quot;, &quot;found&quot;: false &#125; ]&#125;]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Webpack安装及使用]]></title>
    <url>%2F2019%2F09%2F19%2Fwebpack%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[简单了解~环境搭建，安装及配置中文文档 英文文档 含义主要用于模块打包工具（ES Module，CommonJS，CMD，ADM） 安装 nodejs 12node -vnpm -v webpack 123456789101112131415161718192021#前提$ mkdir webpack-demo$ cd webpack-demo$ npm init#全局安装$ npm install webpack webpack-cli -g$ npm uninstall webpack webpack-cli -g#项目中安装~/Desktop/webpack-demo$ npm install webpack webpack-cli -D#项目中不同版本安装~/Desktop/webpack-demo2$ npm info webpack$ npm install webpack@3.10.0 webpack-cli -D#检查项目安装webpack是否成功~/Desktop/webpack-demo2$ npx webpack -v package.json文件修改 1234567891011&#123; "name": "webpack-demo", "version": "1.0.0", "description": "", "private": true, "scripts": &#123; "bundle": "webpack" //npm run bundle &#125; "author": "liupeng", "license": "ISC"&#125; 配置文件webpack.config.js //文件名默认就行，最好不要改 123456789101112const path = require('path');module.exports =&#123; mode: 'production', //模式配置（pro,dev）正式环境压缩 entry: &#123; //打包入口 main: './src/index.js' &#125;, output: &#123; filename: 'bundle.js', //打包输出名 path: path.resolve(__dirname, 'dist') //打包输出地址 &#125;&#125; 运行打包12345678#指定配置文件打包(webpackcongfig.js)npx webpack --config webpackcongfig.js#全局安装打包webpack index.js#项目安装打包npx webpack index.js#配置文件json:scripts打包npm run bundle 打包的一些日志输出知识1234567Hash: 打包的唯一标识Version: webpack版本号Time: 打包时间Asset: 打包的文件名Size: 包的大小Chunk: 项目中所有打包的文件idChunk: 打包生成的文件入口名]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BIO,NIO,AIO写法记录]]></title>
    <url>%2F2019%2F02%2F24%2FBIO-NIO-AIO%E5%86%99%E6%B3%95%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[写法详解~ BIO12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class BIOPlainEchoServer &#123; public void serve(int port) throws IOException &#123; //将ServerSocket绑定到指定的端口里 final ServerSocket socket = new ServerSocket(port); while (true) &#123; //阻塞直到收到新的客户端连接 final Socket clientSocket = socket.accept(); System.out.println(&quot;Accepted connection from &quot; + clientSocket); //创建一个子线程去处理客户端的请求 new Thread(new Runnable() &#123; @Override public void run() &#123; try (BufferedReader reader = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()))) &#123; PrintWriter writer = new PrintWriter(clientSocket.getOutputStream(), true); //从客户端读取数据并原封不动回写回去 while (true) &#123; writer.println(reader.readLine()); writer.flush(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); &#125; &#125; public void improvedServe(int port) throws IOException &#123; //将ServerSocket绑定到指定的端口里 final ServerSocket socket = new ServerSocket(port); //创建一个线程池 ExecutorService executorService = Executors.newFixedThreadPool(6); while (true) &#123; //阻塞直到收到新的客户端连接 final Socket clientSocket = socket.accept(); System.out.println(&quot;Accepted connection from &quot; + clientSocket); //将请求提交给线程池去执行 executorService.execute(() -&gt; &#123; try (BufferedReader reader = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()))) &#123; PrintWriter writer = new PrintWriter(clientSocket.getOutputStream(),true); //从客户端读取数据并原封不动回写回去 while (true) &#123; writer.println(reader.readLine()); writer.flush(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;); &#125; &#125;&#125; NIO123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class NIOPlainEchoServer &#123; public void serve(int port) throws IOException &#123; System.out.println(&quot;Listening for connections on port &quot; + port); ServerSocketChannel serverChannel = ServerSocketChannel.open(); ServerSocket ss = serverChannel.socket(); InetSocketAddress address = new InetSocketAddress(port); //将ServerSocket绑定到指定的端口里 ss.bind(address); serverChannel.configureBlocking(false); Selector selector = Selector.open(); //将channel注册到Selector里，并说明让Selector关注的点，这里是关注建立连接这个事件 serverChannel.register(selector, SelectionKey.OP_ACCEPT); while (true) &#123; try &#123; //阻塞等待就绪的Channel，即没有与客户端建立连接前就一直轮询 selector.select(); &#125; catch (IOException ex) &#123; ex.printStackTrace(); //代码省略的部分是结合业务，正确处理异常的逻辑 break; &#125; //获取到Selector里所有就绪的SelectedKey实例,每将一个channel注册到一个selector就会产生一个SelectedKey Set&lt;SelectionKey&gt; readyKeys = selector.selectedKeys(); Iterator&lt;SelectionKey&gt; iterator = readyKeys.iterator(); while (iterator.hasNext()) &#123; SelectionKey key = (SelectionKey) iterator.next(); //将就绪的SelectedKey从Selector中移除，因为马上就要去处理它，防止重复执行 iterator.remove(); try &#123; //若SelectedKey处于Acceptable状态 if (key.isAcceptable()) &#123; ServerSocketChannel server = (ServerSocketChannel) key.channel(); //接受客户端的连接 SocketChannel client = server.accept(); System.out.println(&quot;Accepted connection from &quot; + client); client.configureBlocking(false); //像selector注册socketchannel，主要关注读写，并传入一个ByteBuffer实例供读写缓存 client.register(selector, SelectionKey.OP_WRITE | SelectionKey.OP_READ, ByteBuffer.allocate(100)); &#125; //若SelectedKey处于可读状态 if (key.isReadable()) &#123; SocketChannel client = (SocketChannel) key.channel(); ByteBuffer output = (ByteBuffer) key.attachment(); //从channel里读取数据存入到ByteBuffer里面 client.read(output); &#125; //若SelectedKey处于可写状态 if (key.isWritable()) &#123; SocketChannel client = (SocketChannel) key.channel(); ByteBuffer output = (ByteBuffer) key.attachment(); output.flip(); //将ByteBuffer里的数据写入到channel里 client.write(output); output.compact(); &#125; &#125; catch (IOException ex) &#123; key.cancel(); try &#123; key.channel().close(); &#125; catch (IOException cex) &#123; &#125; &#125; &#125; &#125; &#125;&#125; AIO1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283public class AIOPlainEchoServer &#123; public void serve(int port) throws IOException &#123; System.out.println(&quot;Listening for connections on port &quot; + port); final AsynchronousServerSocketChannel serverChannel = AsynchronousServerSocketChannel.open(); InetSocketAddress address = new InetSocketAddress(port); // 将ServerSocket绑定到指定的端口里 serverChannel.bind(address); final CountDownLatch latch = new CountDownLatch(1); // 开始接收新的客户端请求. 一旦一个客户端请求被接收， CompletionHandler 就会被调用. serverChannel.accept(null, new CompletionHandler&lt;AsynchronousSocketChannel, Object&gt;() &#123; @Override public void completed(final AsynchronousSocketChannel channel, Object attachment) &#123; // 一旦完成处理，再次接收新的客户端请求 serverChannel.accept(null, this); ByteBuffer buffer = ByteBuffer.allocate(100); // 在channel里植入一个读操作EchoCompletionHandler，一旦buffer有数据写入，EchoCompletionHandler 便会被唤醒 channel.read(buffer, buffer, new EchoCompletionHandler(channel)); &#125; @Override public void failed(Throwable throwable, Object attachment) &#123; try &#123; // 若遇到异常，关闭channel serverChannel.close(); &#125; catch (IOException e) &#123; // ingnore on close &#125; finally &#123; latch.countDown(); &#125; &#125; &#125;); try &#123; latch.await(); &#125; catch (InterruptedException e) &#123; Thread.currentThread().interrupt(); &#125; &#125; private final class EchoCompletionHandler implements CompletionHandler&lt;Integer, ByteBuffer&gt; &#123; private final AsynchronousSocketChannel channel; EchoCompletionHandler(AsynchronousSocketChannel channel) &#123; this.channel = channel; &#125; @Override public void completed(Integer result, ByteBuffer buffer) &#123; buffer.flip(); // 在channel里植入一个读操作CompletionHandler，一旦channel有数据写入，CompletionHandler 便会被唤醒 channel.write(buffer, buffer, new CompletionHandler&lt;Integer, ByteBuffer&gt;() &#123; @Override public void completed(Integer result, ByteBuffer buffer) &#123; if (buffer.hasRemaining()) &#123; // 如果buffer里还有内容，则再次触发写入操作将buffer里的内容写入channel channel.write(buffer, buffer, this); &#125; else &#123; buffer.compact(); // 如果channel里还有内容需要读入到buffer里，则再次触发写入操作将channel里的内容读入buffer channel.read(buffer, buffer, EchoCompletionHandler.this); &#125; &#125; @Override public void failed(Throwable exc, ByteBuffer attachment) &#123; try &#123; channel.close(); &#125; catch (IOException e) &#123; // ingnore on close &#125; &#125; &#125;); &#125; @Override public void failed(Throwable exc, ByteBuffer attachment) &#123; try &#123; channel.close(); &#125; catch (IOException e) &#123; // ingnore on close &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用命令]]></title>
    <url>%2F2019%2F02%2F17%2FLinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[就是做了一些整理~常用系统工作命令，系统状态检测命令，工作目录切换命令，文本文件编辑命令，文件目录管理命令，打包压缩与搜索命令~ 常用系统工作命令echoecho 命令用于在终端输出字符串或变量提取后的值，格式为“echo [字符串 | $变量] 1234[root@linuxprobe ~]# echo Linuxprobe.ComLinuxprobe.Com[root@linuxprobe ~]# echo $SHELL/bin/bash datedate 命令用于显示及设置系统的时间或日期，格式为“date [选项] [+指定的格式]”。 参数 作用 %t 跳格[Tab 键] %H 小时（00～23) %I 小时（00～12） %M 分钟（00～59） %S 秒（00～59） %j 今年中的第几天 12345678910[root@linuxprobe ]# dateMon Aug 24 16:11:23 CST 20[root@linuxprobe ~]# date &quot;+%Y-%m-%d %H:%M:%S&quot;2017-08-24 16:29:12[root@linuxprobe ~]# date -s &quot;20170901 8:30:00&quot;Fri Sep 1 08:30:00 CST 2017[root@linuxprobe ~]# dateFri Sep 1 08:30:01 CST 2017[root@linuxprobe ~]# date &quot;+%j&quot;244 rebootreboot 命令用于重启系统其格式为 rebo1[root@linuxprobe ]# rebo poweroffpoweroff 命令用于关闭系统，其格式为 powerof 1[root@linuxprobe ~]# powero wgetwget 命令用于在终端中下载网络文件，格式为“wget [参数] 下载地址” 参数 作用 -b 后台下载模式 -P 下载到指定目录 -t 最大尝试次数 -c 断点续传 -p 下载页面内所有资源，包括图片、视频等 -r 递归下载 1[root@linuxprobe ~]# wget http://www.linuxprobe.com/docs/LinuxProbe.pdf psps 命令用于查看系统中的进程状态，格式为“ps [参数]”。 参数 作用 -a 显示所有进程（包括其他用户的进程） -u 用户以及其他详细信息 -x 显示没有控制终端的进程 ➢R(运行)：进程正在运行或在运行队列中等待。 ➢S(中断)：进程处于休眠中，当某个条件形成后或者接收到信号时，则脱离该状态。 ➢D(不可中断)：进程不响应系统异步信号，即便用 kill 命令也不能将其中断。 ➢Z(僵死)：进程已经终止，但进程描述符依然存在, 直到父进程调用 wait4()系统函数后将进程释。 ➢ T(停止)：进程收到停止信号后停止。 表 2-7 进程(ps -aux) toptop 命令用于动态地监视进程活动与系统负载等信息，其格式为 top。 ➢ 第 1 行：系统时间、运行时间、登录终端数、系统负载（三个数值分别为 1 分钟、5分钟、15 分钟内的平均值，数值越小意味着负载越低）。 ➢ 第 2 行：进程总数、运行中的进程数、睡眠中的进程数、停止的进程数、僵死的进程数。 ➢ 第 3 行：用户占用资源百分比、系统内核占用资源百分比、改变过优先级的进程资源百分比、空闲的资源百分比等 ➢ 第 4 行：物理内存总量、内存使用量、内存空闲量、作为内核缓存的内存量。 ➢ 第 5 行：虚拟内存总量、虚拟内存使用量、虚拟内存空闲量、已被提前加载的内 pidofpidof 命令用于查询某个指定服务进程的 PID 值，格式为“pidof [参数] [服务名称]”。 12[root@linuxprobe]# pidof sshd2156 killkill 命令用于终止某个指定 PID 的服务进程，格式为“kill [参数] [进程 PID]”。 1[root@linuxprobe ]# kill -9 2156 killall用于终止某个指定名称的服务所对应的全部进程，格式为：“killall [参数] [服务名称]”。 12345[root@linuxprobe ~]# pidof httpd13581 13580 13579 13578 13577 13576[root@linuxprobe ~]# killall httpd[root@linuxprobe ~]# pidof httpd[root@linuxprobe ~]# 系统状态检测命令ifconfigifconfig 命令用于获取网卡配置与网络状态等信息，格式为“ifconfig [网络设备] [参数]。 主要查看的就是网卡名称、inet 参数后面的 IP 地址、ether 参数后面的网卡物理地址（又称为 MAC 地址），以及 RX、TX 的接收数据包与发送数据包的个数及累计流量。12345678910[root@linuxprobe ~]# ifconfigeno16777728: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500inet 192.168.10.10 netmask 255.255.255.0 broadcast 192.168.10.255inet6 fe80::20c:29ff:fec4:a409 prefixlen 64 scopeid 0x20&lt;link&gt;ether 00:0c:29:c4:a4:09 txqueuelen 1000 (Ethernet)RX packets 36 bytes 3176 (3.1 KiB)RX errors 0 dropped 0 overruns 0 frame 0TX packets 38 bytes 4757 (4.6 KiB)TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt; mtu 65536inet 127.0.0.1 netmask 255.0.0.0inet6 ::1 prefixlen 128 scopeid 0x10&lt;host&gt;loop txqueuelen 0 (Local Loopback)RX packets 386 bytes 32780 (32.0 KiB)RX errors 0 dropped 0 overruns 0 frame 0TX packets 386 bytes 32780 (32.0 KiB)TX errors 0 dropped 0 overruns 0 carrier 0 collisions unameuname 命令用于查看系统内核与系统版本等信息，格式为“uname [-a]”。 在使用 uname 命令时，一般会固定搭配上-a 参数来完整地查看当前系统的内核名称、主机名、内核发行版本、节点名、系统时间、硬件名称、硬件平台、处理器类型以及操作系统名称等信息。123[root@linuxprobe ~]# uname -aLinux linuxprobe.com 3.10.0-123.el7.x86_64 #1 SMP Mon May 5 11:16:57 EDT 2017x86_64 x86_64 x86_64 GNU/Linux uptimeuptime 用于查看系统的负载信息，格式为 uptime。 uptime 命令真的很棒，它可以显示当前系统时间、系统已运行时间、启用终端数量以及平均负载值等信息。平均负载值指的是系统在最近 1 分钟、5 分钟、15 分钟内的压力情况；负载值越低越好，尽量不要长期超过 1，在生产环境中不要超过 5。12[root@linuxprobe ~]# uptime22:49:55 up 10 min, 2 users, load average: 0.01, 0.19, 0.18 freefree 用于显示当前系统中内存的使用量信息，格式为“free [-h]”。1[root@linuxprobe ]# free whowho 命令用于查看当前登入主机的用户终端信息，格式为“who [参数]”。1[root@linuxprobe ~]# who lastlast 命令用于查看所有系统的登录记录，格式为“last [参数]”。使用 last 命令可以查看本机的登录记录。但是，由于这些信息都是以日志文件的形式保存在系统中，因此黑客可以很容易地对内容进行篡改。千万不要单纯以该命令的输出信息而判断系统有无被恶意入侵！12345678[root@linuxprobe ~]# lastroot pts/0 :0 Mon Aug 24 17:52 still logged inroot :0 :0 Mon Aug 24 17:52 still logged in(unknown :0 :0 Mon Aug 24 17:50 - 17:52 (00:02)reboot system boot 3.10.0-123.el7.x Tue Aug 25 01:49 - 18:17 (-7:-32)root pts/0 :0 Mon Aug 24 15:40 - 08:54 (7+17:14)root pts/0 :0 Fri Jul 10 10:49 - 15:37 (45+04:47)………………省略部分登录信息……………… historyhistory 命令用于显示历史执行过的命令，格式为“history [-c]”。history 命令应该是作者最喜欢的命令。执行 history 命令能显示出当前用户在本地计算机中执行过的最近 1000 条命令记录。如果觉得 1000 不够用，还可以自定义/etc/profile 文件中的HISTSIZE 变量值。在使用 history 命令时，如果使用-c 参数则会清空所有的命令历史记录。还可以使用“!编码数字”的方式来重复执行某一次的命令。总之，history 命令有很多有趣的玩法等待您去开发。 12345678910111213141516171819202122232425262728[root@linuxprobe ~]# history1 tar xzvf VMwareTools-9.9.0-2304977.tar.gz2 cd vmware-tools-distrib/3 ls4 ./vmware-install.pl -d5 reboot6 df -h7 cd /run/media/8 ls9 cd root/10 ls11 cd VMware\ Tools/12 ls13 cp VMwareTools-9.9.0-2304977.tar.gz /home14 cd /home15 ls16 tar xzvf VMwareTools-9.9.0-2304977.tar.gz17 cd vmware-tools-distrib/18 ls19 ./vmware-install.pl -d20 reboot21 history[root@linuxprobe ~]# !15anaconda-ks.cfg Documents initial-setup-ks.cfg Pictures TemplatesDesktop Downloads Music Public Videos[root@linuxprobe ~]# cat ~/.bash_history[root@linuxprobe ~]# history -c //清除 sosreportsosreport 命令用于收集系统配置及架构信息并输出诊断文档，格式为 sosreport。这个用的不多，需要的自己查资料~ 工作目录切换命令pwdpwd 命令用于显示用户当前所处的工作目录，格式为“pwd [选项]”。12[root@linuxprobe etc]# pwd/etc cdcd 命令用于切换工作路径，格式为“cd [目录名称]”。123[root@linuxprobe ~]# cd /etc //进入[root@linuxprobe bin]# cd - //返回上次[root@linuxprobe etc]# cd ~ //用户家目录 lsls 命令用于显示目录中的文件信息，格式为“ls [选项] [文件] ”。 所处的工作目录不同，当前工作目录下的文件肯定也不同。使用 ls 命令的“-a”参数看到全部文件（包括隐藏文件），使用“-l”参数可以查看文件的属性、大小等详细信息。将这两个参数整合之后，再执行 ls 命令即可查看当前目录中的所有文件并输出这些文件的属性。12345[root@linuxprobe ~]# ls -altotal 60dr-xr-x---. 14 root root 4096 May 4 07:56 .drwxr-xr-x. 17 root root 4096 May 4 15:55 ..省略............ 如果想要查看目录属性信息，则需要额外添加一个-d 参数。例如，可使用如下命令查看/etc 目录的权限与属性信息：1[root@linuxprobe ~]# ls -ld /etcdrwxr-xr-x. 132 root root 8192 Jul 10 10:48 /e 文本文件编辑命令catcat 命令用于查看纯文本文件（内容较少的），格式为“cat [选项] [文件]”。12345[root@linuxprobe ~]# cat -n initial-setup-ks.cfg1 #version=RHEL72 # X Window System configuration information3 xconfig --startxonboot省略.............. moremore 命令用于查看纯文本文件（内容较多的），格式为“more [选项]文件”。12345[root@linuxprobe ~]# more initial-setup-ks.cfg#version=RHEL7# X Window System configuration information省略............--More--(43%) headhead 命令用于查看纯文本文档的前 N 行，格式为“head [选项] [文件]”。1234[root@linuxprobe ~]# head -n 20 initial-setup-ks.cfg#version=RHEL7# X Window System configuration information省略............ tailtail 命令用于查看纯文本文档的后 N 行或持续刷新内容，格式为“tail [选项] [文件]”。 tail 命令最强悍的功能是可以持续刷新一个文件的内容，当想要实时查看最新日志文件时，这特别有用，此时的命令格式为“tail -f 文件名”：1234[root@linuxprobe ~]# tail -f /var/log/messagesMay 4 07:56:38 localhost gnome-session: Window manager warning: Log level 16:STACK_OP_ADD: window 0x1e00001 already in stack省略............ trtr 命令用于替换文本文件中的字符，格式为“tr [原始字符] [目标字符]”。 把某个文本内容中的英文全部替换为大写:1[root@linuxprobe ~]# cat anaconda-ks.cfg | tr [a-z] [A-Z] wcwc 命令用于统计指定文本的行数、字数、字节数，格式为“wc [参数] 文本”。 参数 作用 -l 只显示行数 -w 只显示单词数 -c 只显示字节数 12[root@linuxprobe ~]# wc -l /etc/passwd38 /etc/pass statstat 命令用于查看文件的具体存储信息和时间等信息，格式为“stat 文件名称”。12345678910[root@linuxprobe ~]# stat anaconda-ks.cfgFile: ‘anaconda-ks.cfg’Size: 1213 Blocks: 8 IO Block: 4096 regular fileDevice: fd00h/64768d Inode: 68912908 Links: 1Access: (0600/-rw-------) Uid: ( 0/ root) Gid: ( 0/ root)Context: system_u:object_r:admin_home_t:s0Access: 2017-07-14 01:46:18.721255659 -0400Modify: 2017-05-04 15:44:36.916027026 -0400Change: 2017-05-04 15:44:36.916027026 -0400Birth: - cutcut 命令用于按“列”提取文本字符，格式为“cut [参数] 文本”。 在 Linux 系统中，如何准确地提取出最想要的数据，这也是我们应该重点学习的内容。一般而言，按基于“行”的方式来提取数据是比较简单的，只需要设置好要搜索的关键词即可。但是如果按列搜索，不仅要使用-f 参数来设置需要看的列数，还需要使用-d 参数来设置间隔符号。passwd 在保存用户数据信息时，用户信息的每一项值之间是采用冒号来间隔的，接下来我们使用下述命令尝试提取出 passwd 文件中的用户名信息，即提取以冒号（：）为间隔符号的第一列内容：1234567891011121314151617[root@linuxprobe ~]# head -n 2 /etc/passwdroot:x:0:0:root:/root:/bin/bashbin:x:1:1:bin:/bin:/sbin/nologin[root@linuxprobe ~]# cut -d: -f1 /etc/passwdrootbindaemonadmlpsyncshutdownhaltmailoperatorgamesftp省略............... diff用于比较多个文本文件的差异，格式为“diff [参数] 文件”。123456789101112131415161718[root@linuxprobe ~]# diff --brief diff_A.txt diff_B.t*** diff_A.txt 2017-08-30 18:07:45.230864626 +0800--- diff_B.txt 2017-08-30 18:08:52.203860389 +0800****************** 1,5 ****! Welcome to linuxprobe.comRed Hat certified! Free Linux LessonsProfessional guidanceLinux Course--- 1,7 ----! Welcome tooo linuxprobe.com!Red Hat certified! Free Linux LeSSonS! ////////.....////////Professional guidanceLinux Course 文件目录管理命令touchtouch 命令用于创建空白文件或设置文件的时间，格式为“touch [选项] [文件]”。 参数 作用 -a 仅修改“读取时间”（atime） -m 仅修改“修改时间”（mtime） -d 同时修改 atime 与 mtime 123456789[root@linuxprobe ~]# ls -l anaconda-ks.cfg-rw-------. 1 root root 1213 May 4 15:44 anaconda-ks.cfg[root@linuxprobe ~]# echo &quot;Visit the LinuxProbe.com to learn linux skills&quot; &gt;&gt;anaconda-ks.cfg[root@linuxprobe ~]# ls -l anaconda-ks.cfg-rw-------. 1 root root 1260 Aug 2 01:26 anaconda-ks.cfg[root@linuxprobe ~]# touch -d &quot;2017-05-04 15:44&quot; anaconda-ks.cfg[root@linuxprobe ~]# ls -l anaconda-ks.cfg-rw-------. 1 root root 1260 May 4 15:44 anaconda-ks.cfg mkdirmkdir 命令用于创建空白的目录，格式为“mkdir [选项] 目录”。 123456[root@linuxprobe ~]# mkdir linuxprobe[root@linuxprobe ~]# cd linuxprobe[root@linuxprobe linuxprobe]# mkdir -p a/b/c/d/e[root@linuxprobe linuxprobe]# cd a[root@linuxprobe a]# cd b[root@linuxprobe b]# cpcp 命令用于复制文件或目录，格式为“cp [选项] 源文件 目标文件”。 参数 作用 -p 保留原始文件的属性 -d 若对象为“链接文件”，则保留该“链接文件”的属性 -r 递归持续复制（用于目录） -i 若目标文件存在则询问是否覆盖 -a 相当于-pdr（p、d、r 为上述参数） 1234[root@linuxprobe ~]# touch install.log[root@linuxprobe ~]# cp install.log x.log[root@linuxprobe ~]# lsinstall.log x.log mvmv 命令用于剪切文件或将文件重命名，格式为“mv [选项] 源文件 [目标路径|目标文件名]”。 123[root@linuxprobe ~]# mv x.log linux.log[root@linuxprobe ~]# lsinstall.log linux.log rmrm 命令用于删除文件或目录，格式为“rm [选项] 文件”。 想要删除一个目录，需要在 rm 命令后面一个-r 参数才可以。12345[root@linuxprobe ~]# rm install.logrm: remove regular empty file ‘install.log’? y[root@linuxprobe ~]# rm -f linux.log[root@linuxprobe ~]# ls[root@linuxprobe ~]# dddd 命令用于按照指定大小和个数的数据块来复制文件或转换文件，格式为“dd [参数]”。 dd 命令是一个比较重要而且比较有特色的一个命令，它能够让用户按照指定大小和个数的数据块来复制文件的内容。当然如果愿意的话，还可以在复制过程中转换其中的数据。Linux系统中有一个名为/dev/zero 的设备文件，每次在课堂上解释它时都充满哲学理论的色彩。因为这个文件不会占用系统存储空间，但却可以提供无穷无尽的数据，因此可以使用它作为 dd命令的输入文件，来生成一个指定大小的文件。 参数 作用 if 输入的文件名称 of 输出的文件名称 bs 设置每个“块”的大小 count 设置要复制“块”的个数 例如我们可以用 dd 命令从/dev/zero 设备文件中取出一个大小为 560MB 的数据块，然后保存成名为 560_file 的文件。在理解了这个命令后，以后就能随意创建任意大小的文件了：1234[root@linuxprobe ~]# dd if=/dev/zero of=560_file count=1 bs=560M1+0 records in1+0 records out587202560 bytes (587 MB) copied, 27.1755 s, 21.6 MB/s dd 命令的功能也绝不仅限于复制文件这么简单。如果您想把光驱设备中的光盘制作成 iso 格式的镜像文件，在 Windows 系统中需要借助于第三方软件才能做到，但在 Linux 系统中可以直接使用 dd 命令来压制出光盘镜像文件，将它变成一个可立即使用的 iso 镜像：1234[root@linuxprobe ~]# dd if=/dev/cdrom of=RHEL-server-7.0-x86_64-LinuxProbe.Com.iso7311360+0 records in7311360+0 records out3743416320 bytes (3.7 GB) copied, 370.758 s, 10.1 MB/s 考虑到有些读者会纠结 bs 块大小与 count 块个数的关系，下面举一个吃货的例子进行解释。假设小明的饭量（即需求）是一个固定的值，用来盛饭的勺子的大小即 bs 块大小，而用勺子盛饭的次数即 count 块个数。小明要想吃饱（满足需求），则需要在勺子大小（bs 块大小）与用勺子盛饭的次数（count 块个数）之间进行平衡。勺子越大，用勺子盛饭的次数就越少。由上可见，bs 与 count 都是用来指定容量的大小，只要能满足需求，可随意组合搭配方式。 filefile 命令用于查看文件的类型，格式为“file 文件名”。1234[root@linuxprobe ~]# file anaconda-ks.cfganaconda-ks.cfg: ASCII text[root@linuxprobe ~]# file /dev/sda/dev/sda: block special 打包压缩与搜索命令tartar 命令用于对文件进行打包压缩或解压，格式为“tar [选项] [文件]”。 参数 作用 -c 创建压缩文件 -x 解开压缩文件 -t 查看压缩包里面有哪些文件 -z 用Gzip压缩或解压 -j 用bzip2压缩或解压 -v 显示压缩或解压过程 -f 目标文件名 -P 保存原始的权限与属性 -p 使用绝对路径来压缩 -C 指定解压目录 123[root@linuxprobe ~]# tar -czvf etc.tar.gz /etc[root@linuxprobe ~]# mkdir /root/etc[root@linuxprobe ~]# tar xzvf etc.tar.gz -C /root/etc grepgrep 命令用于在文本中执行关键词搜索，并显示匹配的结果，格式为“grep [选项] [文件]”。 参数 作用 -b 将可执行文件（binary）当作文本文件（text）来搜索 -c 仅显示找到的行数 -i 忽略大小写 -n 显示行号 -v 反向选择—仅列出没有“关键词”的行 在 Linux 系统中，/etc/passwd 文件是保存着所有的用户信息，而一旦用户的登录终端被设置成/sbin/nologin，则不再允许登录系统，因此可以使用 grep 命令来查找出当前系统中不允许登录系统的所有用户信息： 12345678[root@linuxprobe ~]# grep /sbin/nologin /etc/passwdbin:x:1:1:bin:/bin:/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologinadm:x:3:4:adm:/var/adm:/sbin/nologinlp:x:4:7:lp:/var/spool/lpd:/sbin/nologinmail:x:8:12:mail:/var/spool/mail:/sbin/nologinoperator:x:11:0:operator:/root:/sbin/nologin………………省略部分输出过程信息……………… findfind 命令用于按照指定条件来查找文件，格式为“find [查找路径] 寻找条件 操作”。 在 Linux 系统中，搜索工作一般都是通过 find 命令来完成的，它可以使用不同的文件特性作为寻找条件（如文件名、大小、修改时间、权限等信息），一旦匹配成功则默认将信息显示到屏幕上。 参数 作用 -name 匹配名称 -perm 匹配权限（mode 为完全匹配，-mode 为包含即可） -user 匹配所有者 -group 匹配所有组 -mtime -n +n 匹配修改内容的时间（-n 指 n 天以内，+n 指 n 天以前） -atime -n +n 匹配访问文件的时间（-n 指 n 天以内，+n 指 n 天以前） -ctime -n +n 匹配修改文件权限的时间（-n 指 n 天以内，+n 指 n 天以前） -nouser 匹配无所有者的文件 -nogroup 匹配无所有组的文件 -newer f1 !f2 匹配比文件 f1 新但比 f2 旧的文件 –type b/d/c/p/l/f 匹配文件类型（后面的字母参数依次表示块设备、目录、字符设备、管道、链接文件、文本文件） -size 匹配文件的大小（+50KB 为查找超过 50KB 的文件，而-50KB 为查找小于 50KB 的文件） -prune 忽略某个目录 -exec …… {}\; 后面可跟用于进一步处理搜索结果的命令 12345678//获取到该目录中所有以 host 开头的文件列表[root@linuxprobe ~]# find /etc -name &quot;host*&quot; -print/etc/avahi/hosts/etc/host.conf/etc/hosts/etc/hosts.allow/etc/hosts.deny/etc/hostname 12//在整个文件系统中找出所有归属于linuxprobe用户的文件并复制到/root/findresults目录[root@linuxprobe ~]# find / -user linuxprobe -exec cp -a &#123;&#125; /root/findresults/ \; 参考书籍《LinuxProbe》 Linux命令查找]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>command</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OSI参考模型图]]></title>
    <url>%2F2019%2F02%2F13%2FOSI%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[这是一张很长很详细的图~]]></content>
  </entry>
  <entry>
    <title><![CDATA[ReentrantLock与锁]]></title>
    <url>%2F2019%2F02%2F10%2FReentrantLock%E4%B8%8E%E9%94%81%2F</url>
    <content type="text"><![CDATA[ReentrantLock与锁之间的区别及使用~ ReentrantLock（重入锁）与synchronize区别 可重入性：两个都是可以重入的进行锁的计数 锁的实现：ReentrantLock用的是程序实现（用户态），synchronized用的是JVM实现（内核态） 性能的区别：synchronized（轻量级锁，偏向锁）经过优化后和ReentrantLock性能差不多 功能区别：ReentrantLock更加的灵活（细粒度高），synchronized更加便利 ReentrantLock（重入锁）独有的功能 可以指定是公平锁还是非公平锁 提供了一个Condition类，可以分组唤醒需要唤醒的线程 提供能够中断等待锁的线程的机制，lock.lockInterrupibly 12345678910111213141516171819202122232425262728293031323334//ReentrantLock及Condition使用@Slf4jpublic class ConditionExample &#123; public static void main(String[] args) &#123; ReentrantLock reentrantLock = new ReentrantLock(); Condition condition = reentrantLock.newCondition(); new Thread(() -&gt; &#123; try&#123; reentrantLock.lock(); log.info(&quot;wait signal&quot;);// 1 condition.await(); &#125;catch(InterruptedException e)&#123; e.printStackTrace(); &#125; log.info(&quot;get signal&quot;);// 4 reentrantLock.unlock(); &#125;).start(); new Thread(() -&gt; &#123; reentrantLock.lock(); log.info(&quot;get Lock&quot;);// 2 try&#123; Thread.sleep(3000); &#125;catch(InterruptedException e)&#123; e.printStackTrace(); &#125; condition.signalAll(); log.info(&quot;send signal ~&quot;);// 3 reentrantLock.unlock(); &#125;).start(); &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java线程类测试]]></title>
    <url>%2F2019%2F02%2F08%2FJava%E7%BA%BF%E7%A8%8B%E7%B1%BB%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[对java中的线程安全类及不安全的类进行测试~ 线程不安全类 StringBuilder -&gt; StringBuffer SimpleDateFormat -&gt; JodaTime 同步容器 ArrayList -&gt; Vector,Stack HashMap -&gt; HashTable(key, value不能为null) Collections.synchronizedXXX(List, Set, Map) 并发容器 ArrayList -&gt; CopyOnWriteArrayList HashSet,TreeSet -&gt; CopyOnWriteArraySet,ConcurrentSkipListSet HashMap,TreeMap -&gt; ConcurrentHashMap,ConcurrentSkipListMap 1234567891011121314151617181920212223242526272829303132333435//可以自行进行测试public class ConcurrencyTest &#123; //请求总数 public static int clientTotal = 5000; //同时并发执行的线程数 public static int threadTotal = 200; public static int count = 0; public static void main(String[] args) throws Exception &#123; ExecutorService executorService = Executors.newCachedThreadPool(); final Semaphore semaphore = new Semaphore(threadTotal); final CountDownLatch countDownLatch = new CountDownLatch(clientTotal); for (int i = 0; i &lt; clientTotal; i++) &#123; executorService.execute(() -&gt; &#123; try&#123; semaphore.acquire(); add(); semaphore.release(); &#125; catch (Exception e)&#123; log.error(&quot;exception&quot; , e); &#125; countDownLatch.countDown(); &#125;); &#125; countDownLatch.await(); executorService.shutdown(); log.info(&quot;count:&#123;&#125;&quot; , count); &#125; private static void add()&#123; count++; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java线程封闭]]></title>
    <url>%2F2019%2F02%2F08%2FJava%E7%BA%BF%E7%A8%8B%E5%B0%81%E9%97%AD%2F</url>
    <content type="text"><![CDATA[java是如何保持线程之间的不互相干扰？ 线程封闭 Ad-hoc线程封闭：程序控制，最糟糕，忽略 堆栈封闭：局部变量(利用不同的虚拟机栈副本存储) ThreadLocal线程封闭：特别好的封闭方法 1234567891011121314151617181920//ThreadLocal线程封闭public class RequestHolder &#123; private final static ThreadLocal&lt;Long&gt; requestHolder = new ThreadLocal&lt;Long&gt;(); public static void add(Long id)&#123; requestHolder.set(id); &#125; public static Long getId()&#123; //自动获取key(当前线程对象地址),找出value值返回 return requestHolder.get(); &#125; public static void remove()&#123; //数据会一直存到项目重启 //数据一定要移除，避免产生内存溢出(oom) requestHolder.remove(); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java不可变对象]]></title>
    <url>%2F2019%2F02%2F07%2Fjava%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[不可变对象定义，作用，使用方式详解。 不可变对象需要满足的条件： 对象创建以后其状态就不能修改 对象所有域都是final类型 对象时正确创建的（在对象创建期间，this引用没有逸出） 123456789101112131415161718192021222324252627282930313233//final关键字：类，方法，变量// 修饰类：不能被继承// 修饰方法：1.锁定方法不能被继承类修改（默认为private）;2.效率// 修饰变量：基本数据类型变量，引用类型变量@Slf4j@NotThreadSafepublic class ImmutableFinal &#123; private final static Integer a = 1; private final static String b = &quot;2&quot;; //guava private final static Map&lt;Integer, Integer&gt; map = Maps.newHashMap(); static &#123; map.put(1, 2); map.put(3, 4); map.put(5, 6); &#125; public static void main(String[] args) &#123; //a = 2; //b = &quot;3&quot;; //map = Maps.newHashMap(); //map引用不能修改，但是内部的值还是可以进行修改~ map.put(1, 3); log.info(&quot;&#123;&#125;&quot;,map.get(1)); &#125; //final参数不能修改 private void test(final int a)&#123; // a = 1 &#125;&#125; 1234567891011121314151617181920////利用基本的类库进行不可变Map对象的创建（内部参数也不可以改变）@Slf4j@ThreadSafepublic class ImmutableMap &#123; private static Map&lt;Integer, Integer&gt; map = Maps.newHashMap(); static&#123; map.put(1, 2); map.put(3, 4); map.put(5, 6); //java map = Collections.unmodifiableMap(map); &#125; public static void main(String[] args) &#123; //会报错哈~UnsupportedOperationException map.put(1, 3); log.info(&quot;&#123;&#125;&quot;, map.get(1)); &#125;&#125; 1234567891011121314151617//利用Guava的类库进行不可变Map对象的创建（内部参数也不可以改变）@ThreadSafepublic class ImmutableGuava &#123; private final static ImmutableList&lt;Integer&gt; list = ImmutableList.of(1, 2, 3); private final static ImmutableSet set = ImmutableSet.copyOf(list); private final static ImmutableMap&lt;Integer, Integer&gt; map = ImmutableMap.of(1, 2, 3, 4); private final static ImmutableMap&lt;Integer, Integer&gt; map2 = ImmutableMap.&lt;Integer, Integer&gt;builder() .put(1, 2).put(3, 4).put(5, 6).build(); public static void main(String[] args) &#123; System.out.println(map2.get(3)); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[jdk，jre你真的懂吗？]]></title>
    <url>%2F2019%2F02%2F07%2Fjdk%EF%BC%8Cjre%E4%BD%A0%E7%9C%9F%E7%9A%84%E6%87%82%E5%90%97%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[关于jdk和jre 大家肯定在安装JDK的时候会有选择是否安装单独的jre，一般都会一起安装，我也建议大家这样做。因为这样更能帮助大家弄清楚它们的区别：Jre 是java runtime environment, 是java程序的运行环境。既然是运行，当然要包含jvm，也就是大家熟悉的虚拟机啦，还有所有java类库的class文件，都在lib目录下打包成了jar。大家可以自己验证。至于在windows上的虚拟机是哪个文件呢？学过MFC的都知道什么是dll文件吧，那么大家看看jre/bin/client里面是不是有一个jvm.dll呢？那就是虚拟机。 Jdk 是java development kit，是java的开发工具包，里面包含了各种类库和工具。当然也包括了另外一个Jre. 那么为什么要包括另外一个Jre呢？而且jdk/jre/bin同时有client和server两个文件夹下都包含一个jvm.dll。说明是有两个虚拟机的。这一点不知道大家是否注意到了呢？ 相信大家都知道jdk的bin下有各种java程序需要用到的命令，与jre的bin目录最明显的区别就是jdk下才有javac，这一点很好理解，因为 jre只是一个运行环境而已。与开发无关，正因为如此，具备开发功能的jdk自己的jre下才会同时有client性质的jvm和server性质的 jvm， 而仅仅作为运行环境的jre下只需要client性质的jvm.dll就够了。 记得在环境变量path中设置jdk/bin路径麽？这应该是大家学习Java的第一步吧，老师会告诉大家不设置的话javac和java是用不了的。确实jdk/bin目录下包含了所有的命令。可是有没有人想过我们用的java命令并不是 jdk/bin目录下的而是jre/bin目录下的呢？不信可以做一个实验，大家可以把jdk/bin目录下的java.exe剪切到别的地方再运行 java程序，发现了什么？一切OK！ 那么有人会问了？我明明没有设置jre/bin目录到环境变量中啊？ 试想一下如果java为了提供给大多数人使用，他们是不需要jdk做开发的，只需要jre能让java程序跑起来就可以了，那么每个客户还需要手动去设置环境变量多麻烦啊？所以安装jre的时候安装程序自动帮你把jre的java.exe添加到了系统变量中，验证的方法很简单，大家看到了系统环境变量的 path最前面有“%SystemRoot%system32;%SystemRoot%;”这样的配置，那么再去Windows/system32下面去看看吧，发现了什么？有一个java.exe。 如果强行能够把jdk/bin挪到system32变量前面，当然也可以迫使使用jdk/jre里面的java，不过除非有必要，我不建议大家这么做。使用单独的jre跑java程序也算是客户环境下的一种测试。 ——————————————————————————————————————————— 通俗点来说： jdk是java的开发包，其中包括jre;jre仅仅是java的运行时环境；而JDK包括了同版本的JRE，此外还包括有编译器和其它工具 JDK是java开发工具包(java Development Kit)的缩写。它是一种构建在java平台上发布的应用程序、apple和组件的开发环境。JDK是一切java应用程序的基础，所有的java应用程序是构建在这个之上的。它是一组API，也可以说是一些java Class。要成为一个Java程序员，JDK是必不可少的最基本的工具。 JRE是Java运行环境(Java Runtime Enviroment)的缩写。它基本上就和Java虚拟机是同一个概念。一般来说，在谈论一个具体的产品的时候，可以说“JRE”,而说到理论中的一个模型的时候，我们常用的是“Java虚拟机”。要使用Java程序，JRE是必不可少的环境。 如果机子里安装了多个版本的jdk，如下： BEA Weblogic Server 7.0 自带一套 JDK1.3.1_02下载了一套最新的JDK1.4.1_02JBuilder9自带一套JKD1.4.1_02Oracle8.1.7自带一套JRE1.1.7Ration Rose自带一套JDK1.3DreamWeaver自带一套JDK1.3 6套JRE，每套JRE都被各自安装到不同的目录，不会互相影响。当在控制台执行java.exe，操作系统寻找JRE的方式如下： 先找当前目录下有没有JRE再找父目录下有没有JRE接着在PATH路径中找JRE（一般运行时从path中查找，按照path设置前后顺序，以前面为准）注册表HKEY_LOCAL_MACHINE\SOFTWARE\JavaSoft\Java Runtime Environment\ 查看CurrentVersion的键值指向哪个JRE（一般XP下是这个：C:\Program Files\Java\jre6） 最常用的是在PATH路径中找JRE，一般情况下，自己的程序运行之前都会先在批处理文件里面临时设置PATH，把自己用的JRE放到PATH路径最前面，所以肯定会运行自己带的JRE，不会造成版本混乱。 ——————————————————————————————————————————————JDK就是Java Development Kit.简单的说JDK是面向开发人员使用的SDK，它提供了Java的开发环境和运行环境。SDK是Software Development Kit 一般指软件开发包，可以包括函数库、编译程序等。 JRE是Java Runtime Enviroment是指Java的运行环境，是面向Java程序的使用者，而不是开发者。 如果安装了JDK，会发同你的电脑有两套JRE，一套位于 \jre 另外一套位于 C:\Program Files\Java\jre1.5.0_15 目录下，后面这套比前面那套少了Server端的Java虚拟机，不过直接将前面那套的Server端Java虚拟机复制过来就行了。而且在安装JDK可以选择是否安装这个位于 C:\Program Files\Java 目录下的JRE。如果你只安装JRE，而不是JDK，那么只会在 C:\Program Files\Java 目录下安装唯一的一套JRE。 JRE的地位就象一台PC机一样，我们写好的Win32应用程序需要操作系统帮我们运行，同样的，我们编写的Java程序也必须要JRE才能运行。所以当你装完JDK后，如果分别在硬盘上的两个不同地方安装了两套JRE，那么你可以想象你的电脑有两台虚拟的Java PC机，都具有运行Java程序的功能。所以我们可以说，只要你的电脑安装了JRE，就可以正确运行Java应用程序。 为什么Sun要让JDK安装两套相同的JRE？ 这是因为JDK里面有很多用Java所编写的开发工具（如javac.exe、jar.exe等），而且都放置在 \lib\tools.jar 里。从下面例子可以看出，先将tools.jar改名为tools1.jar，然后运行javac.exe，显示如下结果： Exception in thread “main” java.lang.NoClassDefFoundError: com/sun/tools/javac /Main 这个意思是说，你输入javac.exe与输入 java -cp c:\jdk\lib\tools.jar com.sun.tools.javac.Main 是一样的，会得到相同的结果。从这里我们可以证明javac.exe只是一个包装器（Wrapper），而制作的目的是为了让开发者免于输入太长的指命。而且可以发现\lib目录下的程序都很小，不大于2 9K，从这里我们可以得出一个结论。就是JDK里的工具几乎是用Java所编写，所以也是Java应用程序，因此要使用JDK所附的工具来开发Java程序，也必须要自行附一套JRE才行，所以位于C:\Program Files\Java目录下的那套JRE就是用来运行一般Java程序用的。 如果一台电脑安装两套以上的JRE，谁来决定呢？ 这个重大任务就落在java.exe身上。Java.exe的工作就是找到合适的JRE来运行Java程序。 Java.exe依照底下的顺序来查找JRE：自己的目录下有没有JRE；父目录有没有JRE；查询注册表： [HKEY_LOCAL_MACHINE\SOFTWARE\JavaSoft\Java Runtime Environment] 所以java.exe的运行结果与你的电脑里面哪个JRE被执行有很大的关系。 ADD：（小小结） JVM – java virtual machineJVM就是我们常说的java虚拟机，它是整个java实现跨平台的最核心的部分，所有的java程序会首先被编译为.class的类文件，这种类文件可以在虚拟机上执行，也就是说class并不直接与机器的操作系统相对应，而是经过虚拟机间接与操作系统交互，由虚拟机将程序解释给本地系统执行。 JRE – java runtime environmentJRE是指java运行环境。光有JVM还不能成class的执行，因为在解释class的时候JVM需要调用解释所需要的类库lib。在JDK的安装目录里你可以找到jre目录，里面有两个文件夹bin和lib,在这里可以认为bin里的就是jvm，lib中则是jvm工作所需要的类库，而jvm和 lib和起来就称为jre。所以，在你写完java程序编译成.class之后，你可以把这个.class文件和jre一起打包发给朋友，这样你的朋友就可以运行你写程序了。（jre里有运行.class的java.exe） JDK – java development kitJDK是java开发工具包，基本上每个学java的人都会先在机器上装一个JDK，那他都包含哪几部分呢？让我们看一下JDK的安装目录。在目录下面有六个文件夹、一个src类库源码压缩包、和其他几个声明文件。其中，真正在运行java时起作用的是以下四个文件夹：bin、include、lib、 jre。现在我们可以看出这样一个关系，JDK包含JRE，而JRE包含JVM。bin:最主要的是编译器(javac.exe)include:java和JVM交互用的头文件lib：类库jre:java运行环境（注意：这里的bin、lib文件夹和jre里的bin、lib是不同的）总的来说JDK是用于java程序的开发,而jre则是只能运行class而没有编译的功能。 eclipse、idea等其他IDE有自己的编译器而不是用JDK bin目录中自带的，所以在安装时你会发现他们只要求你选中jre路径就ok了。 ITeye原文]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[如何安全发布对象？]]></title>
    <url>%2F2019%2F02%2F05%2F%E5%A6%82%E4%BD%95%E5%AE%89%E5%85%A8%E5%8F%91%E5%B8%83%E5%AF%B9%E8%B1%A1%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[安全发布对象详解~ 在静态初始化函数中初始化一个对象引用 将对象的引用保存到volatile类型域或者AtomicReference对象中 将对象的引用保存到某个正确构造对象的final类型域中 将对象的引用保存到一个由锁保护的域中 例子：1234567891011121314151617181920212223242526272829/** * 懒汉模式 -》 双重同步锁单例模式 * 单例实例在第一次使用时进行创建 */@ThreadSafepublic class LazySingleton &#123; // 私有构造函数 private LazySingleton() &#123;&#125; // 1、memory = allocate() 分配对象的内存空间 // 2、ctorInstance() 初始化对象 // 3、instance = memory 设置instance指向刚分配的内存 // 单例对象 volatile + 双重检测机制 -&gt; 禁止指令重排 private volatile static LazySingleton instance = null; // 静态的工厂方法 public static LazySingleton getInstance() &#123; if (instance == null) &#123; // 双重检测机制 synchronized (LazySingleton.class) &#123; // 同步锁 if (instance == null) &#123; instance = new LazySingleton(); &#125; &#125; &#125; return instance; &#125;&#125; 12345678910111213141516171819202122232425/** * 饿汉模式 * 单例实例在类装载时进行创建 */@ThreadSafepublic class HungrySingleton &#123; // 私有构造函数 private HungrySingleton() &#123;&#125; // 单例对象 private static HungrySingleton instance = new HungrySingleton(); /* private static SingletonExample6 instance = null; static &#123; instance = new SingletonExample6(); &#125;*/ // 静态的工厂方法 public static HungrySingleton getInstance() &#123; return instance; &#125;&#125; 1234567891011121314151617181920212223242526272829/** * 枚举模式：最安全 */@ThreadSafe@Recommendpublic class EnumSingleton &#123; // 私有构造函数 private EnumSingleton() &#123;&#125; public static EnumSingleton getInstance() &#123; return Singleton.INSTANCE.getInstance(); &#125; private enum Singleton &#123; INSTANCE; private EnumSingleton singleton; // JVM保证这个方法绝对只调用一次 Singleton() &#123; singleton = new EnumSingleton(); &#125; public EnumSingleton getInstance() &#123; return singleton; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Concurrency</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[发布对象线程安全问题]]></title>
    <url>%2F2019%2F02%2F05%2F%E5%8F%91%E5%B8%83%E5%AF%B9%E8%B1%A1%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[发布对象，对象逸出并发问题详解 发布对象（NotThreadSafe）使一个对象能够被当前范围之外的代码所使用。 12345678910111213141516@Slf4j@NotThreadSafepublic class UnsafePublish &#123; private String[] states = &#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;; public String[] getStates()&#123; return states; &#125; public static void main(String[] args) &#123; UnsafePublish unsafePublish = new UnsafePublish(); log.info(&quot;&#123;&#125;&quot;, Arrays.toString(unsafePublish.getStates())); unsafePublish.getStates()[0] = &quot;d&quot;; log.info(&quot;&#123;&#125;&quot;, Arrays.toString(unsafePublish.getStates())); &#125;&#125; 对象逸出（NotThreadSafe）一种错误的发布。当一个对象还没有构建完成时，就使它被其他线程所见。1234567891011121314151617181920@NotThreadSafe@NotRecommendpublic class Escape &#123; private int thisCanBeEscape = 0; public Escape ()&#123; new InnerClass(); &#125; private class InnerClass &#123; public InnerClass()&#123; //获取的数据是未创建完的对象数据 log.info(&quot;&#123;&#125;&quot;, Escape.this.thisCanBeEscape); &#125; &#125; public static void main(String[] args) &#123; new Escape(); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Concurrency</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新年快乐]]></title>
    <url>%2F2019%2F02%2F05%2F%E6%96%B0%E5%B9%B4%E5%BF%AB%E4%B9%90%2F</url>
    <content type="text"><![CDATA[新年深夜更博~北京四年反省总结 在过去一年中，发生了很多大事，家人的离世，房贷的压力，互联网环境的变更，辞职决定去杭州发展，身上的压力是越来越重，我只有不停的学习，不停的进步才能减轻担忧。 我不是本科，也不是本专业，却走上了程序猿这条路，通过培训获取了当一名程序猿的资格，进了第一家公司不停加班，学习，才让我跟上工作步伐。 很恨自己中间有一年安逸的日子没有学习，只会玩手机，导致技术的滞后。安逸真的会使人堕落，而我本就没有这样的资格堕落。 2019新的一年到了，深刻的反省。 三月份到杭州，我会做一个学习计划，到时候再发博~ 在最后祝大家新年快乐，身体健康，合家团员。 best wishes:努力的去拥抱生活，让自己变得更好，不要辜负自己的青春，在最灿烂的年纪，绽放最耀眼的光芒。]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HashMap？面试？我是谁？我在哪]]></title>
    <url>%2F2019%2F02%2F04%2FHashMap%EF%BC%9F%E9%9D%A2%E8%AF%95%EF%BC%9F%E6%88%91%E6%98%AF%E8%B0%81%EF%BC%9F%E6%88%91%E5%9C%A8%E5%93%AA%2F</url>
    <content type="text"><![CDATA[面试经常被问到做个笔记，emmmmm 为什么用HashMap？ HashMap 是一个散列桶（数组和链表），它存储的内容是键值对 key-value 映射 HashMap 采用了数组和链表的数据结构，能在查询和修改方便继承了数组的线性查找和链表的寻址修改 HashMap 是非 synchronized，所以 HashMap 很快 HashMap 可以接受 null 键和值，而 Hashtable 则不能（原因就是 equlas() 方法需要对象，因为 HashMap 是后出的 API 经过处理才可以） HashMap 的工作原理是什么？HashMap 是基于 hashing 的原理 我们使用 put(key, value) 存储对象到 HashMap 中，使用 get(key) 从 HashMap 中获取对象。当我们给 put() 方法传递键和值时，我们先对键调用 hashCode() 方法，计算并返回的 hashCode 是用于找到 Map 数组的 bucket 位置来储存 Node 对象。 这里关键点在于指出，HashMap 是在 bucket 中储存键对象和值对象，作为Map.Node。 以下是 HashMap 初始化简化的模拟数据结构：1234567Node[] table = new Node[16]; // 散列桶初始化，tableclass Node &#123; hash; //hash值 key; //键 value; //值 node next; //用于指向链表的下一层（产生冲突，用拉链法）&#125; 以下是具体的 put 过程（JDK1.8） 对 Key 求 Hash 值，然后再计算下标 如果没有碰撞，直接放入桶中（碰撞的意思是计算得到的 Hash 值相同，需要放到同一个 bucket 中） 如果碰撞了，以链表的方式链接到后面 如果链表长度超过阀值（TREEIFY THRESHOLD==8），就把链表转成红黑树，链表长度低于6，就把红黑树转回链表 如果节点已经存在就替换旧值 如果桶满了（容量16*加载因子0.75），就需要 resize（扩容2倍后重排）]]></content>
  </entry>
  <entry>
    <title><![CDATA[Apache Bench]]></title>
    <url>%2F2019%2F02%2F03%2FApacheBench%2F</url>
    <content type="text"><![CDATA[Apache Bench简介ApacheBench 是 Apache 服务器自带的一个web压力测试工具，简称ab。ab又是一个命令行工具，对发起负载的本机要求很低，根据ab命令可以创建很多的并发访问线程，模拟多个访问者同时对某一URL地址进行访问，因此可以用来测试目标服务器的负载压力。总的来说ab工具小巧简单，上手学习较快，可以提供需要的基本性能指标，但是没有图形化结果，不能监控。 Apache Bench安装首先需要安装Apache服务器，下载地址：https://www.apachelounge.com/download/ Apache Bench使用了解参数123456789101112131415161718192021222324252627282930313233参数说明：格式：ab [options] [http://]hostname[:port]/path-n requests Number of requests to perform //本次测试发起的总请求数-c concurrency Number of multiple requests to make //一次产生的请求数（或并发数）-t timelimit Seconds to max. wait for responses //测试所进行的最大秒数，默认没有时间限制。-r Don&apos;t exit on socket receive errors. // 抛出异常继续执行测试任务 -p postfile File containing data to POST //包含了需要POST的数据的文件，文件格式如“p1=1&amp;p2=2”.使用方法是 -p 111.txt-T content-type Content-type header for POSTing//POST数据所使用的Content-type头信息，如 -T “application/x-www-form-urlencoded” 。 （配合-p）-v verbosity How much troubleshooting info to print//设置显示信息的详细程度 – 4或更大值会显示头信息， 3或更大值可以显示响应代码(404, 200等), 2或更大值可以显示警告和其他信息。 -V 显示版本号并退出。-C attribute Add cookie, eg. -C “c1=1234,c2=2,c3=3” (repeatable)//-C cookie-name=value 对请求附加一个Cookie:行。 其典型形式是name=value的一个参数对。此参数可以重复，用逗号分割。提示：可以借助session实现原理传递 JSESSIONID参数， 实现保持会话的功能，如-C ” c1=1234,c2=2,c3=3, JSESSIONID=FF056CD16DA9D71CB131C1D56F0319F8″ 。-w Print out results in HTML tables //以HTML表的格式输出结果。默认时，它是白色背景的两列宽度的一张表。-i Use HEAD instead of GET-x attributes String to insert as table attributes-y attributes String to insert as tr attributes-z attributes String to insert as td or th attributes-H attribute Add Arbitrary header line, eg. ‘Accept-Encoding: gzip’ Inserted after all normal header lines. (repeatable)-A attribute Add Basic WWW Authentication, the attributesare a colon separated username and password.-P attribute Add Basic Proxy Authentication, the attributes are a colon separated username and password.-X proxy:port Proxyserver and port number to use-V Print version number and exit-k Use HTTP KeepAlive feature-d Do not show percentiles served table.-S Do not show confidence estimators and warnings.-g filename Output collected data to gnuplot format file.-e filename Output CSV file with percentages served-h Display usage information (this message) 参数倒是挺多的不过，经常用的就是 -n -c ,记得配置path环境变量哈，不然要去bin目录下执行 例如:]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开篇博客]]></title>
    <url>%2F2019%2F02%2F03%2F%E5%BC%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[开个博客，写写东西。很早之间我就想做个博客，写一些技术文档，随笔，却一直没有沉下心来做这件事。 最近过年才有时间，大概花了1天时间搭建Hexo比想象中的简单多了，之前一直觉得挺麻烦的，也许是因为知识的积累和想拥有一个自己博客的迫切希望才促使我不断的去突破困难搭建完善。 搭建博客虽然简单，但是持之以恒的去写文章就很难了。我现在开篇立个flag，一周至少更新一篇技术博客，大家监督~ 我一直认为啊~技术宅真的是可以拯救世界的，大家一起加油吧~]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
</search>
