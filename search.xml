<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[如何安全发布对象？]]></title>
    <url>%2F2019%2F02%2F05%2F%E5%A6%82%E4%BD%95%E5%AE%89%E5%85%A8%E5%8F%91%E5%B8%83%E5%AF%B9%E8%B1%A1%EF%BC%9F-1%2F</url>
    <content type="text"><![CDATA[安全发布对象详解~ 在静态初始化函数中初始化一个对象引用 将对象的引用保存到volatile类型域或者AtomicReference对象中 将对象的引用保存到某个正确构造对象的final类型域中 将对象的引用保存到一个由锁保护的域中 例子：1234567891011121314151617181920212223242526272829/** * 懒汉模式 -》 双重同步锁单例模式 * 单例实例在第一次使用时进行创建 */@ThreadSafepublic class LazySingleton &#123; // 私有构造函数 private LazySingleton() &#123;&#125; // 1、memory = allocate() 分配对象的内存空间 // 2、ctorInstance() 初始化对象 // 3、instance = memory 设置instance指向刚分配的内存 // 单例对象 volatile + 双重检测机制 -&gt; 禁止指令重排 private volatile static LazySingleton instance = null; // 静态的工厂方法 public static LazySingleton getInstance() &#123; if (instance == null) &#123; // 双重检测机制 synchronized (LazySingleton.class) &#123; // 同步锁 if (instance == null) &#123; instance = new LazySingleton(); &#125; &#125; &#125; return instance; &#125;&#125; 12345678910111213141516171819202122232425/** * 饿汉模式 * 单例实例在类装载时进行创建 */@ThreadSafepublic class HungrySingleton &#123; // 私有构造函数 private HungrySingleton() &#123;&#125; // 单例对象 private static HungrySingleton instance = new HungrySingleton(); /* private static SingletonExample6 instance = null; static &#123; instance = new SingletonExample6(); &#125;*/ // 静态的工厂方法 public static HungrySingleton getInstance() &#123; return instance; &#125;&#125; 1234567891011121314151617181920212223242526272829/** * 枚举模式：最安全 */@ThreadSafe@Recommendpublic class EnumSingleton &#123; // 私有构造函数 private EnumSingleton() &#123;&#125; public static EnumSingleton getInstance() &#123; return Singleton.INSTANCE.getInstance(); &#125; private enum Singleton &#123; INSTANCE; private EnumSingleton singleton; // JVM保证这个方法绝对只调用一次 Singleton() &#123; singleton = new EnumSingleton(); &#125; public EnumSingleton getInstance() &#123; return singleton; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Concurrency</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[发布对象线程安全问题]]></title>
    <url>%2F2019%2F02%2F05%2F%E5%8F%91%E5%B8%83%E5%AF%B9%E8%B1%A1%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[发布对象，对象逸出并发问题详解 发布对象（NotThreadSafe）使一个对象能够被当前范围之外的代码所使用。 12345678910111213141516@Slf4j@NotThreadSafepublic class UnsafePublish &#123; private String[] states = &#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;; public String[] getStates()&#123; return states; &#125; public static void main(String[] args) &#123; UnsafePublish unsafePublish = new UnsafePublish(); log.info(&quot;&#123;&#125;&quot;, Arrays.toString(unsafePublish.getStates())); unsafePublish.getStates()[0] = &quot;d&quot;; log.info(&quot;&#123;&#125;&quot;, Arrays.toString(unsafePublish.getStates())); &#125;&#125; 对象逸出（NotThreadSafe）一种错误的发布。当一个对象还没有构建完成时，就使它被其他线程所见。1234567891011121314151617181920@NotThreadSafe@NotRecommendpublic class Escape &#123; private int thisCanBeEscape = 0; public Escape ()&#123; new InnerClass(); &#125; private class InnerClass &#123; public InnerClass()&#123; //获取的数据是未创建完的对象数据 log.info(&quot;&#123;&#125;&quot;, Escape.this.thisCanBeEscape); &#125; &#125; public static void main(String[] args) &#123; new Escape(); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Concurrency</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新年快乐]]></title>
    <url>%2F2019%2F02%2F05%2F%E6%96%B0%E5%B9%B4%E5%BF%AB%E4%B9%90%2F</url>
    <content type="text"><![CDATA[新年深夜更博~北京四年反省总结 在过去一年中，发生了很多大事，家人的离世，房贷的压力，互联网环境的变更，辞职决定去杭州发展，身上的压力是越来越重，我只有不停的学习，不停的进步才能减轻担忧。 我不是本科，也不是本专业，却走上了程序猿这条路，通过培训获取了当一名程序猿的资格，进了第一家公司不停加班，学习，才让我跟上工作步伐。 很恨自己中间有一年安逸的日子没有学习，只会玩手机，导致技术的滞后。安逸真的会使人堕落，而我本就没有这样的资格堕落。 2019新的一年到了，深刻的反省。 三月份到杭州，我会做一个学习计划，到时候再发博~ 在最后祝大家新年快乐，身体健康，合家团员。 best wishes:努力的去拥抱生活，让自己变得更好，不要辜负自己的青春，在最灿烂的年纪，绽放最耀眼的光芒。]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HashMap？面试？我是谁？我在哪]]></title>
    <url>%2F2019%2F02%2F04%2FHashMap%EF%BC%9F%E9%9D%A2%E8%AF%95%EF%BC%9F%E6%88%91%E6%98%AF%E8%B0%81%EF%BC%9F%E6%88%91%E5%9C%A8%E5%93%AA%2F</url>
    <content type="text"><![CDATA[面试经常被问到做个笔记，emmmmm 为什么用HashMap？ HashMap 是一个散列桶（数组和链表），它存储的内容是键值对 key-value 映射 HashMap 采用了数组和链表的数据结构，能在查询和修改方便继承了数组的线性查找和链表的寻址修改 HashMap 是非 synchronized，所以 HashMap 很快 HashMap 可以接受 null 键和值，而 Hashtable 则不能（原因就是 equlas() 方法需要对象，因为 HashMap 是后出的 API 经过处理才可以） HashMap 的工作原理是什么？HashMap 是基于 hashing 的原理 我们使用 put(key, value) 存储对象到 HashMap 中，使用 get(key) 从 HashMap 中获取对象。当我们给 put() 方法传递键和值时，我们先对键调用 hashCode() 方法，计算并返回的 hashCode 是用于找到 Map 数组的 bucket 位置来储存 Node 对象。 这里关键点在于指出，HashMap 是在 bucket 中储存键对象和值对象，作为Map.Node。 以下是 HashMap 初始化简化的模拟数据结构：1234567Node[] table = new Node[16]; // 散列桶初始化，tableclass Node &#123; hash; //hash值 key; //键 value; //值 node next; //用于指向链表的下一层（产生冲突，用拉链法）&#125; 以下是具体的 put 过程（JDK1.8） 对 Key 求 Hash 值，然后再计算下标 如果没有碰撞，直接放入桶中（碰撞的意思是计算得到的 Hash 值相同，需要放到同一个 bucket 中） 如果碰撞了，以链表的方式链接到后面 如果链表长度超过阀值（TREEIFY THRESHOLD==8），就把链表转成红黑树，链表长度低于6，就把红黑树转回链表 如果节点已经存在就替换旧值 如果桶满了（容量16*加载因子0.75），就需要 resize（扩容2倍后重排）]]></content>
  </entry>
  <entry>
    <title><![CDATA[Apache Bench]]></title>
    <url>%2F2019%2F02%2F03%2FApacheBench%2F</url>
    <content type="text"><![CDATA[Apache Bench简介ApacheBench 是 Apache 服务器自带的一个web压力测试工具，简称ab。ab又是一个命令行工具，对发起负载的本机要求很低，根据ab命令可以创建很多的并发访问线程，模拟多个访问者同时对某一URL地址进行访问，因此可以用来测试目标服务器的负载压力。总的来说ab工具小巧简单，上手学习较快，可以提供需要的基本性能指标，但是没有图形化结果，不能监控。 Apache Bench安装首先需要安装Apache服务器，下载地址：https://www.apachelounge.com/download/ Apache Bench使用了解参数123456789101112131415161718192021222324252627282930313233参数说明：格式：ab [options] [http://]hostname[:port]/path-n requests Number of requests to perform //本次测试发起的总请求数-c concurrency Number of multiple requests to make //一次产生的请求数（或并发数）-t timelimit Seconds to max. wait for responses //测试所进行的最大秒数，默认没有时间限制。-r Don&apos;t exit on socket receive errors. // 抛出异常继续执行测试任务 -p postfile File containing data to POST //包含了需要POST的数据的文件，文件格式如“p1=1&amp;p2=2”.使用方法是 -p 111.txt-T content-type Content-type header for POSTing//POST数据所使用的Content-type头信息，如 -T “application/x-www-form-urlencoded” 。 （配合-p）-v verbosity How much troubleshooting info to print//设置显示信息的详细程度 – 4或更大值会显示头信息， 3或更大值可以显示响应代码(404, 200等), 2或更大值可以显示警告和其他信息。 -V 显示版本号并退出。-C attribute Add cookie, eg. -C “c1=1234,c2=2,c3=3” (repeatable)//-C cookie-name=value 对请求附加一个Cookie:行。 其典型形式是name=value的一个参数对。此参数可以重复，用逗号分割。提示：可以借助session实现原理传递 JSESSIONID参数， 实现保持会话的功能，如-C ” c1=1234,c2=2,c3=3, JSESSIONID=FF056CD16DA9D71CB131C1D56F0319F8″ 。-w Print out results in HTML tables //以HTML表的格式输出结果。默认时，它是白色背景的两列宽度的一张表。-i Use HEAD instead of GET-x attributes String to insert as table attributes-y attributes String to insert as tr attributes-z attributes String to insert as td or th attributes-H attribute Add Arbitrary header line, eg. ‘Accept-Encoding: gzip’ Inserted after all normal header lines. (repeatable)-A attribute Add Basic WWW Authentication, the attributesare a colon separated username and password.-P attribute Add Basic Proxy Authentication, the attributes are a colon separated username and password.-X proxy:port Proxyserver and port number to use-V Print version number and exit-k Use HTTP KeepAlive feature-d Do not show percentiles served table.-S Do not show confidence estimators and warnings.-g filename Output collected data to gnuplot format file.-e filename Output CSV file with percentages served-h Display usage information (this message) 参数倒是挺多的不过，经常用的就是 -n -c ,记得配置path环境变量哈，不然要去bin目录下执行 例如:]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开篇博客]]></title>
    <url>%2F2019%2F02%2F03%2F%E5%BC%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[开个博客，写写东西。很早之间我就想做个博客，写一些技术文档，随笔，却一直没有沉下心来做这件事。 最近过年才有时间，大概花了1天时间搭建Hexo比想象中的简单多了，之前一直觉得挺麻烦的，也许是因为知识的积累和想拥有一个自己博客的迫切希望才促使我不断的去突破困难搭建完善。 搭建博客虽然简单，但是持之以恒的去写文章就很难了。我现在开篇立个flag，一周至少更新一篇技术博客，大家监督~ 我一直认为啊~技术宅真的是可以拯救世界的，大家一起加油吧！]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
</search>
