<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Linux常用命令]]></title>
    <url>%2F2019%2F02%2F17%2FLinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[就是做了一些整理~常用系统工作命令，系统状态检测命令，工作目录切换命令，文本文件编辑命令，文件目录管理命令，打包压缩与搜索命令~ 常用系统工作命令echoecho 命令用于在终端输出字符串或变量提取后的值，格式为“echo [字符串 | $变量] 1234[root@linuxprobe ~]# echo Linuxprobe.ComLinuxprobe.Com[root@linuxprobe ~]# echo $SHELL/bin/bash datedate 命令用于显示及设置系统的时间或日期，格式为“date [选项] [+指定的格式]”。 参数 作用 %t 跳格[Tab 键] %H 小时（00～23) %I 小时（00～12） %M 分钟（00～59） %S 秒（00～59） %j 今年中的第几天 12345678910[root@linuxprobe ]# dateMon Aug 24 16:11:23 CST 20[root@linuxprobe ~]# date &quot;+%Y-%m-%d %H:%M:%S&quot;2017-08-24 16:29:12[root@linuxprobe ~]# date -s &quot;20170901 8:30:00&quot;Fri Sep 1 08:30:00 CST 2017[root@linuxprobe ~]# dateFri Sep 1 08:30:01 CST 2017[root@linuxprobe ~]# date &quot;+%j&quot;244 rebootreboot 命令用于重启系统其格式为 rebo1[root@linuxprobe ]# rebo poweroffpoweroff 命令用于关闭系统，其格式为 powerof 1[root@linuxprobe ~]# powero wgetwget 命令用于在终端中下载网络文件，格式为“wget [参数] 下载地址” 参数 作用 -b 后台下载模式 -P 下载到指定目录 -t 最大尝试次数 -c 断点续传 -p 下载页面内所有资源，包括图片、视频等 -r 递归下载 1[root@linuxprobe ~]# wget http://www.linuxprobe.com/docs/LinuxProbe.pdf psps 命令用于查看系统中的进程状态，格式为“ps [参数]”。 参数 作用 -a 显示所有进程（包括其他用户的进程） -u 用户以及其他详细信息 -x 显示没有控制终端的进程 ➢R(运行)：进程正在运行或在运行队列中等待。 ➢S(中断)：进程处于休眠中，当某个条件形成后或者接收到信号时，则脱离该状态。 ➢D(不可中断)：进程不响应系统异步信号，即便用 kill 命令也不能将其中断。 ➢Z(僵死)：进程已经终止，但进程描述符依然存在, 直到父进程调用 wait4()系统函数后将进程释。 ➢ T(停止)：进程收到停止信号后停止。 表 2-7 进程(ps -aux) toptop 命令用于动态地监视进程活动与系统负载等信息，其格式为 top。 ➢ 第 1 行：系统时间、运行时间、登录终端数、系统负载（三个数值分别为 1 分钟、5分钟、15 分钟内的平均值，数值越小意味着负载越低）。 ➢ 第 2 行：进程总数、运行中的进程数、睡眠中的进程数、停止的进程数、僵死的进程数。 ➢ 第 3 行：用户占用资源百分比、系统内核占用资源百分比、改变过优先级的进程资源百分比、空闲的资源百分比等 ➢ 第 4 行：物理内存总量、内存使用量、内存空闲量、作为内核缓存的内存量。 ➢ 第 5 行：虚拟内存总量、虚拟内存使用量、虚拟内存空闲量、已被提前加载的内 pidofpidof 命令用于查询某个指定服务进程的 PID 值，格式为“pidof [参数] [服务名称]”。 12[root@linuxprobe]# pidof sshd2156 killkill 命令用于终止某个指定 PID 的服务进程，格式为“kill [参数] [进程 PID]”。 1[root@linuxprobe ]# kill -9 2156 killall用于终止某个指定名称的服务所对应的全部进程，格式为：“killall [参数] [服务名称]”。 12345[root@linuxprobe ~]# pidof httpd13581 13580 13579 13578 13577 13576[root@linuxprobe ~]# killall httpd[root@linuxprobe ~]# pidof httpd[root@linuxprobe ~]# 系统状态检测命令ifconfigifconfig 命令用于获取网卡配置与网络状态等信息，格式为“ifconfig [网络设备] [参数]。 主要查看的就是网卡名称、inet 参数后面的 IP 地址、ether 参数后面的网卡物理地址（又称为 MAC 地址），以及 RX、TX 的接收数据包与发送数据包的个数及累计流量。12345678910[root@linuxprobe ~]# ifconfigeno16777728: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500inet 192.168.10.10 netmask 255.255.255.0 broadcast 192.168.10.255inet6 fe80::20c:29ff:fec4:a409 prefixlen 64 scopeid 0x20&lt;link&gt;ether 00:0c:29:c4:a4:09 txqueuelen 1000 (Ethernet)RX packets 36 bytes 3176 (3.1 KiB)RX errors 0 dropped 0 overruns 0 frame 0TX packets 38 bytes 4757 (4.6 KiB)TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt; mtu 65536inet 127.0.0.1 netmask 255.0.0.0inet6 ::1 prefixlen 128 scopeid 0x10&lt;host&gt;loop txqueuelen 0 (Local Loopback)RX packets 386 bytes 32780 (32.0 KiB)RX errors 0 dropped 0 overruns 0 frame 0TX packets 386 bytes 32780 (32.0 KiB)TX errors 0 dropped 0 overruns 0 carrier 0 collisions unameuname 命令用于查看系统内核与系统版本等信息，格式为“uname [-a]”。 在使用 uname 命令时，一般会固定搭配上-a 参数来完整地查看当前系统的内核名称、主机名、内核发行版本、节点名、系统时间、硬件名称、硬件平台、处理器类型以及操作系统名称等信息。123[root@linuxprobe ~]# uname -aLinux linuxprobe.com 3.10.0-123.el7.x86_64 #1 SMP Mon May 5 11:16:57 EDT 2017x86_64 x86_64 x86_64 GNU/Linux uptimeuptime 用于查看系统的负载信息，格式为 uptime。 uptime 命令真的很棒，它可以显示当前系统时间、系统已运行时间、启用终端数量以及平均负载值等信息。平均负载值指的是系统在最近 1 分钟、5 分钟、15 分钟内的压力情况；负载值越低越好，尽量不要长期超过 1，在生产环境中不要超过 5。12[root@linuxprobe ~]# uptime22:49:55 up 10 min, 2 users, load average: 0.01, 0.19, 0.18 freefree 用于显示当前系统中内存的使用量信息，格式为“free [-h]”。1[root@linuxprobe ]# free whowho 命令用于查看当前登入主机的用户终端信息，格式为“who [参数]”。1[root@linuxprobe ~]# who lastlast 命令用于查看所有系统的登录记录，格式为“last [参数]”。使用 last 命令可以查看本机的登录记录。但是，由于这些信息都是以日志文件的形式保存在系统中，因此黑客可以很容易地对内容进行篡改。千万不要单纯以该命令的输出信息而判断系统有无被恶意入侵！12345678[root@linuxprobe ~]# lastroot pts/0 :0 Mon Aug 24 17:52 still logged inroot :0 :0 Mon Aug 24 17:52 still logged in(unknown :0 :0 Mon Aug 24 17:50 - 17:52 (00:02)reboot system boot 3.10.0-123.el7.x Tue Aug 25 01:49 - 18:17 (-7:-32)root pts/0 :0 Mon Aug 24 15:40 - 08:54 (7+17:14)root pts/0 :0 Fri Jul 10 10:49 - 15:37 (45+04:47)………………省略部分登录信息……………… historyhistory 命令用于显示历史执行过的命令，格式为“history [-c]”。history 命令应该是作者最喜欢的命令。执行 history 命令能显示出当前用户在本地计算机中执行过的最近 1000 条命令记录。如果觉得 1000 不够用，还可以自定义/etc/profile 文件中的HISTSIZE 变量值。在使用 history 命令时，如果使用-c 参数则会清空所有的命令历史记录。还可以使用“!编码数字”的方式来重复执行某一次的命令。总之，history 命令有很多有趣的玩法等待您去开发。 12345678910111213141516171819202122232425262728[root@linuxprobe ~]# history1 tar xzvf VMwareTools-9.9.0-2304977.tar.gz2 cd vmware-tools-distrib/3 ls4 ./vmware-install.pl -d5 reboot6 df -h7 cd /run/media/8 ls9 cd root/10 ls11 cd VMware\ Tools/12 ls13 cp VMwareTools-9.9.0-2304977.tar.gz /home14 cd /home15 ls16 tar xzvf VMwareTools-9.9.0-2304977.tar.gz17 cd vmware-tools-distrib/18 ls19 ./vmware-install.pl -d20 reboot21 history[root@linuxprobe ~]# !15anaconda-ks.cfg Documents initial-setup-ks.cfg Pictures TemplatesDesktop Downloads Music Public Videos[root@linuxprobe ~]# cat ~/.bash_history[root@linuxprobe ~]# history -c //清除 sosreportsosreport 命令用于收集系统配置及架构信息并输出诊断文档，格式为 sosreport。这个用的不多，需要的自己查资料~ 工作目录切换命令pwdpwd 命令用于显示用户当前所处的工作目录，格式为“pwd [选项]”。12[root@linuxprobe etc]# pwd/etc cdcd 命令用于切换工作路径，格式为“cd [目录名称]”。123[root@linuxprobe ~]# cd /etc //进入[root@linuxprobe bin]# cd - //返回上次[root@linuxprobe etc]# cd ~ //用户家目录 lsls 命令用于显示目录中的文件信息，格式为“ls [选项] [文件] ”。 所处的工作目录不同，当前工作目录下的文件肯定也不同。使用 ls 命令的“-a”参数看到全部文件（包括隐藏文件），使用“-l”参数可以查看文件的属性、大小等详细信息。将这两个参数整合之后，再执行 ls 命令即可查看当前目录中的所有文件并输出这些文件的属性。12345[root@linuxprobe ~]# ls -altotal 60dr-xr-x---. 14 root root 4096 May 4 07:56 .drwxr-xr-x. 17 root root 4096 May 4 15:55 ..省略............ 如果想要查看目录属性信息，则需要额外添加一个-d 参数。例如，可使用如下命令查看/etc 目录的权限与属性信息：1[root@linuxprobe ~]# ls -ld /etcdrwxr-xr-x. 132 root root 8192 Jul 10 10:48 /e 文本文件编辑命令catcat 命令用于查看纯文本文件（内容较少的），格式为“cat [选项] [文件]”。12345[root@linuxprobe ~]# cat -n initial-setup-ks.cfg1 #version=RHEL72 # X Window System configuration information3 xconfig --startxonboot省略.............. moremore 命令用于查看纯文本文件（内容较多的），格式为“more [选项]文件”。12345[root@linuxprobe ~]# more initial-setup-ks.cfg#version=RHEL7# X Window System configuration information省略............--More--(43%) headhead 命令用于查看纯文本文档的前 N 行，格式为“head [选项] [文件]”。1234[root@linuxprobe ~]# head -n 20 initial-setup-ks.cfg#version=RHEL7# X Window System configuration information省略............ tailtail 命令用于查看纯文本文档的后 N 行或持续刷新内容，格式为“tail [选项] [文件]”。 tail 命令最强悍的功能是可以持续刷新一个文件的内容，当想要实时查看最新日志文件时，这特别有用，此时的命令格式为“tail -f 文件名”：1234[root@linuxprobe ~]# tail -f /var/log/messagesMay 4 07:56:38 localhost gnome-session: Window manager warning: Log level 16:STACK_OP_ADD: window 0x1e00001 already in stack省略............ trtr 命令用于替换文本文件中的字符，格式为“tr [原始字符] [目标字符]”。 把某个文本内容中的英文全部替换为大写:1[root@linuxprobe ~]# cat anaconda-ks.cfg | tr [a-z] [A-Z] wcwc 命令用于统计指定文本的行数、字数、字节数，格式为“wc [参数] 文本”。 参数 作用 -l 只显示行数 -w 只显示单词数 -c 只显示字节数 12[root@linuxprobe ~]# wc -l /etc/passwd38 /etc/pass statstat 命令用于查看文件的具体存储信息和时间等信息，格式为“stat 文件名称”。12345678910[root@linuxprobe ~]# stat anaconda-ks.cfgFile: ‘anaconda-ks.cfg’Size: 1213 Blocks: 8 IO Block: 4096 regular fileDevice: fd00h/64768d Inode: 68912908 Links: 1Access: (0600/-rw-------) Uid: ( 0/ root) Gid: ( 0/ root)Context: system_u:object_r:admin_home_t:s0Access: 2017-07-14 01:46:18.721255659 -0400Modify: 2017-05-04 15:44:36.916027026 -0400Change: 2017-05-04 15:44:36.916027026 -0400Birth: - cutcut 命令用于按“列”提取文本字符，格式为“cut [参数] 文本”。 在 Linux 系统中，如何准确地提取出最想要的数据，这也是我们应该重点学习的内容。一般而言，按基于“行”的方式来提取数据是比较简单的，只需要设置好要搜索的关键词即可。但是如果按列搜索，不仅要使用-f 参数来设置需要看的列数，还需要使用-d 参数来设置间隔符号。passwd 在保存用户数据信息时，用户信息的每一项值之间是采用冒号来间隔的，接下来我们使用下述命令尝试提取出 passwd 文件中的用户名信息，即提取以冒号（：）为间隔符号的第一列内容：1234567891011121314151617[root@linuxprobe ~]# head -n 2 /etc/passwdroot:x:0:0:root:/root:/bin/bashbin:x:1:1:bin:/bin:/sbin/nologin[root@linuxprobe ~]# cut -d: -f1 /etc/passwdrootbindaemonadmlpsyncshutdownhaltmailoperatorgamesftp省略............... diff用于比较多个文本文件的差异，格式为“diff [参数] 文件”。123456789101112131415161718[root@linuxprobe ~]# diff --brief diff_A.txt diff_B.t*** diff_A.txt 2017-08-30 18:07:45.230864626 +0800--- diff_B.txt 2017-08-30 18:08:52.203860389 +0800****************** 1,5 ****! Welcome to linuxprobe.comRed Hat certified! Free Linux LessonsProfessional guidanceLinux Course--- 1,7 ----! Welcome tooo linuxprobe.com!Red Hat certified! Free Linux LeSSonS! ////////.....////////Professional guidanceLinux Course 文件目录管理命令touchtouch 命令用于创建空白文件或设置文件的时间，格式为“touch [选项] [文件]”。 参数 作用 -a 仅修改“读取时间”（atime） -m 仅修改“修改时间”（mtime） -d 同时修改 atime 与 mtime 123456789[root@linuxprobe ~]# ls -l anaconda-ks.cfg-rw-------. 1 root root 1213 May 4 15:44 anaconda-ks.cfg[root@linuxprobe ~]# echo &quot;Visit the LinuxProbe.com to learn linux skills&quot; &gt;&gt;anaconda-ks.cfg[root@linuxprobe ~]# ls -l anaconda-ks.cfg-rw-------. 1 root root 1260 Aug 2 01:26 anaconda-ks.cfg[root@linuxprobe ~]# touch -d &quot;2017-05-04 15:44&quot; anaconda-ks.cfg[root@linuxprobe ~]# ls -l anaconda-ks.cfg-rw-------. 1 root root 1260 May 4 15:44 anaconda-ks.cfg mkdirmkdir 命令用于创建空白的目录，格式为“mkdir [选项] 目录”。 123456[root@linuxprobe ~]# mkdir linuxprobe[root@linuxprobe ~]# cd linuxprobe[root@linuxprobe linuxprobe]# mkdir -p a/b/c/d/e[root@linuxprobe linuxprobe]# cd a[root@linuxprobe a]# cd b[root@linuxprobe b]# cpcp 命令用于复制文件或目录，格式为“cp [选项] 源文件 目标文件”。 参数 作用 -p 保留原始文件的属性 -d 若对象为“链接文件”，则保留该“链接文件”的属性 -r 递归持续复制（用于目录） -i 若目标文件存在则询问是否覆盖 -a 相当于-pdr（p、d、r 为上述参数） 1234[root@linuxprobe ~]# touch install.log[root@linuxprobe ~]# cp install.log x.log[root@linuxprobe ~]# lsinstall.log x.log mvmv 命令用于剪切文件或将文件重命名，格式为“mv [选项] 源文件 [目标路径|目标文件名]”。 123[root@linuxprobe ~]# mv x.log linux.log[root@linuxprobe ~]# lsinstall.log linux.log rmrm 命令用于删除文件或目录，格式为“rm [选项] 文件”。 想要删除一个目录，需要在 rm 命令后面一个-r 参数才可以。12345[root@linuxprobe ~]# rm install.logrm: remove regular empty file ‘install.log’? y[root@linuxprobe ~]# rm -f linux.log[root@linuxprobe ~]# ls[root@linuxprobe ~]# dddd 命令用于按照指定大小和个数的数据块来复制文件或转换文件，格式为“dd [参数]”。 dd 命令是一个比较重要而且比较有特色的一个命令，它能够让用户按照指定大小和个数的数据块来复制文件的内容。当然如果愿意的话，还可以在复制过程中转换其中的数据。Linux系统中有一个名为/dev/zero 的设备文件，每次在课堂上解释它时都充满哲学理论的色彩。因为这个文件不会占用系统存储空间，但却可以提供无穷无尽的数据，因此可以使用它作为 dd命令的输入文件，来生成一个指定大小的文件。 参数 作用 if 输入的文件名称 of 输出的文件名称 bs 设置每个“块”的大小 count 设置要复制“块”的个数 例如我们可以用 dd 命令从/dev/zero 设备文件中取出一个大小为 560MB 的数据块，然后保存成名为 560_file 的文件。在理解了这个命令后，以后就能随意创建任意大小的文件了：1234[root@linuxprobe ~]# dd if=/dev/zero of=560_file count=1 bs=560M1+0 records in1+0 records out587202560 bytes (587 MB) copied, 27.1755 s, 21.6 MB/s dd 命令的功能也绝不仅限于复制文件这么简单。如果您想把光驱设备中的光盘制作成 iso 格式的镜像文件，在 Windows 系统中需要借助于第三方软件才能做到，但在 Linux 系统中可以直接使用 dd 命令来压制出光盘镜像文件，将它变成一个可立即使用的 iso 镜像：1234[root@linuxprobe ~]# dd if=/dev/cdrom of=RHEL-server-7.0-x86_64-LinuxProbe.Com.iso7311360+0 records in7311360+0 records out3743416320 bytes (3.7 GB) copied, 370.758 s, 10.1 MB/s 考虑到有些读者会纠结 bs 块大小与 count 块个数的关系，下面举一个吃货的例子进行解释。假设小明的饭量（即需求）是一个固定的值，用来盛饭的勺子的大小即 bs 块大小，而用勺子盛饭的次数即 count 块个数。小明要想吃饱（满足需求），则需要在勺子大小（bs 块大小）与用勺子盛饭的次数（count 块个数）之间进行平衡。勺子越大，用勺子盛饭的次数就越少。由上可见，bs 与 count 都是用来指定容量的大小，只要能满足需求，可随意组合搭配方式。 filefile 命令用于查看文件的类型，格式为“file 文件名”。1234[root@linuxprobe ~]# file anaconda-ks.cfganaconda-ks.cfg: ASCII text[root@linuxprobe ~]# file /dev/sda/dev/sda: block special 打包压缩与搜索命令tartar 命令用于对文件进行打包压缩或解压，格式为“tar [选项] [文件]”。 参数 作用 -c 创建压缩文件 -x 解开压缩文件 -t 查看压缩包里面有哪些文件 -z 用Gzip压缩或解压 -j 用bzip2压缩或解压 -v 显示压缩或解压过程 -f 目标文件名 -P 保存原始的权限与属性 -p 使用绝对路径来压缩 -C 指定解压目录 123[root@linuxprobe ~]# tar -czvf etc.tar.gz /etc[root@linuxprobe ~]# mkdir /root/etc[root@linuxprobe ~]# tar xzvf etc.tar.gz -C /root/etc grepgrep 命令用于在文本中执行关键词搜索，并显示匹配的结果，格式为“grep [选项] [文件]”。 参数 作用 -b 将可执行文件（binary）当作文本文件（text）来搜索 -c 仅显示找到的行数 -i 忽略大小写 -n 显示行号 -v 反向选择—仅列出没有“关键词”的行 在 Linux 系统中，/etc/passwd 文件是保存着所有的用户信息，而一旦用户的登录终端被设置成/sbin/nologin，则不再允许登录系统，因此可以使用 grep 命令来查找出当前系统中不允许登录系统的所有用户信息： 12345678[root@linuxprobe ~]# grep /sbin/nologin /etc/passwdbin:x:1:1:bin:/bin:/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologinadm:x:3:4:adm:/var/adm:/sbin/nologinlp:x:4:7:lp:/var/spool/lpd:/sbin/nologinmail:x:8:12:mail:/var/spool/mail:/sbin/nologinoperator:x:11:0:operator:/root:/sbin/nologin………………省略部分输出过程信息……………… findfind 命令用于按照指定条件来查找文件，格式为“find [查找路径] 寻找条件 操作”。 在 Linux 系统中，搜索工作一般都是通过 find 命令来完成的，它可以使用不同的文件特性作为寻找条件（如文件名、大小、修改时间、权限等信息），一旦匹配成功则默认将信息显示到屏幕上。 参数 作用 -name 匹配名称 -perm 匹配权限（mode 为完全匹配，-mode 为包含即可） -user 匹配所有者 -group 匹配所有组 -mtime -n +n 匹配修改内容的时间（-n 指 n 天以内，+n 指 n 天以前） -atime -n +n 匹配访问文件的时间（-n 指 n 天以内，+n 指 n 天以前） -ctime -n +n 匹配修改文件权限的时间（-n 指 n 天以内，+n 指 n 天以前） -nouser 匹配无所有者的文件 -nogroup 匹配无所有组的文件 -newer f1 !f2 匹配比文件 f1 新但比 f2 旧的文件 –type b/d/c/p/l/f 匹配文件类型（后面的字母参数依次表示块设备、目录、字符设备、管道、链接文件、文本文件） -size 匹配文件的大小（+50KB 为查找超过 50KB 的文件，而-50KB 为查找小于 50KB 的文件） -prune 忽略某个目录 -exec …… {}\; 后面可跟用于进一步处理搜索结果的命令 12345678//获取到该目录中所有以 host 开头的文件列表[root@linuxprobe ~]# find /etc -name &quot;host*&quot; -print/etc/avahi/hosts/etc/host.conf/etc/hosts/etc/hosts.allow/etc/hosts.deny/etc/hostname 12//在整个文件系统中找出所有归属于linuxprobe用户的文件并复制到/root/findresults目录[root@linuxprobe ~]# find / -user linuxprobe -exec cp -a &#123;&#125; /root/findresults/ \; 参考书籍《LinuxProbe》 Linux命令查找]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>command</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OSI参考模型图]]></title>
    <url>%2F2019%2F02%2F13%2FOSI%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[这是一张很长很详细的图~]]></content>
  </entry>
  <entry>
    <title><![CDATA[ReentrantLock与锁]]></title>
    <url>%2F2019%2F02%2F10%2FReentrantLock%E4%B8%8E%E9%94%81%2F</url>
    <content type="text"><![CDATA[ReentrantLock与锁之间的区别及使用~ ReentrantLock（重入锁）与synchronize区别 可重入性：两个都是可以重入的进行锁的计数 锁的实现：ReentrantLock用的是程序实现（用户态），synchronized用的是JVM实现（内核态） 性能的区别：synchronized（轻量级锁，偏向锁）经过优化后和ReentrantLock性能差不多 功能区别：ReentrantLock更加的灵活（细粒度高），synchronized更加便利 ReentrantLock（重入锁）独有的功能 可以指定是公平锁还是非公平锁 提供了一个Condition类，可以分组唤醒需要唤醒的线程 提供能够中断等待锁的线程的机制，lock.lockInterrupibly 12345678910111213141516171819202122232425262728293031323334//ReentrantLock及Condition使用@Slf4jpublic class ConditionExample &#123; public static void main(String[] args) &#123; ReentrantLock reentrantLock = new ReentrantLock(); Condition condition = reentrantLock.newCondition(); new Thread(() -&gt; &#123; try&#123; reentrantLock.lock(); log.info(&quot;wait signal&quot;);// 1 condition.await(); &#125;catch(InterruptedException e)&#123; e.printStackTrace(); &#125; log.info(&quot;get signal&quot;);// 4 reentrantLock.unlock(); &#125;).start(); new Thread(() -&gt; &#123; reentrantLock.lock(); log.info(&quot;get Lock&quot;);// 2 try&#123; Thread.sleep(3000); &#125;catch(InterruptedException e)&#123; e.printStackTrace(); &#125; condition.signalAll(); log.info(&quot;send signal ~&quot;);// 3 reentrantLock.unlock(); &#125;).start(); &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java线程类测试]]></title>
    <url>%2F2019%2F02%2F08%2FJava%E7%BA%BF%E7%A8%8B%E7%B1%BB%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[对java中的线程安全类及不安全的类进行测试~ 线程不安全类 StringBuilder -&gt; StringBuffer SimpleDateFormat -&gt; JodaTime 同步容器 ArrayList -&gt; Vector,Stack HashMap -&gt; HashTable(key, value不能为null) Collections.synchronizedXXX(List, Set, Map) 并发容器 ArrayList -&gt; CopyOnWriteArrayList HashSet,TreeSet -&gt; CopyOnWriteArraySet,ConcurrentSkipListSet HashMap,TreeMap -&gt; ConcurrentHashMap,ConcurrentSkipListMap 1234567891011121314151617181920212223242526272829303132333435//可以自行进行测试public class ConcurrencyTest &#123; //请求总数 public static int clientTotal = 5000; //同时并发执行的线程数 public static int threadTotal = 200; public static int count = 0; public static void main(String[] args) throws Exception &#123; ExecutorService executorService = Executors.newCachedThreadPool(); final Semaphore semaphore = new Semaphore(threadTotal); final CountDownLatch countDownLatch = new CountDownLatch(clientTotal); for (int i = 0; i &lt; clientTotal; i++) &#123; executorService.execute(() -&gt; &#123; try&#123; semaphore.acquire(); add(); semaphore.release(); &#125; catch (Exception e)&#123; log.error(&quot;exception&quot; , e); &#125; countDownLatch.countDown(); &#125;); &#125; countDownLatch.await(); executorService.shutdown(); log.info(&quot;count:&#123;&#125;&quot; , count); &#125; private static void add()&#123; count++; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java线程封闭]]></title>
    <url>%2F2019%2F02%2F08%2FJava%E7%BA%BF%E7%A8%8B%E5%B0%81%E9%97%AD%2F</url>
    <content type="text"><![CDATA[java是如何保持线程之间的不互相干扰？ 线程封闭 Ad-hoc线程封闭：程序控制，最糟糕，忽略 堆栈封闭：局部变量(利用不同的虚拟机栈副本存储) ThreadLocal线程封闭：特别好的封闭方法 1234567891011121314151617181920//ThreadLocal线程封闭public class RequestHolder &#123; private final static ThreadLocal&lt;Long&gt; requestHolder = new ThreadLocal&lt;Long&gt;(); public static void add(Long id)&#123; requestHolder.set(id); &#125; public static Long getId()&#123; //自动获取key(当前线程对象地址),找出value值返回 return requestHolder.get(); &#125; public static void remove()&#123; //数据会一直存到项目重启 //数据一定要移除，避免产生内存溢出(oom) requestHolder.remove(); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java不可变对象]]></title>
    <url>%2F2019%2F02%2F07%2Fjava%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[不可变对象定义，作用，使用方式详解。 不可变对象需要满足的条件： 对象创建以后其状态就不能修改 对象所有域都是final类型 对象时正确创建的（在对象创建期间，this引用没有逸出） 123456789101112131415161718192021222324252627282930313233//final关键字：类，方法，变量// 修饰类：不能被继承// 修饰方法：1.锁定方法不能被继承类修改（默认为private）;2.效率// 修饰变量：基本数据类型变量，引用类型变量@Slf4j@NotThreadSafepublic class ImmutableFinal &#123; private final static Integer a = 1; private final static String b = &quot;2&quot;; //guava private final static Map&lt;Integer, Integer&gt; map = Maps.newHashMap(); static &#123; map.put(1, 2); map.put(3, 4); map.put(5, 6); &#125; public static void main(String[] args) &#123; //a = 2; //b = &quot;3&quot;; //map = Maps.newHashMap(); //map引用不能修改，但是内部的值还是可以进行修改~ map.put(1, 3); log.info(&quot;&#123;&#125;&quot;,map.get(1)); &#125; //final参数不能修改 private void test(final int a)&#123; // a = 1 &#125;&#125; 1234567891011121314151617181920////利用基本的类库进行不可变Map对象的创建（内部参数也不可以改变）@Slf4j@ThreadSafepublic class ImmutableMap &#123; private static Map&lt;Integer, Integer&gt; map = Maps.newHashMap(); static&#123; map.put(1, 2); map.put(3, 4); map.put(5, 6); //java map = Collections.unmodifiableMap(map); &#125; public static void main(String[] args) &#123; //会报错哈~UnsupportedOperationException map.put(1, 3); log.info(&quot;&#123;&#125;&quot;, map.get(1)); &#125;&#125; 1234567891011121314151617//利用Guava的类库进行不可变Map对象的创建（内部参数也不可以改变）@ThreadSafepublic class ImmutableGuava &#123; private final static ImmutableList&lt;Integer&gt; list = ImmutableList.of(1, 2, 3); private final static ImmutableSet set = ImmutableSet.copyOf(list); private final static ImmutableMap&lt;Integer, Integer&gt; map = ImmutableMap.of(1, 2, 3, 4); private final static ImmutableMap&lt;Integer, Integer&gt; map2 = ImmutableMap.&lt;Integer, Integer&gt;builder() .put(1, 2).put(3, 4).put(5, 6).build(); public static void main(String[] args) &#123; System.out.println(map2.get(3)); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[jdk，jre你真的懂吗？]]></title>
    <url>%2F2019%2F02%2F07%2Fjdk%EF%BC%8Cjre%E4%BD%A0%E7%9C%9F%E7%9A%84%E6%87%82%E5%90%97%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[关于jdk和jre 大家肯定在安装JDK的时候会有选择是否安装单独的jre，一般都会一起安装，我也建议大家这样做。因为这样更能帮助大家弄清楚它们的区别：Jre 是java runtime environment, 是java程序的运行环境。既然是运行，当然要包含jvm，也就是大家熟悉的虚拟机啦，还有所有java类库的class文件，都在lib目录下打包成了jar。大家可以自己验证。至于在windows上的虚拟机是哪个文件呢？学过MFC的都知道什么是dll文件吧，那么大家看看jre/bin/client里面是不是有一个jvm.dll呢？那就是虚拟机。 Jdk 是java development kit，是java的开发工具包，里面包含了各种类库和工具。当然也包括了另外一个Jre. 那么为什么要包括另外一个Jre呢？而且jdk/jre/bin同时有client和server两个文件夹下都包含一个jvm.dll。说明是有两个虚拟机的。这一点不知道大家是否注意到了呢？ 相信大家都知道jdk的bin下有各种java程序需要用到的命令，与jre的bin目录最明显的区别就是jdk下才有javac，这一点很好理解，因为 jre只是一个运行环境而已。与开发无关，正因为如此，具备开发功能的jdk自己的jre下才会同时有client性质的jvm和server性质的 jvm， 而仅仅作为运行环境的jre下只需要client性质的jvm.dll就够了。 记得在环境变量path中设置jdk/bin路径麽？这应该是大家学习Java的第一步吧，老师会告诉大家不设置的话javac和java是用不了的。确实jdk/bin目录下包含了所有的命令。可是有没有人想过我们用的java命令并不是 jdk/bin目录下的而是jre/bin目录下的呢？不信可以做一个实验，大家可以把jdk/bin目录下的java.exe剪切到别的地方再运行 java程序，发现了什么？一切OK！ 那么有人会问了？我明明没有设置jre/bin目录到环境变量中啊？ 试想一下如果java为了提供给大多数人使用，他们是不需要jdk做开发的，只需要jre能让java程序跑起来就可以了，那么每个客户还需要手动去设置环境变量多麻烦啊？所以安装jre的时候安装程序自动帮你把jre的java.exe添加到了系统变量中，验证的方法很简单，大家看到了系统环境变量的 path最前面有“%SystemRoot%system32;%SystemRoot%;”这样的配置，那么再去Windows/system32下面去看看吧，发现了什么？有一个java.exe。 如果强行能够把jdk/bin挪到system32变量前面，当然也可以迫使使用jdk/jre里面的java，不过除非有必要，我不建议大家这么做。使用单独的jre跑java程序也算是客户环境下的一种测试。 ——————————————————————————————————————————— 通俗点来说： jdk是java的开发包，其中包括jre;jre仅仅是java的运行时环境；而JDK包括了同版本的JRE，此外还包括有编译器和其它工具 JDK是java开发工具包(java Development Kit)的缩写。它是一种构建在java平台上发布的应用程序、apple和组件的开发环境。JDK是一切java应用程序的基础，所有的java应用程序是构建在这个之上的。它是一组API，也可以说是一些java Class。要成为一个Java程序员，JDK是必不可少的最基本的工具。 JRE是Java运行环境(Java Runtime Enviroment)的缩写。它基本上就和Java虚拟机是同一个概念。一般来说，在谈论一个具体的产品的时候，可以说“JRE”,而说到理论中的一个模型的时候，我们常用的是“Java虚拟机”。要使用Java程序，JRE是必不可少的环境。 如果机子里安装了多个版本的jdk，如下： BEA Weblogic Server 7.0 自带一套 JDK1.3.1_02下载了一套最新的JDK1.4.1_02JBuilder9自带一套JKD1.4.1_02Oracle8.1.7自带一套JRE1.1.7Ration Rose自带一套JDK1.3DreamWeaver自带一套JDK1.3 6套JRE，每套JRE都被各自安装到不同的目录，不会互相影响。当在控制台执行java.exe，操作系统寻找JRE的方式如下： 先找当前目录下有没有JRE再找父目录下有没有JRE接着在PATH路径中找JRE（一般运行时从path中查找，按照path设置前后顺序，以前面为准）注册表HKEY_LOCAL_MACHINE\SOFTWARE\JavaSoft\Java Runtime Environment\ 查看CurrentVersion的键值指向哪个JRE（一般XP下是这个：C:\Program Files\Java\jre6） 最常用的是在PATH路径中找JRE，一般情况下，自己的程序运行之前都会先在批处理文件里面临时设置PATH，把自己用的JRE放到PATH路径最前面，所以肯定会运行自己带的JRE，不会造成版本混乱。 ——————————————————————————————————————————————JDK就是Java Development Kit.简单的说JDK是面向开发人员使用的SDK，它提供了Java的开发环境和运行环境。SDK是Software Development Kit 一般指软件开发包，可以包括函数库、编译程序等。 JRE是Java Runtime Enviroment是指Java的运行环境，是面向Java程序的使用者，而不是开发者。 如果安装了JDK，会发同你的电脑有两套JRE，一套位于 \jre 另外一套位于 C:\Program Files\Java\jre1.5.0_15 目录下，后面这套比前面那套少了Server端的Java虚拟机，不过直接将前面那套的Server端Java虚拟机复制过来就行了。而且在安装JDK可以选择是否安装这个位于 C:\Program Files\Java 目录下的JRE。如果你只安装JRE，而不是JDK，那么只会在 C:\Program Files\Java 目录下安装唯一的一套JRE。 JRE的地位就象一台PC机一样，我们写好的Win32应用程序需要操作系统帮我们运行，同样的，我们编写的Java程序也必须要JRE才能运行。所以当你装完JDK后，如果分别在硬盘上的两个不同地方安装了两套JRE，那么你可以想象你的电脑有两台虚拟的Java PC机，都具有运行Java程序的功能。所以我们可以说，只要你的电脑安装了JRE，就可以正确运行Java应用程序。 为什么Sun要让JDK安装两套相同的JRE？ 这是因为JDK里面有很多用Java所编写的开发工具（如javac.exe、jar.exe等），而且都放置在 \lib\tools.jar 里。从下面例子可以看出，先将tools.jar改名为tools1.jar，然后运行javac.exe，显示如下结果： Exception in thread “main” java.lang.NoClassDefFoundError: com/sun/tools/javac /Main 这个意思是说，你输入javac.exe与输入 java -cp c:\jdk\lib\tools.jar com.sun.tools.javac.Main 是一样的，会得到相同的结果。从这里我们可以证明javac.exe只是一个包装器（Wrapper），而制作的目的是为了让开发者免于输入太长的指命。而且可以发现\lib目录下的程序都很小，不大于2 9K，从这里我们可以得出一个结论。就是JDK里的工具几乎是用Java所编写，所以也是Java应用程序，因此要使用JDK所附的工具来开发Java程序，也必须要自行附一套JRE才行，所以位于C:\Program Files\Java目录下的那套JRE就是用来运行一般Java程序用的。 如果一台电脑安装两套以上的JRE，谁来决定呢？ 这个重大任务就落在java.exe身上。Java.exe的工作就是找到合适的JRE来运行Java程序。 Java.exe依照底下的顺序来查找JRE：自己的目录下有没有JRE；父目录有没有JRE；查询注册表： [HKEY_LOCAL_MACHINE\SOFTWARE\JavaSoft\Java Runtime Environment] 所以java.exe的运行结果与你的电脑里面哪个JRE被执行有很大的关系。 ADD：（小小结） JVM – java virtual machineJVM就是我们常说的java虚拟机，它是整个java实现跨平台的最核心的部分，所有的java程序会首先被编译为.class的类文件，这种类文件可以在虚拟机上执行，也就是说class并不直接与机器的操作系统相对应，而是经过虚拟机间接与操作系统交互，由虚拟机将程序解释给本地系统执行。 JRE – java runtime environmentJRE是指java运行环境。光有JVM还不能成class的执行，因为在解释class的时候JVM需要调用解释所需要的类库lib。在JDK的安装目录里你可以找到jre目录，里面有两个文件夹bin和lib,在这里可以认为bin里的就是jvm，lib中则是jvm工作所需要的类库，而jvm和 lib和起来就称为jre。所以，在你写完java程序编译成.class之后，你可以把这个.class文件和jre一起打包发给朋友，这样你的朋友就可以运行你写程序了。（jre里有运行.class的java.exe） JDK – java development kitJDK是java开发工具包，基本上每个学java的人都会先在机器上装一个JDK，那他都包含哪几部分呢？让我们看一下JDK的安装目录。在目录下面有六个文件夹、一个src类库源码压缩包、和其他几个声明文件。其中，真正在运行java时起作用的是以下四个文件夹：bin、include、lib、 jre。现在我们可以看出这样一个关系，JDK包含JRE，而JRE包含JVM。bin:最主要的是编译器(javac.exe)include:java和JVM交互用的头文件lib：类库jre:java运行环境（注意：这里的bin、lib文件夹和jre里的bin、lib是不同的）总的来说JDK是用于java程序的开发,而jre则是只能运行class而没有编译的功能。 eclipse、idea等其他IDE有自己的编译器而不是用JDK bin目录中自带的，所以在安装时你会发现他们只要求你选中jre路径就ok了。 ITeye原文]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[中国式的人情社会]]></title>
    <url>%2F2019%2F02%2F06%2F%E4%B8%AD%E5%9B%BD%E5%BC%8F%E7%9A%84%E4%BA%BA%E6%83%85%E7%A4%BE%E4%BC%9A%2F</url>
    <content type="text"><![CDATA[最近想到的一些东西，随便写写。 不知道为什么我这个人一直不喜欢麻烦别人，从北京辞职回来以后，我说要去杭州，就各种亲戚和我说“那谁谁也是在杭州做事，可以帮你介绍工作。。可以住他家里，又谁谁在那里买了房子”。我知道大家都是好心，可是我就想靠自己做出一番事情也不管成功或者失败。。。最好谁也别搭理我~（ps:感觉很讨厌这样的环境，好奇怪） （没有结果，也没有结论…..就是想说说记录下，查查资料后再补上） 还有哦~一个人经济及社会地位决定了你社交圈，当你突破当前的社交圈向上走的时候，你会感觉到自身的不足，也会自卑，而你需要做的就是努力的融入进去然后继续向上走~ 为自己加油吧~ 2019年 需要做的事情（社交能力的提升，健身，本科文凭，工作）]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[如何安全发布对象？]]></title>
    <url>%2F2019%2F02%2F05%2F%E5%A6%82%E4%BD%95%E5%AE%89%E5%85%A8%E5%8F%91%E5%B8%83%E5%AF%B9%E8%B1%A1%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[安全发布对象详解~ 在静态初始化函数中初始化一个对象引用 将对象的引用保存到volatile类型域或者AtomicReference对象中 将对象的引用保存到某个正确构造对象的final类型域中 将对象的引用保存到一个由锁保护的域中 例子：1234567891011121314151617181920212223242526272829/** * 懒汉模式 -》 双重同步锁单例模式 * 单例实例在第一次使用时进行创建 */@ThreadSafepublic class LazySingleton &#123; // 私有构造函数 private LazySingleton() &#123;&#125; // 1、memory = allocate() 分配对象的内存空间 // 2、ctorInstance() 初始化对象 // 3、instance = memory 设置instance指向刚分配的内存 // 单例对象 volatile + 双重检测机制 -&gt; 禁止指令重排 private volatile static LazySingleton instance = null; // 静态的工厂方法 public static LazySingleton getInstance() &#123; if (instance == null) &#123; // 双重检测机制 synchronized (LazySingleton.class) &#123; // 同步锁 if (instance == null) &#123; instance = new LazySingleton(); &#125; &#125; &#125; return instance; &#125;&#125; 12345678910111213141516171819202122232425/** * 饿汉模式 * 单例实例在类装载时进行创建 */@ThreadSafepublic class HungrySingleton &#123; // 私有构造函数 private HungrySingleton() &#123;&#125; // 单例对象 private static HungrySingleton instance = new HungrySingleton(); /* private static SingletonExample6 instance = null; static &#123; instance = new SingletonExample6(); &#125;*/ // 静态的工厂方法 public static HungrySingleton getInstance() &#123; return instance; &#125;&#125; 1234567891011121314151617181920212223242526272829/** * 枚举模式：最安全 */@ThreadSafe@Recommendpublic class EnumSingleton &#123; // 私有构造函数 private EnumSingleton() &#123;&#125; public static EnumSingleton getInstance() &#123; return Singleton.INSTANCE.getInstance(); &#125; private enum Singleton &#123; INSTANCE; private EnumSingleton singleton; // JVM保证这个方法绝对只调用一次 Singleton() &#123; singleton = new EnumSingleton(); &#125; public EnumSingleton getInstance() &#123; return singleton; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Concurrency</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[发布对象线程安全问题]]></title>
    <url>%2F2019%2F02%2F05%2F%E5%8F%91%E5%B8%83%E5%AF%B9%E8%B1%A1%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[发布对象，对象逸出并发问题详解 发布对象（NotThreadSafe）使一个对象能够被当前范围之外的代码所使用。 12345678910111213141516@Slf4j@NotThreadSafepublic class UnsafePublish &#123; private String[] states = &#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;; public String[] getStates()&#123; return states; &#125; public static void main(String[] args) &#123; UnsafePublish unsafePublish = new UnsafePublish(); log.info(&quot;&#123;&#125;&quot;, Arrays.toString(unsafePublish.getStates())); unsafePublish.getStates()[0] = &quot;d&quot;; log.info(&quot;&#123;&#125;&quot;, Arrays.toString(unsafePublish.getStates())); &#125;&#125; 对象逸出（NotThreadSafe）一种错误的发布。当一个对象还没有构建完成时，就使它被其他线程所见。1234567891011121314151617181920@NotThreadSafe@NotRecommendpublic class Escape &#123; private int thisCanBeEscape = 0; public Escape ()&#123; new InnerClass(); &#125; private class InnerClass &#123; public InnerClass()&#123; //获取的数据是未创建完的对象数据 log.info(&quot;&#123;&#125;&quot;, Escape.this.thisCanBeEscape); &#125; &#125; public static void main(String[] args) &#123; new Escape(); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Concurrency</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新年快乐]]></title>
    <url>%2F2019%2F02%2F05%2F%E6%96%B0%E5%B9%B4%E5%BF%AB%E4%B9%90%2F</url>
    <content type="text"><![CDATA[新年深夜更博~北京四年反省总结 在过去一年中，发生了很多大事，家人的离世，房贷的压力，互联网环境的变更，辞职决定去杭州发展，身上的压力是越来越重，我只有不停的学习，不停的进步才能减轻担忧。 我不是本科，也不是本专业，却走上了程序猿这条路，通过培训获取了当一名程序猿的资格，进了第一家公司不停加班，学习，才让我跟上工作步伐。 很恨自己中间有一年安逸的日子没有学习，只会玩手机，导致技术的滞后。安逸真的会使人堕落，而我本就没有这样的资格堕落。 2019新的一年到了，深刻的反省。 三月份到杭州，我会做一个学习计划，到时候再发博~ 在最后祝大家新年快乐，身体健康，合家团员。 best wishes:努力的去拥抱生活，让自己变得更好，不要辜负自己的青春，在最灿烂的年纪，绽放最耀眼的光芒。]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HashMap？面试？我是谁？我在哪]]></title>
    <url>%2F2019%2F02%2F04%2FHashMap%EF%BC%9F%E9%9D%A2%E8%AF%95%EF%BC%9F%E6%88%91%E6%98%AF%E8%B0%81%EF%BC%9F%E6%88%91%E5%9C%A8%E5%93%AA%2F</url>
    <content type="text"><![CDATA[面试经常被问到做个笔记，emmmmm 为什么用HashMap？ HashMap 是一个散列桶（数组和链表），它存储的内容是键值对 key-value 映射 HashMap 采用了数组和链表的数据结构，能在查询和修改方便继承了数组的线性查找和链表的寻址修改 HashMap 是非 synchronized，所以 HashMap 很快 HashMap 可以接受 null 键和值，而 Hashtable 则不能（原因就是 equlas() 方法需要对象，因为 HashMap 是后出的 API 经过处理才可以） HashMap 的工作原理是什么？HashMap 是基于 hashing 的原理 我们使用 put(key, value) 存储对象到 HashMap 中，使用 get(key) 从 HashMap 中获取对象。当我们给 put() 方法传递键和值时，我们先对键调用 hashCode() 方法，计算并返回的 hashCode 是用于找到 Map 数组的 bucket 位置来储存 Node 对象。 这里关键点在于指出，HashMap 是在 bucket 中储存键对象和值对象，作为Map.Node。 以下是 HashMap 初始化简化的模拟数据结构：1234567Node[] table = new Node[16]; // 散列桶初始化，tableclass Node &#123; hash; //hash值 key; //键 value; //值 node next; //用于指向链表的下一层（产生冲突，用拉链法）&#125; 以下是具体的 put 过程（JDK1.8） 对 Key 求 Hash 值，然后再计算下标 如果没有碰撞，直接放入桶中（碰撞的意思是计算得到的 Hash 值相同，需要放到同一个 bucket 中） 如果碰撞了，以链表的方式链接到后面 如果链表长度超过阀值（TREEIFY THRESHOLD==8），就把链表转成红黑树，链表长度低于6，就把红黑树转回链表 如果节点已经存在就替换旧值 如果桶满了（容量16*加载因子0.75），就需要 resize（扩容2倍后重排）]]></content>
  </entry>
  <entry>
    <title><![CDATA[Apache Bench]]></title>
    <url>%2F2019%2F02%2F03%2FApacheBench%2F</url>
    <content type="text"><![CDATA[Apache Bench简介ApacheBench 是 Apache 服务器自带的一个web压力测试工具，简称ab。ab又是一个命令行工具，对发起负载的本机要求很低，根据ab命令可以创建很多的并发访问线程，模拟多个访问者同时对某一URL地址进行访问，因此可以用来测试目标服务器的负载压力。总的来说ab工具小巧简单，上手学习较快，可以提供需要的基本性能指标，但是没有图形化结果，不能监控。 Apache Bench安装首先需要安装Apache服务器，下载地址：https://www.apachelounge.com/download/ Apache Bench使用了解参数123456789101112131415161718192021222324252627282930313233参数说明：格式：ab [options] [http://]hostname[:port]/path-n requests Number of requests to perform //本次测试发起的总请求数-c concurrency Number of multiple requests to make //一次产生的请求数（或并发数）-t timelimit Seconds to max. wait for responses //测试所进行的最大秒数，默认没有时间限制。-r Don&apos;t exit on socket receive errors. // 抛出异常继续执行测试任务 -p postfile File containing data to POST //包含了需要POST的数据的文件，文件格式如“p1=1&amp;p2=2”.使用方法是 -p 111.txt-T content-type Content-type header for POSTing//POST数据所使用的Content-type头信息，如 -T “application/x-www-form-urlencoded” 。 （配合-p）-v verbosity How much troubleshooting info to print//设置显示信息的详细程度 – 4或更大值会显示头信息， 3或更大值可以显示响应代码(404, 200等), 2或更大值可以显示警告和其他信息。 -V 显示版本号并退出。-C attribute Add cookie, eg. -C “c1=1234,c2=2,c3=3” (repeatable)//-C cookie-name=value 对请求附加一个Cookie:行。 其典型形式是name=value的一个参数对。此参数可以重复，用逗号分割。提示：可以借助session实现原理传递 JSESSIONID参数， 实现保持会话的功能，如-C ” c1=1234,c2=2,c3=3, JSESSIONID=FF056CD16DA9D71CB131C1D56F0319F8″ 。-w Print out results in HTML tables //以HTML表的格式输出结果。默认时，它是白色背景的两列宽度的一张表。-i Use HEAD instead of GET-x attributes String to insert as table attributes-y attributes String to insert as tr attributes-z attributes String to insert as td or th attributes-H attribute Add Arbitrary header line, eg. ‘Accept-Encoding: gzip’ Inserted after all normal header lines. (repeatable)-A attribute Add Basic WWW Authentication, the attributesare a colon separated username and password.-P attribute Add Basic Proxy Authentication, the attributes are a colon separated username and password.-X proxy:port Proxyserver and port number to use-V Print version number and exit-k Use HTTP KeepAlive feature-d Do not show percentiles served table.-S Do not show confidence estimators and warnings.-g filename Output collected data to gnuplot format file.-e filename Output CSV file with percentages served-h Display usage information (this message) 参数倒是挺多的不过，经常用的就是 -n -c ,记得配置path环境变量哈，不然要去bin目录下执行 例如:]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开篇博客]]></title>
    <url>%2F2019%2F02%2F03%2F%E5%BC%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[开个博客，写写东西。很早之间我就想做个博客，写一些技术文档，随笔，却一直没有沉下心来做这件事。 最近过年才有时间，大概花了1天时间搭建Hexo比想象中的简单多了，之前一直觉得挺麻烦的，也许是因为知识的积累和想拥有一个自己博客的迫切希望才促使我不断的去突破困难搭建完善。 搭建博客虽然简单，但是持之以恒的去写文章就很难了。我现在开篇立个flag，一周至少更新一篇技术博客，大家监督~ 我一直认为啊~技术宅真的是可以拯救世界的，大家一起加油吧！]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
</search>
