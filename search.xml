<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[OSI参考模型图]]></title>
    <url>%2F2019%2F02%2F13%2FOSI%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[这是一张很长很详细的图~]]></content>
  </entry>
  <entry>
    <title><![CDATA[ReentrantLock与锁]]></title>
    <url>%2F2019%2F02%2F10%2FReentrantLock%E4%B8%8E%E9%94%81%2F</url>
    <content type="text"><![CDATA[ReentrantLock与锁之间的区别及使用~ ReentrantLock（重入锁）与synchronize区别 可重入性：两个都是可以重入的进行锁的计数 锁的实现：ReentrantLock用的是程序实现（用户态），synchronized用的是JVM实现（内核态） 性能的区别：synchronized（轻量级锁，偏向锁）经过优化后和ReentrantLock性能差不多 功能区别：ReentrantLock更加的灵活（细粒度高），synchronized更加便利 ReentrantLock（重入锁）独有的功能 可以指定是公平锁还是非公平锁 提供了一个Condition类，可以分组唤醒需要唤醒的线程 提供能够中断等待锁的线程的机制，lock.lockInterrupibly 12345678910111213141516171819202122232425262728293031323334//ReentrantLock及Condition使用@Slf4jpublic class ConditionExample &#123; public static void main(String[] args) &#123; ReentrantLock reentrantLock = new ReentrantLock(); Condition condition = reentrantLock.newCondition(); new Thread(() -&gt; &#123; try&#123; reentrantLock.lock(); log.info(&quot;wait signal&quot;);// 1 condition.await(); &#125;catch(InterruptedException e)&#123; e.printStackTrace(); &#125; log.info(&quot;get signal&quot;);// 4 reentrantLock.unlock(); &#125;).start(); new Thread(() -&gt; &#123; reentrantLock.lock(); log.info(&quot;get Lock&quot;);// 2 try&#123; Thread.sleep(3000); &#125;catch(InterruptedException e)&#123; e.printStackTrace(); &#125; condition.signalAll(); log.info(&quot;send signal ~&quot;);// 3 reentrantLock.unlock(); &#125;).start(); &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java线程类测试]]></title>
    <url>%2F2019%2F02%2F08%2FJava%E7%BA%BF%E7%A8%8B%E7%B1%BB%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[对java中的线程安全类及不安全的类进行测试~ 线程不安全类 StringBuilder -&gt; StringBuffer SimpleDateFormat -&gt; JodaTime 同步容器 ArrayList -&gt; Vector,Stack HashMap -&gt; HashTable(key, value不能为null) Collections.synchronizedXXX(List, Set, Map) 并发容器 ArrayList -&gt; CopyOnWriteArrayList HashSet,TreeSet -&gt; CopyOnWriteArraySet,ConcurrentSkipListSet HashMap,TreeMap -&gt; ConcurrentHashMap,ConcurrentSkipListMap 1234567891011121314151617181920212223242526272829303132333435//可以自行进行测试public class ConcurrencyTest &#123; //请求总数 public static int clientTotal = 5000; //同时并发执行的线程数 public static int threadTotal = 200; public static int count = 0; public static void main(String[] args) throws Exception &#123; ExecutorService executorService = Executors.newCachedThreadPool(); final Semaphore semaphore = new Semaphore(threadTotal); final CountDownLatch countDownLatch = new CountDownLatch(clientTotal); for (int i = 0; i &lt; clientTotal; i++) &#123; executorService.execute(() -&gt; &#123; try&#123; semaphore.acquire(); add(); semaphore.release(); &#125; catch (Exception e)&#123; log.error(&quot;exception&quot; , e); &#125; countDownLatch.countDown(); &#125;); &#125; countDownLatch.await(); executorService.shutdown(); log.info(&quot;count:&#123;&#125;&quot; , count); &#125; private static void add()&#123; count++; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java线程封闭]]></title>
    <url>%2F2019%2F02%2F08%2FJava%E7%BA%BF%E7%A8%8B%E5%B0%81%E9%97%AD%2F</url>
    <content type="text"><![CDATA[java是如何保持线程之间的不互相干扰？ 线程封闭 Ad-hoc线程封闭：程序控制，最糟糕，忽略 堆栈封闭：局部变量(利用不同的虚拟机栈副本存储) ThreadLocal线程封闭：特别好的封闭方法 1234567891011121314151617181920//ThreadLocal线程封闭public class RequestHolder &#123; private final static ThreadLocal&lt;Long&gt; requestHolder = new ThreadLocal&lt;Long&gt;(); public static void add(Long id)&#123; requestHolder.set(id); &#125; public static Long getId()&#123; //自动获取key(当前线程对象地址),找出value值返回 return requestHolder.get(); &#125; public static void remove()&#123; //数据会一直存到项目重启 //数据一定要移除，避免产生内存溢出(oom) requestHolder.remove(); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java不可变对象]]></title>
    <url>%2F2019%2F02%2F07%2Fjava%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[不可变对象定义，作用，使用方式详解。 不可变对象需要满足的条件： 对象创建以后其状态就不能修改 对象所有域都是final类型 对象时正确创建的（在对象创建期间，this引用没有逸出） 123456789101112131415161718192021222324252627282930313233//final关键字：类，方法，变量// 修饰类：不能被继承// 修饰方法：1.锁定方法不能被继承类修改（默认为private）;2.效率// 修饰变量：基本数据类型变量，引用类型变量@Slf4j@NotThreadSafepublic class ImmutableFinal &#123; private final static Integer a = 1; private final static String b = &quot;2&quot;; //guava private final static Map&lt;Integer, Integer&gt; map = Maps.newHashMap(); static &#123; map.put(1, 2); map.put(3, 4); map.put(5, 6); &#125; public static void main(String[] args) &#123; //a = 2; //b = &quot;3&quot;; //map = Maps.newHashMap(); //map引用不能修改，但是内部的值还是可以进行修改~ map.put(1, 3); log.info(&quot;&#123;&#125;&quot;,map.get(1)); &#125; //final参数不能修改 private void test(final int a)&#123; // a = 1 &#125;&#125; 1234567891011121314151617181920////利用基本的类库进行不可变Map对象的创建（内部参数也不可以改变）@Slf4j@ThreadSafepublic class ImmutableMap &#123; private static Map&lt;Integer, Integer&gt; map = Maps.newHashMap(); static&#123; map.put(1, 2); map.put(3, 4); map.put(5, 6); //java map = Collections.unmodifiableMap(map); &#125; public static void main(String[] args) &#123; //会报错哈~UnsupportedOperationException map.put(1, 3); log.info(&quot;&#123;&#125;&quot;, map.get(1)); &#125;&#125; 1234567891011121314151617//利用Guava的类库进行不可变Map对象的创建（内部参数也不可以改变）@ThreadSafepublic class ImmutableGuava &#123; private final static ImmutableList&lt;Integer&gt; list = ImmutableList.of(1, 2, 3); private final static ImmutableSet set = ImmutableSet.copyOf(list); private final static ImmutableMap&lt;Integer, Integer&gt; map = ImmutableMap.of(1, 2, 3, 4); private final static ImmutableMap&lt;Integer, Integer&gt; map2 = ImmutableMap.&lt;Integer, Integer&gt;builder() .put(1, 2).put(3, 4).put(5, 6).build(); public static void main(String[] args) &#123; System.out.println(map2.get(3)); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[jdk，jre你真的懂吗？]]></title>
    <url>%2F2019%2F02%2F07%2Fjdk%EF%BC%8Cjre%E4%BD%A0%E7%9C%9F%E7%9A%84%E6%87%82%E5%90%97%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[关于jdk和jre 大家肯定在安装JDK的时候会有选择是否安装单独的jre，一般都会一起安装，我也建议大家这样做。因为这样更能帮助大家弄清楚它们的区别：Jre 是java runtime environment, 是java程序的运行环境。既然是运行，当然要包含jvm，也就是大家熟悉的虚拟机啦，还有所有java类库的class文件，都在lib目录下打包成了jar。大家可以自己验证。至于在windows上的虚拟机是哪个文件呢？学过MFC的都知道什么是dll文件吧，那么大家看看jre/bin/client里面是不是有一个jvm.dll呢？那就是虚拟机。 Jdk 是java development kit，是java的开发工具包，里面包含了各种类库和工具。当然也包括了另外一个Jre. 那么为什么要包括另外一个Jre呢？而且jdk/jre/bin同时有client和server两个文件夹下都包含一个jvm.dll。说明是有两个虚拟机的。这一点不知道大家是否注意到了呢？ 相信大家都知道jdk的bin下有各种java程序需要用到的命令，与jre的bin目录最明显的区别就是jdk下才有javac，这一点很好理解，因为 jre只是一个运行环境而已。与开发无关，正因为如此，具备开发功能的jdk自己的jre下才会同时有client性质的jvm和server性质的 jvm， 而仅仅作为运行环境的jre下只需要client性质的jvm.dll就够了。 记得在环境变量path中设置jdk/bin路径麽？这应该是大家学习Java的第一步吧，老师会告诉大家不设置的话javac和java是用不了的。确实jdk/bin目录下包含了所有的命令。可是有没有人想过我们用的java命令并不是 jdk/bin目录下的而是jre/bin目录下的呢？不信可以做一个实验，大家可以把jdk/bin目录下的java.exe剪切到别的地方再运行 java程序，发现了什么？一切OK！ 那么有人会问了？我明明没有设置jre/bin目录到环境变量中啊？ 试想一下如果java为了提供给大多数人使用，他们是不需要jdk做开发的，只需要jre能让java程序跑起来就可以了，那么每个客户还需要手动去设置环境变量多麻烦啊？所以安装jre的时候安装程序自动帮你把jre的java.exe添加到了系统变量中，验证的方法很简单，大家看到了系统环境变量的 path最前面有“%SystemRoot%system32;%SystemRoot%;”这样的配置，那么再去Windows/system32下面去看看吧，发现了什么？有一个java.exe。 如果强行能够把jdk/bin挪到system32变量前面，当然也可以迫使使用jdk/jre里面的java，不过除非有必要，我不建议大家这么做。使用单独的jre跑java程序也算是客户环境下的一种测试。 ——————————————————————————————————————————— 通俗点来说： jdk是java的开发包，其中包括jre;jre仅仅是java的运行时环境；而JDK包括了同版本的JRE，此外还包括有编译器和其它工具 JDK是java开发工具包(java Development Kit)的缩写。它是一种构建在java平台上发布的应用程序、apple和组件的开发环境。JDK是一切java应用程序的基础，所有的java应用程序是构建在这个之上的。它是一组API，也可以说是一些java Class。要成为一个Java程序员，JDK是必不可少的最基本的工具。 JRE是Java运行环境(Java Runtime Enviroment)的缩写。它基本上就和Java虚拟机是同一个概念。一般来说，在谈论一个具体的产品的时候，可以说“JRE”,而说到理论中的一个模型的时候，我们常用的是“Java虚拟机”。要使用Java程序，JRE是必不可少的环境。 如果机子里安装了多个版本的jdk，如下： BEA Weblogic Server 7.0 自带一套 JDK1.3.1_02下载了一套最新的JDK1.4.1_02JBuilder9自带一套JKD1.4.1_02Oracle8.1.7自带一套JRE1.1.7Ration Rose自带一套JDK1.3DreamWeaver自带一套JDK1.3 6套JRE，每套JRE都被各自安装到不同的目录，不会互相影响。当在控制台执行java.exe，操作系统寻找JRE的方式如下： 先找当前目录下有没有JRE再找父目录下有没有JRE接着在PATH路径中找JRE（一般运行时从path中查找，按照path设置前后顺序，以前面为准）注册表HKEY_LOCAL_MACHINE\SOFTWARE\JavaSoft\Java Runtime Environment\ 查看CurrentVersion的键值指向哪个JRE（一般XP下是这个：C:\Program Files\Java\jre6） 最常用的是在PATH路径中找JRE，一般情况下，自己的程序运行之前都会先在批处理文件里面临时设置PATH，把自己用的JRE放到PATH路径最前面，所以肯定会运行自己带的JRE，不会造成版本混乱。 ——————————————————————————————————————————————JDK就是Java Development Kit.简单的说JDK是面向开发人员使用的SDK，它提供了Java的开发环境和运行环境。SDK是Software Development Kit 一般指软件开发包，可以包括函数库、编译程序等。 JRE是Java Runtime Enviroment是指Java的运行环境，是面向Java程序的使用者，而不是开发者。 如果安装了JDK，会发同你的电脑有两套JRE，一套位于 \jre 另外一套位于 C:\Program Files\Java\jre1.5.0_15 目录下，后面这套比前面那套少了Server端的Java虚拟机，不过直接将前面那套的Server端Java虚拟机复制过来就行了。而且在安装JDK可以选择是否安装这个位于 C:\Program Files\Java 目录下的JRE。如果你只安装JRE，而不是JDK，那么只会在 C:\Program Files\Java 目录下安装唯一的一套JRE。 JRE的地位就象一台PC机一样，我们写好的Win32应用程序需要操作系统帮我们运行，同样的，我们编写的Java程序也必须要JRE才能运行。所以当你装完JDK后，如果分别在硬盘上的两个不同地方安装了两套JRE，那么你可以想象你的电脑有两台虚拟的Java PC机，都具有运行Java程序的功能。所以我们可以说，只要你的电脑安装了JRE，就可以正确运行Java应用程序。 为什么Sun要让JDK安装两套相同的JRE？ 这是因为JDK里面有很多用Java所编写的开发工具（如javac.exe、jar.exe等），而且都放置在 \lib\tools.jar 里。从下面例子可以看出，先将tools.jar改名为tools1.jar，然后运行javac.exe，显示如下结果： Exception in thread “main” java.lang.NoClassDefFoundError: com/sun/tools/javac /Main 这个意思是说，你输入javac.exe与输入 java -cp c:\jdk\lib\tools.jar com.sun.tools.javac.Main 是一样的，会得到相同的结果。从这里我们可以证明javac.exe只是一个包装器（Wrapper），而制作的目的是为了让开发者免于输入太长的指命。而且可以发现\lib目录下的程序都很小，不大于2 9K，从这里我们可以得出一个结论。就是JDK里的工具几乎是用Java所编写，所以也是Java应用程序，因此要使用JDK所附的工具来开发Java程序，也必须要自行附一套JRE才行，所以位于C:\Program Files\Java目录下的那套JRE就是用来运行一般Java程序用的。 如果一台电脑安装两套以上的JRE，谁来决定呢？ 这个重大任务就落在java.exe身上。Java.exe的工作就是找到合适的JRE来运行Java程序。 Java.exe依照底下的顺序来查找JRE：自己的目录下有没有JRE；父目录有没有JRE；查询注册表： [HKEY_LOCAL_MACHINE\SOFTWARE\JavaSoft\Java Runtime Environment] 所以java.exe的运行结果与你的电脑里面哪个JRE被执行有很大的关系。 ADD：（小小结） JVM – java virtual machineJVM就是我们常说的java虚拟机，它是整个java实现跨平台的最核心的部分，所有的java程序会首先被编译为.class的类文件，这种类文件可以在虚拟机上执行，也就是说class并不直接与机器的操作系统相对应，而是经过虚拟机间接与操作系统交互，由虚拟机将程序解释给本地系统执行。 JRE – java runtime environmentJRE是指java运行环境。光有JVM还不能成class的执行，因为在解释class的时候JVM需要调用解释所需要的类库lib。在JDK的安装目录里你可以找到jre目录，里面有两个文件夹bin和lib,在这里可以认为bin里的就是jvm，lib中则是jvm工作所需要的类库，而jvm和 lib和起来就称为jre。所以，在你写完java程序编译成.class之后，你可以把这个.class文件和jre一起打包发给朋友，这样你的朋友就可以运行你写程序了。（jre里有运行.class的java.exe） JDK – java development kitJDK是java开发工具包，基本上每个学java的人都会先在机器上装一个JDK，那他都包含哪几部分呢？让我们看一下JDK的安装目录。在目录下面有六个文件夹、一个src类库源码压缩包、和其他几个声明文件。其中，真正在运行java时起作用的是以下四个文件夹：bin、include、lib、 jre。现在我们可以看出这样一个关系，JDK包含JRE，而JRE包含JVM。bin:最主要的是编译器(javac.exe)include:java和JVM交互用的头文件lib：类库jre:java运行环境（注意：这里的bin、lib文件夹和jre里的bin、lib是不同的）总的来说JDK是用于java程序的开发,而jre则是只能运行class而没有编译的功能。 eclipse、idea等其他IDE有自己的编译器而不是用JDK bin目录中自带的，所以在安装时你会发现他们只要求你选中jre路径就ok了。 ITeye原文]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[中国式的人情社会]]></title>
    <url>%2F2019%2F02%2F06%2F%E4%B8%AD%E5%9B%BD%E5%BC%8F%E7%9A%84%E4%BA%BA%E6%83%85%E7%A4%BE%E4%BC%9A%2F</url>
    <content type="text"><![CDATA[最近想到的一些东西，随便写写。 不知道为什么我这个人一直不喜欢麻烦别人，从北京辞职回来以后，我说要去杭州，就各种亲戚和我说“那谁谁也是在杭州做事，可以帮你介绍工作。。可以住他家里，又谁谁在那里买了房子”。我知道大家都是好心，可是我就想靠自己做出一番事情也不管成功或者失败。。。最好谁也别搭理我~（ps:感觉很讨厌这样的环境，好奇怪） （没有结果，也没有结论…..就是想说说记录下，查查资料后再补上） 还有哦~一个人经济及社会地位决定了你社交圈，当你突破当前的社交圈向上走的时候，你会感觉到自身的不足，也会自卑，而你需要做的就是努力的融入进去然后继续向上走~ 为自己加油吧~ 2019年 需要做的事情（社交能力的提升，健身，本科文凭，工作）]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[如何安全发布对象？]]></title>
    <url>%2F2019%2F02%2F05%2F%E5%A6%82%E4%BD%95%E5%AE%89%E5%85%A8%E5%8F%91%E5%B8%83%E5%AF%B9%E8%B1%A1%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[安全发布对象详解~ 在静态初始化函数中初始化一个对象引用 将对象的引用保存到volatile类型域或者AtomicReference对象中 将对象的引用保存到某个正确构造对象的final类型域中 将对象的引用保存到一个由锁保护的域中 例子：1234567891011121314151617181920212223242526272829/** * 懒汉模式 -》 双重同步锁单例模式 * 单例实例在第一次使用时进行创建 */@ThreadSafepublic class LazySingleton &#123; // 私有构造函数 private LazySingleton() &#123;&#125; // 1、memory = allocate() 分配对象的内存空间 // 2、ctorInstance() 初始化对象 // 3、instance = memory 设置instance指向刚分配的内存 // 单例对象 volatile + 双重检测机制 -&gt; 禁止指令重排 private volatile static LazySingleton instance = null; // 静态的工厂方法 public static LazySingleton getInstance() &#123; if (instance == null) &#123; // 双重检测机制 synchronized (LazySingleton.class) &#123; // 同步锁 if (instance == null) &#123; instance = new LazySingleton(); &#125; &#125; &#125; return instance; &#125;&#125; 12345678910111213141516171819202122232425/** * 饿汉模式 * 单例实例在类装载时进行创建 */@ThreadSafepublic class HungrySingleton &#123; // 私有构造函数 private HungrySingleton() &#123;&#125; // 单例对象 private static HungrySingleton instance = new HungrySingleton(); /* private static SingletonExample6 instance = null; static &#123; instance = new SingletonExample6(); &#125;*/ // 静态的工厂方法 public static HungrySingleton getInstance() &#123; return instance; &#125;&#125; 1234567891011121314151617181920212223242526272829/** * 枚举模式：最安全 */@ThreadSafe@Recommendpublic class EnumSingleton &#123; // 私有构造函数 private EnumSingleton() &#123;&#125; public static EnumSingleton getInstance() &#123; return Singleton.INSTANCE.getInstance(); &#125; private enum Singleton &#123; INSTANCE; private EnumSingleton singleton; // JVM保证这个方法绝对只调用一次 Singleton() &#123; singleton = new EnumSingleton(); &#125; public EnumSingleton getInstance() &#123; return singleton; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Concurrency</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[发布对象线程安全问题]]></title>
    <url>%2F2019%2F02%2F05%2F%E5%8F%91%E5%B8%83%E5%AF%B9%E8%B1%A1%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[发布对象，对象逸出并发问题详解 发布对象（NotThreadSafe）使一个对象能够被当前范围之外的代码所使用。 12345678910111213141516@Slf4j@NotThreadSafepublic class UnsafePublish &#123; private String[] states = &#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;; public String[] getStates()&#123; return states; &#125; public static void main(String[] args) &#123; UnsafePublish unsafePublish = new UnsafePublish(); log.info(&quot;&#123;&#125;&quot;, Arrays.toString(unsafePublish.getStates())); unsafePublish.getStates()[0] = &quot;d&quot;; log.info(&quot;&#123;&#125;&quot;, Arrays.toString(unsafePublish.getStates())); &#125;&#125; 对象逸出（NotThreadSafe）一种错误的发布。当一个对象还没有构建完成时，就使它被其他线程所见。1234567891011121314151617181920@NotThreadSafe@NotRecommendpublic class Escape &#123; private int thisCanBeEscape = 0; public Escape ()&#123; new InnerClass(); &#125; private class InnerClass &#123; public InnerClass()&#123; //获取的数据是未创建完的对象数据 log.info(&quot;&#123;&#125;&quot;, Escape.this.thisCanBeEscape); &#125; &#125; public static void main(String[] args) &#123; new Escape(); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Concurrency</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新年快乐]]></title>
    <url>%2F2019%2F02%2F05%2F%E6%96%B0%E5%B9%B4%E5%BF%AB%E4%B9%90%2F</url>
    <content type="text"><![CDATA[新年深夜更博~北京四年反省总结 在过去一年中，发生了很多大事，家人的离世，房贷的压力，互联网环境的变更，辞职决定去杭州发展，身上的压力是越来越重，我只有不停的学习，不停的进步才能减轻担忧。 我不是本科，也不是本专业，却走上了程序猿这条路，通过培训获取了当一名程序猿的资格，进了第一家公司不停加班，学习，才让我跟上工作步伐。 很恨自己中间有一年安逸的日子没有学习，只会玩手机，导致技术的滞后。安逸真的会使人堕落，而我本就没有这样的资格堕落。 2019新的一年到了，深刻的反省。 三月份到杭州，我会做一个学习计划，到时候再发博~ 在最后祝大家新年快乐，身体健康，合家团员。 best wishes:努力的去拥抱生活，让自己变得更好，不要辜负自己的青春，在最灿烂的年纪，绽放最耀眼的光芒。]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HashMap？面试？我是谁？我在哪]]></title>
    <url>%2F2019%2F02%2F04%2FHashMap%EF%BC%9F%E9%9D%A2%E8%AF%95%EF%BC%9F%E6%88%91%E6%98%AF%E8%B0%81%EF%BC%9F%E6%88%91%E5%9C%A8%E5%93%AA%2F</url>
    <content type="text"><![CDATA[面试经常被问到做个笔记，emmmmm 为什么用HashMap？ HashMap 是一个散列桶（数组和链表），它存储的内容是键值对 key-value 映射 HashMap 采用了数组和链表的数据结构，能在查询和修改方便继承了数组的线性查找和链表的寻址修改 HashMap 是非 synchronized，所以 HashMap 很快 HashMap 可以接受 null 键和值，而 Hashtable 则不能（原因就是 equlas() 方法需要对象，因为 HashMap 是后出的 API 经过处理才可以） HashMap 的工作原理是什么？HashMap 是基于 hashing 的原理 我们使用 put(key, value) 存储对象到 HashMap 中，使用 get(key) 从 HashMap 中获取对象。当我们给 put() 方法传递键和值时，我们先对键调用 hashCode() 方法，计算并返回的 hashCode 是用于找到 Map 数组的 bucket 位置来储存 Node 对象。 这里关键点在于指出，HashMap 是在 bucket 中储存键对象和值对象，作为Map.Node。 以下是 HashMap 初始化简化的模拟数据结构：1234567Node[] table = new Node[16]; // 散列桶初始化，tableclass Node &#123; hash; //hash值 key; //键 value; //值 node next; //用于指向链表的下一层（产生冲突，用拉链法）&#125; 以下是具体的 put 过程（JDK1.8） 对 Key 求 Hash 值，然后再计算下标 如果没有碰撞，直接放入桶中（碰撞的意思是计算得到的 Hash 值相同，需要放到同一个 bucket 中） 如果碰撞了，以链表的方式链接到后面 如果链表长度超过阀值（TREEIFY THRESHOLD==8），就把链表转成红黑树，链表长度低于6，就把红黑树转回链表 如果节点已经存在就替换旧值 如果桶满了（容量16*加载因子0.75），就需要 resize（扩容2倍后重排）]]></content>
  </entry>
  <entry>
    <title><![CDATA[Apache Bench]]></title>
    <url>%2F2019%2F02%2F03%2FApacheBench%2F</url>
    <content type="text"><![CDATA[Apache Bench简介ApacheBench 是 Apache 服务器自带的一个web压力测试工具，简称ab。ab又是一个命令行工具，对发起负载的本机要求很低，根据ab命令可以创建很多的并发访问线程，模拟多个访问者同时对某一URL地址进行访问，因此可以用来测试目标服务器的负载压力。总的来说ab工具小巧简单，上手学习较快，可以提供需要的基本性能指标，但是没有图形化结果，不能监控。 Apache Bench安装首先需要安装Apache服务器，下载地址：https://www.apachelounge.com/download/ Apache Bench使用了解参数123456789101112131415161718192021222324252627282930313233参数说明：格式：ab [options] [http://]hostname[:port]/path-n requests Number of requests to perform //本次测试发起的总请求数-c concurrency Number of multiple requests to make //一次产生的请求数（或并发数）-t timelimit Seconds to max. wait for responses //测试所进行的最大秒数，默认没有时间限制。-r Don&apos;t exit on socket receive errors. // 抛出异常继续执行测试任务 -p postfile File containing data to POST //包含了需要POST的数据的文件，文件格式如“p1=1&amp;p2=2”.使用方法是 -p 111.txt-T content-type Content-type header for POSTing//POST数据所使用的Content-type头信息，如 -T “application/x-www-form-urlencoded” 。 （配合-p）-v verbosity How much troubleshooting info to print//设置显示信息的详细程度 – 4或更大值会显示头信息， 3或更大值可以显示响应代码(404, 200等), 2或更大值可以显示警告和其他信息。 -V 显示版本号并退出。-C attribute Add cookie, eg. -C “c1=1234,c2=2,c3=3” (repeatable)//-C cookie-name=value 对请求附加一个Cookie:行。 其典型形式是name=value的一个参数对。此参数可以重复，用逗号分割。提示：可以借助session实现原理传递 JSESSIONID参数， 实现保持会话的功能，如-C ” c1=1234,c2=2,c3=3, JSESSIONID=FF056CD16DA9D71CB131C1D56F0319F8″ 。-w Print out results in HTML tables //以HTML表的格式输出结果。默认时，它是白色背景的两列宽度的一张表。-i Use HEAD instead of GET-x attributes String to insert as table attributes-y attributes String to insert as tr attributes-z attributes String to insert as td or th attributes-H attribute Add Arbitrary header line, eg. ‘Accept-Encoding: gzip’ Inserted after all normal header lines. (repeatable)-A attribute Add Basic WWW Authentication, the attributesare a colon separated username and password.-P attribute Add Basic Proxy Authentication, the attributes are a colon separated username and password.-X proxy:port Proxyserver and port number to use-V Print version number and exit-k Use HTTP KeepAlive feature-d Do not show percentiles served table.-S Do not show confidence estimators and warnings.-g filename Output collected data to gnuplot format file.-e filename Output CSV file with percentages served-h Display usage information (this message) 参数倒是挺多的不过，经常用的就是 -n -c ,记得配置path环境变量哈，不然要去bin目录下执行 例如:]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开篇博客]]></title>
    <url>%2F2019%2F02%2F03%2F%E5%BC%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[开个博客，写写东西。很早之间我就想做个博客，写一些技术文档，随笔，却一直没有沉下心来做这件事。 最近过年才有时间，大概花了1天时间搭建Hexo比想象中的简单多了，之前一直觉得挺麻烦的，也许是因为知识的积累和想拥有一个自己博客的迫切希望才促使我不断的去突破困难搭建完善。 搭建博客虽然简单，但是持之以恒的去写文章就很难了。我现在开篇立个flag，一周至少更新一篇技术博客，大家监督~ 我一直认为啊~技术宅真的是可以拯救世界的，大家一起加油吧！]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
</search>
