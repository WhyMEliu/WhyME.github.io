<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>PengˇBlog</title>
  
  <subtitle>学习，生活</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://liupeng.world/"/>
  <updated>2019-09-19T09:23:11.812Z</updated>
  <id>http://liupeng.world/</id>
  
  <author>
    <name>peng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Webpack入门</title>
    <link href="http://liupeng.world/2019/09/19/webpack%E5%85%A5%E9%97%A8/"/>
    <id>http://liupeng.world/2019/09/19/webpack入门/</id>
    <published>2019-09-19T09:11:00.000Z</published>
    <updated>2019-09-19T09:23:11.812Z</updated>
    
    <content type="html"><![CDATA[<p>简单了解~环境搭建，安装及配置<br><a id="more"></a><br><a href="https://www.webpackjs.com/concepts/" target="_blank" rel="noopener">中文文档</a>  <a href="https://webpack.js.org/concepts/" target="_blank" rel="noopener">英文文档</a></p><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><p>主要用于模块打包工具（ES Module，CommonJS，CMD，ADM）</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><blockquote><p><a href="https://nodejs.org/en/" target="_blank" rel="noopener">nodejs</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><blockquote><p>webpack</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>前提</span><br><span class="line"><span class="meta">$</span> mkdir webpack-demo</span><br><span class="line"><span class="meta">$</span> cd webpack-demo</span><br><span class="line"><span class="meta">$</span> npm init</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>全局安装</span><br><span class="line"><span class="meta">$</span> npm install webpack webpack-cli -g</span><br><span class="line"><span class="meta">$</span> npm uninstall webpack webpack-cli -g</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>项目中安装</span><br><span class="line">~/Desktop/webpack-demo</span><br><span class="line"><span class="meta">$</span> npm install webpack webpack-cli -D</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>项目中不同版本安装</span><br><span class="line">~/Desktop/webpack-demo2</span><br><span class="line"><span class="meta">$</span> npm info webpack</span><br><span class="line"><span class="meta">$</span> npm install webpack@3.10.0 webpack-cli -D</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>检查项目安装webpack是否成功</span><br><span class="line">~/Desktop/webpack-demo2</span><br><span class="line"><span class="meta">$</span> npx webpack -v</span><br></pre></td></tr></table></figure><p>package.json文件修改</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"webpack-demo"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"private"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">  <span class="attr">"bundle"</span>: <span class="string">"webpack"</span>//npm run bundle</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="string">"author"</span>: <span class="string">"liupeng"</span>,</span><br><span class="line">  <span class="attr">"license"</span>: <span class="string">"ISC"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>webpack.config.js          //文件名默认就行，最好不要改</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports =&#123;</span><br><span class="line">    mode: <span class="string">'production'</span>,<span class="comment">//模式配置（pro,dev）正式环境压缩</span></span><br><span class="line">entry: &#123;<span class="comment">//打包入口</span></span><br><span class="line">     main: <span class="string">'./src/index.js'</span>   </span><br><span class="line">    &#125;,</span><br><span class="line">output: &#123;</span><br><span class="line">filename: <span class="string">'bundle.js'</span>,    <span class="comment">//打包输出名</span></span><br><span class="line">path: path.resolve(__dirname, <span class="string">'dist'</span>)<span class="comment">//打包输出地址</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行打包"><a href="#运行打包" class="headerlink" title="运行打包"></a>运行打包</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>指定配置文件打包(webpackcongfig.js)</span><br><span class="line">npx webpack --config webpackcongfig.js</span><br><span class="line"><span class="meta">#</span>全局安装打包</span><br><span class="line">webpack index.js</span><br><span class="line"><span class="meta">#</span>项目安装打包</span><br><span class="line">npx webpack index.js</span><br><span class="line"><span class="meta">#</span>配置文件json:scripts打包</span><br><span class="line">npm run bundle</span><br></pre></td></tr></table></figure><h4 id="打包的一些日志输出知识"><a href="#打包的一些日志输出知识" class="headerlink" title="打包的一些日志输出知识"></a>打包的一些日志输出知识</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Hash: 打包的唯一标识</span><br><span class="line">Version: webpack版本号</span><br><span class="line">Time: 打包时间</span><br><span class="line">Asset: 打包的文件名</span><br><span class="line">Size: 包的大小</span><br><span class="line">Chunk: 项目中所有打包的文件id</span><br><span class="line">Chunk: 打包生成的文件入口名</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单了解~环境搭建，安装及配置&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://liupeng.world/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="webpack" scheme="http://liupeng.world/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>BIO,NIO,AIO写法记录</title>
    <link href="http://liupeng.world/2019/02/24/BIO-NIO-AIO%E5%86%99%E6%B3%95%E8%AE%B0%E5%BD%95/"/>
    <id>http://liupeng.world/2019/02/24/BIO-NIO-AIO写法记录/</id>
    <published>2019-02-24T10:21:00.000Z</published>
    <updated>2019-02-24T11:55:57.559Z</updated>
    
    <content type="html"><![CDATA[<p>写法详解~<br><a id="more"></a></p><h3 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">public class BIOPlainEchoServer &#123;</span><br><span class="line">    public void serve(int port) throws IOException &#123;</span><br><span class="line">        //将ServerSocket绑定到指定的端口里</span><br><span class="line">        final ServerSocket socket = new ServerSocket(port);</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            //阻塞直到收到新的客户端连接</span><br><span class="line">            final Socket clientSocket = socket.accept();</span><br><span class="line">            System.out.println(&quot;Accepted connection from &quot; + clientSocket);</span><br><span class="line">            //创建一个子线程去处理客户端的请求</span><br><span class="line">            new Thread(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    try (BufferedReader reader = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()))) &#123;</span><br><span class="line">                        PrintWriter writer = new PrintWriter(clientSocket.getOutputStream(), true);</span><br><span class="line">                        //从客户端读取数据并原封不动回写回去</span><br><span class="line">                        while (true) &#123;</span><br><span class="line">                            writer.println(reader.readLine());</span><br><span class="line">                            writer.flush();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; catch (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void improvedServe(int port) throws IOException &#123;</span><br><span class="line">        //将ServerSocket绑定到指定的端口里</span><br><span class="line">        final ServerSocket socket = new ServerSocket(port);</span><br><span class="line">        //创建一个线程池</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(6);</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            //阻塞直到收到新的客户端连接</span><br><span class="line">            final Socket clientSocket = socket.accept();</span><br><span class="line">            System.out.println(&quot;Accepted connection from &quot; + clientSocket);</span><br><span class="line">            //将请求提交给线程池去执行</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                try (BufferedReader reader = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()))) &#123;</span><br><span class="line">                    PrintWriter writer = new PrintWriter(clientSocket.getOutputStream(),true);</span><br><span class="line">                    //从客户端读取数据并原封不动回写回去</span><br><span class="line">                    while (true) &#123;</span><br><span class="line">                        writer.println(reader.readLine());</span><br><span class="line">                        writer.flush();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">public class NIOPlainEchoServer &#123;</span><br><span class="line">    public void serve(int port) throws IOException &#123;</span><br><span class="line">        System.out.println(&quot;Listening for connections on port &quot; + port);</span><br><span class="line">        ServerSocketChannel serverChannel = ServerSocketChannel.open();</span><br><span class="line">        ServerSocket ss = serverChannel.socket();</span><br><span class="line">        InetSocketAddress address = new InetSocketAddress(port);</span><br><span class="line">        //将ServerSocket绑定到指定的端口里</span><br><span class="line">        ss.bind(address);</span><br><span class="line">        serverChannel.configureBlocking(false);</span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        //将channel注册到Selector里，并说明让Selector关注的点，这里是关注建立连接这个事件</span><br><span class="line">        serverChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                //阻塞等待就绪的Channel，即没有与客户端建立连接前就一直轮询</span><br><span class="line">                selector.select();</span><br><span class="line">            &#125; catch (IOException ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">                //代码省略的部分是结合业务，正确处理异常的逻辑</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            //获取到Selector里所有就绪的SelectedKey实例,每将一个channel注册到一个selector就会产生一个SelectedKey</span><br><span class="line">            Set&lt;SelectionKey&gt; readyKeys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = readyKeys.iterator();</span><br><span class="line">            while (iterator.hasNext()) &#123;</span><br><span class="line">                SelectionKey key = (SelectionKey) iterator.next();</span><br><span class="line">                //将就绪的SelectedKey从Selector中移除，因为马上就要去处理它，防止重复执行</span><br><span class="line">                iterator.remove();</span><br><span class="line">                try &#123;</span><br><span class="line">                    //若SelectedKey处于Acceptable状态</span><br><span class="line">                    if (key.isAcceptable()) &#123;</span><br><span class="line">                        ServerSocketChannel server = (ServerSocketChannel) key.channel();</span><br><span class="line">                        //接受客户端的连接</span><br><span class="line">                        SocketChannel client = server.accept();</span><br><span class="line">                        System.out.println(&quot;Accepted connection from &quot; + client);</span><br><span class="line">                        client.configureBlocking(false);</span><br><span class="line">                        //像selector注册socketchannel，主要关注读写，并传入一个ByteBuffer实例供读写缓存</span><br><span class="line">                        client.register(selector, SelectionKey.OP_WRITE | SelectionKey.OP_READ, ByteBuffer.allocate(100));</span><br><span class="line">                    &#125;</span><br><span class="line">                    //若SelectedKey处于可读状态</span><br><span class="line">                    if (key.isReadable()) &#123;</span><br><span class="line">                        SocketChannel client = (SocketChannel) key.channel();</span><br><span class="line">                        ByteBuffer output = (ByteBuffer) key.attachment();</span><br><span class="line">                        //从channel里读取数据存入到ByteBuffer里面</span><br><span class="line">                        client.read(output);</span><br><span class="line">                    &#125;</span><br><span class="line">                    //若SelectedKey处于可写状态</span><br><span class="line">                    if (key.isWritable()) &#123;</span><br><span class="line">                        SocketChannel client = (SocketChannel) key.channel();</span><br><span class="line">                        ByteBuffer output = (ByteBuffer) key.attachment();</span><br><span class="line">                        output.flip();</span><br><span class="line">                        //将ByteBuffer里的数据写入到channel里</span><br><span class="line">                        client.write(output);</span><br><span class="line">                        output.compact();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (IOException ex) &#123;</span><br><span class="line">                    key.cancel();</span><br><span class="line">                    try &#123;</span><br><span class="line">                        key.channel().close();</span><br><span class="line">                    &#125; catch (IOException cex) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">public class AIOPlainEchoServer &#123;</span><br><span class="line">    public void serve(int port) throws IOException &#123;</span><br><span class="line">        System.out.println(&quot;Listening for connections on port &quot; + port);</span><br><span class="line">        final AsynchronousServerSocketChannel serverChannel = AsynchronousServerSocketChannel.open();</span><br><span class="line">        InetSocketAddress address = new InetSocketAddress(port);</span><br><span class="line">        // 将ServerSocket绑定到指定的端口里</span><br><span class="line">        serverChannel.bind(address);</span><br><span class="line">        final CountDownLatch latch = new CountDownLatch(1);</span><br><span class="line">        // 开始接收新的客户端请求. 一旦一个客户端请求被接收， CompletionHandler 就会被调用.</span><br><span class="line">        serverChannel.accept(null, new CompletionHandler&lt;AsynchronousSocketChannel, Object&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void completed(final AsynchronousSocketChannel channel, Object attachment) &#123;</span><br><span class="line">                // 一旦完成处理，再次接收新的客户端请求</span><br><span class="line">                serverChannel.accept(null, this);</span><br><span class="line">                ByteBuffer buffer = ByteBuffer.allocate(100);</span><br><span class="line">                // 在channel里植入一个读操作EchoCompletionHandler，一旦buffer有数据写入，EchoCompletionHandler 便会被唤醒</span><br><span class="line">                channel.read(buffer, buffer, new EchoCompletionHandler(channel));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void failed(Throwable throwable, Object attachment) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    // 若遇到异常，关闭channel</span><br><span class="line">                    serverChannel.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    // ingnore on close</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    latch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        try &#123;</span><br><span class="line">            latch.await();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private final class EchoCompletionHandler implements CompletionHandler&lt;Integer, ByteBuffer&gt; &#123;</span><br><span class="line">        private final AsynchronousSocketChannel channel;</span><br><span class="line"></span><br><span class="line">        EchoCompletionHandler(AsynchronousSocketChannel channel) &#123;</span><br><span class="line">            this.channel = channel;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void completed(Integer result, ByteBuffer buffer) &#123;</span><br><span class="line">            buffer.flip();</span><br><span class="line">            // 在channel里植入一个读操作CompletionHandler，一旦channel有数据写入，CompletionHandler 便会被唤醒</span><br><span class="line">            channel.write(buffer, buffer, new CompletionHandler&lt;Integer, ByteBuffer&gt;() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void completed(Integer result, ByteBuffer buffer) &#123;</span><br><span class="line">                    if (buffer.hasRemaining()) &#123;</span><br><span class="line">                        // 如果buffer里还有内容，则再次触发写入操作将buffer里的内容写入channel</span><br><span class="line">                        channel.write(buffer, buffer, this);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        buffer.compact();</span><br><span class="line">                        // 如果channel里还有内容需要读入到buffer里，则再次触发写入操作将channel里的内容读入buffer</span><br><span class="line">                        channel.read(buffer, buffer, EchoCompletionHandler.this);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                @Override</span><br><span class="line">                public void failed(Throwable exc, ByteBuffer attachment) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        channel.close();</span><br><span class="line">                    &#125; catch (IOException e) &#123;</span><br><span class="line">                        // ingnore on close</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void failed(Throwable exc, ByteBuffer attachment) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                channel.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                // ingnore on close</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写法详解~&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://liupeng.world/categories/Java/"/>
    
    
      <category term="IO" scheme="http://liupeng.world/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用命令</title>
    <link href="http://liupeng.world/2019/02/17/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://liupeng.world/2019/02/17/Linux常用命令/</id>
    <published>2019-02-17T02:07:00.000Z</published>
    <updated>2019-02-17T09:40:12.031Z</updated>
    
    <content type="html"><![CDATA[<p>就是做了一些整理~常用系统工作命令，系统状态检测命令，工作目录切换命令，文本文件编辑命令，文件目录管理命令，打包压缩与搜索命令~<br><a id="more"></a></p><h3 id="常用系统工作命令"><a href="#常用系统工作命令" class="headerlink" title="常用系统工作命令"></a>常用系统工作命令</h3><h4 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h4><p>echo 命令用于在终端输出字符串或变量提取后的值，格式为“echo [字符串 | $变量]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]# echo Linuxprobe.Com</span><br><span class="line">Linuxprobe.Com</span><br><span class="line">[root@linuxprobe ~]# echo $SHELL</span><br><span class="line">/bin/bash</span><br></pre></td></tr></table></figure><h4 id="date"><a href="#date" class="headerlink" title="date"></a>date</h4><p>date 命令用于显示及设置系统的时间或日期，格式为“date [选项] [+指定的格式]”。</p><table><thead><tr><th>参数</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td>%t</td><td style="text-align:center">跳格[Tab 键]</td></tr><tr><td>%H</td><td style="text-align:center">小时（00～23)</td></tr><tr><td>%I</td><td style="text-align:center">小时（00～12）</td></tr><tr><td>%M</td><td style="text-align:center">分钟（00～59）</td></tr><tr><td>%S</td><td style="text-align:center">秒（00～59）</td></tr><tr><td>%j</td><td style="text-align:center">今年中的第几天</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ]# date</span><br><span class="line">Mon Aug 24 16:11:23 CST 20</span><br><span class="line">[root@linuxprobe ~]# date &quot;+%Y-%m-%d %H:%M:%S&quot;</span><br><span class="line">2017-08-24 16:29:12</span><br><span class="line">[root@linuxprobe ~]# date -s &quot;20170901 8:30:00&quot;</span><br><span class="line">Fri Sep 1 08:30:00 CST 2017</span><br><span class="line">[root@linuxprobe ~]# date</span><br><span class="line">Fri Sep 1 08:30:01 CST 2017</span><br><span class="line">[root@linuxprobe ~]# date &quot;+%j&quot;</span><br><span class="line">244</span><br></pre></td></tr></table></figure><h4 id="reboot"><a href="#reboot" class="headerlink" title="reboot"></a>reboot</h4><p>reboot 命令用于重启系统其格式为 rebo<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ]# rebo</span><br></pre></td></tr></table></figure></p><h4 id="poweroff"><a href="#poweroff" class="headerlink" title="poweroff"></a>poweroff</h4><p>poweroff 命令用于关闭系统，其格式为 powerof</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]# powero</span><br></pre></td></tr></table></figure><h4 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h4><p>wget 命令用于在终端中下载网络文件，格式为“wget [参数] 下载地址”</p><table><thead><tr><th>参数</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td>-b</td><td style="text-align:center">后台下载模式</td></tr><tr><td>-P</td><td style="text-align:center">下载到指定目录</td></tr><tr><td>-t</td><td style="text-align:center">最大尝试次数</td></tr><tr><td>-c</td><td style="text-align:center">断点续传</td></tr><tr><td>-p</td><td style="text-align:center">下载页面内所有资源，包括图片、视频等</td></tr><tr><td>-r</td><td style="text-align:center">递归下载</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]# wget http://www.linuxprobe.com/docs/LinuxProbe.pdf</span><br></pre></td></tr></table></figure><h4 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h4><p>ps 命令用于查看系统中的进程状态，格式为“ps [参数]”。</p><table><thead><tr><th>参数</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td>-a</td><td style="text-align:center">显示所有进程（包括其他用户的进程）</td></tr><tr><td>-u</td><td style="text-align:center">用户以及其他详细信息</td></tr><tr><td>-x</td><td style="text-align:center">显示没有控制终端的进程</td></tr></tbody></table><p>➢R(运行)：进程正在运行或在运行队列中等待。</p><p>➢S(中断)：进程处于休眠中，当某个条件形成后或者接收到信号时，则脱离该<br>状态。</p><p>➢D(不可中断)：进程不响应系统异步信号，即便用 kill 命令也不能将其中断。</p><p>➢Z(僵死)：进程已经终止，但进程描述符依然存在, 直到父进程调用 wait4()系统函数后将进程释。</p><p>➢ T(停止)：进程收到停止信号后停止。</p><p>表 2-7 进程(ps -aux)<br><img src="/images/ps-aux.png" alt=""></p><h4 id="top"><a href="#top" class="headerlink" title="top"></a>top</h4><p>top 命令用于动态地监视进程活动与系统负载等信息，其格式为 top。</p><p><img src="/images/top.jpg" alt=""><br>➢ 第 1 行：系统时间、运行时间、登录终端数、系统负载（三个数值分别为 1 分钟、5<br>分钟、15 分钟内的平均值，数值越小意味着负载越低）。</p><p>➢ 第 2 行：进程总数、运行中的进程数、睡眠中的进程数、停止的进程数、僵死的进程<br>数。</p><p>➢ 第 3 行：用户占用资源百分比、系统内核占用资源百分比、改变过优先级的进程资源<br>百分比、空闲的资源百分比等</p><p>➢ 第 4 行：物理内存总量、内存使用量、内存空闲量、作为内核缓存的内存量。</p><p>➢ 第 5 行：虚拟内存总量、虚拟内存使用量、虚拟内存空闲量、已被提前加载的内</p><h4 id="pidof"><a href="#pidof" class="headerlink" title="pidof"></a>pidof</h4><p>pidof 命令用于查询某个指定服务进程的 PID 值，格式为“pidof [参数] [服务名称]”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe]# pidof sshd</span><br><span class="line">2156</span><br></pre></td></tr></table></figure><h4 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h4><p>kill 命令用于终止某个指定 PID 的服务进程，格式为“kill [参数] [进程 PID]”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ]# kill  -9 2156</span><br></pre></td></tr></table></figure><h4 id="killall"><a href="#killall" class="headerlink" title="killall"></a>killall</h4><p>用于终止某个指定名称的服务所对应的全部进程，格式为：“killall [参数] [服<br>务名称]”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]# pidof httpd</span><br><span class="line">13581 13580 13579 13578 13577 13576</span><br><span class="line">[root@linuxprobe ~]# killall httpd</span><br><span class="line">[root@linuxprobe ~]# pidof httpd</span><br><span class="line">[root@linuxprobe ~]#</span><br></pre></td></tr></table></figure><h3 id="系统状态检测命令"><a href="#系统状态检测命令" class="headerlink" title="系统状态检测命令"></a>系统状态检测命令</h3><h4 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h4><p>ifconfig 命令用于获取网卡配置与网络状态等信息，格式为“ifconfig [网络设备] [参数]。</p><p>主要查看的就<br>是网卡名称、inet 参数后面的 IP 地址、ether 参数后面的网卡物理地址（又称为 MAC 地址），<br>以及 RX、TX 的接收数据包与发送数据包的个数及累计流量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]# ifconfig</span><br><span class="line">eno16777728: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500</span><br><span class="line">inet 192.168.10.10 netmask 255.255.255.0 broadcast 192.168.10.255</span><br><span class="line">inet6 fe80::20c:29ff:fec4:a409 prefixlen 64 scopeid 0x20&lt;link&gt;</span><br><span class="line">ether 00:0c:29:c4:a4:09 txqueuelen 1000 (Ethernet)</span><br><span class="line">RX packets 36 bytes 3176 (3.1 KiB)</span><br><span class="line">RX errors 0 dropped 0 overruns 0 frame 0</span><br><span class="line">TX packets 38 bytes 4757 (4.6 KiB)</span><br><span class="line">TX errors 0 dropped 0 overruns 0 carrier 0 collisions </span><br><span class="line">0lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt; mtu 65536inet 127.0.0.1 netmask 255.0.0.0inet6 ::1 prefixlen 128 scopeid 0x10&lt;host&gt;loop txqueuelen 0 (Local Loopback)RX packets 386 bytes 32780 (32.0 KiB)RX errors 0 dropped 0 overruns 0 frame 0TX packets 386 bytes 32780 (32.0 KiB)TX errors 0 dropped 0 overruns 0 carrier 0 collisions</span><br></pre></td></tr></table></figure></p><h4 id="uname"><a href="#uname" class="headerlink" title="uname"></a>uname</h4><p>uname 命令用于查看系统内核与系统版本等信息，格式为“uname [-a]”。</p><p>在使用 uname 命令时，一般会固定搭配上-a 参数来完整地查看当前系统的内核名称、主<br>机名、内核发行版本、节点名、系统时间、硬件名称、硬件平台、处理器类型以及操作系统名<br>称等信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]# uname -a</span><br><span class="line">Linux linuxprobe.com 3.10.0-123.el7.x86_64 #1 SMP Mon May 5 11:16:57 EDT 2017</span><br><span class="line">x86_64 x86_64 x86_64 GNU/Linux</span><br></pre></td></tr></table></figure></p><h4 id="uptime"><a href="#uptime" class="headerlink" title="uptime"></a>uptime</h4><p>uptime 用于查看系统的负载信息，格式为 uptime。</p><p>uptime 命令真的很棒，它可以显示当前系统时间、系统已运行时间、启用终端数量以<br>及平均负载值等信息。平均负载值指的是系统在最近 1 分钟、5 分钟、15 分钟内的压力情<br>况；负载值越低越好，尽量不要长期超过 1，在生产环境中不要超<br>过 5。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]# uptime</span><br><span class="line">22:49:55 up 10 min, 2 users, load average: 0.01, 0.19, 0.18</span><br></pre></td></tr></table></figure></p><h4 id="free"><a href="#free" class="headerlink" title="free"></a>free</h4><p>free 用于显示当前系统中内存的使用量信息，格式为“free [-h]”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ]# free</span><br></pre></td></tr></table></figure></p><p><img src="/images/free-h.jpg" alt=""></p><h4 id="who"><a href="#who" class="headerlink" title="who"></a>who</h4><p>who 命令用于查看当前登入主机的用户终端信息，格式为“who [参数]”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]# who</span><br></pre></td></tr></table></figure></p><h4 id="last"><a href="#last" class="headerlink" title="last"></a>last</h4><p>last 命令用于查看所有系统的登录记录，格式为“last [参数]”。<br>使用 last 命令可以查看本机的登录记录。但是，由于这些信息都是以日志文件的形式保<br>存在系统中，因此黑客可以很容易地对内容进行篡改。千万不要单纯以该命令的输出信息而<br>判断系统有无被恶意入侵！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]# last</span><br><span class="line">root pts/0 :0 Mon Aug 24 17:52 still logged in</span><br><span class="line">root :0 :0 Mon Aug 24 17:52 still logged in</span><br><span class="line">(unknown :0 :0 Mon Aug 24 17:50 - 17:52 (00:02)</span><br><span class="line">reboot system boot 3.10.0-123.el7.x Tue Aug 25 01:49 - 18:17 (-7:-32)</span><br><span class="line">root pts/0 :0 Mon Aug 24 15:40 - 08:54 (7+17:14)</span><br><span class="line">root pts/0 :0 Fri Jul 10 10:49 - 15:37 (45+04:47)</span><br><span class="line">………………省略部分登录信息………………</span><br></pre></td></tr></table></figure></p><h4 id="history"><a href="#history" class="headerlink" title="history"></a>history</h4><p>history 命令用于显示历史执行过的命令，格式为“history [-c]”。<br>history 命令应该是作者最喜欢的命令。执行 history 命令能显示出当前用户在本地计算机<br>中执行过的最近 1000 条命令记录。如果觉得 1000 不够用，还可以自定义/etc/profile 文件中的<br>HISTSIZE 变量值。在使用 history 命令时，如果使用-c 参数则会清空所有的命令历史记录。<br>还可以使用“!编码数字”的方式来重复执行某一次的命令。总之，history 命令有很多有趣的玩法等待您去开发。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]# history</span><br><span class="line">1 tar xzvf VMwareTools-9.9.0-2304977.tar.gz</span><br><span class="line">2 cd vmware-tools-distrib/</span><br><span class="line">3 ls</span><br><span class="line">4 ./vmware-install.pl -d</span><br><span class="line">5 reboot</span><br><span class="line">6 df -h</span><br><span class="line">7 cd /run/media/</span><br><span class="line">8 ls</span><br><span class="line">9 cd root/</span><br><span class="line">10 ls</span><br><span class="line">11 cd VMware\ Tools/</span><br><span class="line">12 ls</span><br><span class="line">13 cp VMwareTools-9.9.0-2304977.tar.gz /home</span><br><span class="line">14 cd /home</span><br><span class="line">15 ls</span><br><span class="line">16 tar xzvf VMwareTools-9.9.0-2304977.tar.gz</span><br><span class="line">17 cd vmware-tools-distrib/</span><br><span class="line">18 ls</span><br><span class="line">19 ./vmware-install.pl -d</span><br><span class="line">20 reboot</span><br><span class="line">21 history</span><br><span class="line">[root@linuxprobe ~]# !15</span><br><span class="line">anaconda-ks.cfg Documents initial-setup-ks.cfg Pictures Templates</span><br><span class="line">Desktop Downloads Music Public Videos</span><br><span class="line"></span><br><span class="line">[root@linuxprobe ~]# cat ~/.bash_history</span><br><span class="line">[root@linuxprobe ~]# history -c  //清除</span><br></pre></td></tr></table></figure><h4 id="sosreport"><a href="#sosreport" class="headerlink" title="sosreport"></a>sosreport</h4><p>sosreport 命令用于收集系统配置及架构信息并输出诊断文档，格式为 sosreport。<br>这个用的不多，需要的自己查资料~</p><h3 id="工作目录切换命令"><a href="#工作目录切换命令" class="headerlink" title="工作目录切换命令"></a>工作目录切换命令</h3><h4 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h4><p>pwd 命令用于显示用户当前所处的工作目录，格式为“pwd [选项]”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe etc]# pwd</span><br><span class="line">/etc</span><br></pre></td></tr></table></figure></p><h4 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h4><p>cd 命令用于切换工作路径，格式为“cd [目录名称]”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]# cd /etc //进入</span><br><span class="line">[root@linuxprobe bin]# cd -  //返回上次</span><br><span class="line">[root@linuxprobe etc]# cd ~  //用户家目录</span><br></pre></td></tr></table></figure></p><h4 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h4><p>ls 命令用于显示目录中的文件信息，格式为“ls [选项] [文件] ”。</p><p>所处的工作目录不同，当前工作目录下的文件肯定也不同。使用 ls 命令的“-a”参数看<br>到全部文件（包括隐藏文件），使用“-l”参数可以查看文件的属性、大小等详细信息。将这<br>两个参数整合之后，再执行 ls 命令即可查看当前目录中的所有文件并输出这些文件的属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]# ls -al</span><br><span class="line">total 60</span><br><span class="line">dr-xr-x---. 14 root root 4096 May 4 07:56 .</span><br><span class="line">drwxr-xr-x. 17 root root 4096 May 4 15:55 ..</span><br><span class="line">省略............</span><br></pre></td></tr></table></figure></p><p>如果想要查看目录属性信息，则需要额外添加一个-d 参数。例如，可使用如下命令查看<br>/etc 目录的权限与属性信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]# ls -ld /etcdrwxr-xr-x. 132 root root 8192 Jul 10 10:48 /e</span><br></pre></td></tr></table></figure></p><h3 id="文本文件编辑命令"><a href="#文本文件编辑命令" class="headerlink" title="文本文件编辑命令"></a>文本文件编辑命令</h3><h4 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h4><p>cat 命令用于查看纯文本文件（内容较少的），格式为“cat [选项] [文件]”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]# cat -n initial-setup-ks.cfg</span><br><span class="line">1 #version=RHEL7</span><br><span class="line">2 # X Window System configuration information</span><br><span class="line">3 xconfig --startxonboot</span><br><span class="line">省略..............</span><br></pre></td></tr></table></figure></p><h4 id="more"><a href="#more" class="headerlink" title="more"></a>more</h4><p>more 命令用于查看纯文本文件（内容较多的），格式为“more [选项]文件”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]# more initial-setup-ks.cfg</span><br><span class="line">#version=RHEL7</span><br><span class="line"># X Window System configuration information</span><br><span class="line">省略............</span><br><span class="line">--More--(43%)</span><br></pre></td></tr></table></figure></p><h4 id="head"><a href="#head" class="headerlink" title="head"></a>head</h4><p>head 命令用于查看纯文本文档的前 N 行，格式为“head [选项] [文件]”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]# head -n 20 initial-setup-ks.cfg</span><br><span class="line">#version=RHEL7</span><br><span class="line"># X Window System configuration information</span><br><span class="line">省略............</span><br></pre></td></tr></table></figure></p><h4 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h4><p>tail 命令用于查看纯文本文档的后 N 行或持续刷新内容，格式为“tail [选项] [文件]”。</p><p>tail 命令最强悍的功能是可以持续刷新一个文件的内容，当想要实时<br>查看最新日志文件时，这特别有用，此时的命令格式为“tail -f 文件名”：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]# tail -f /var/log/messages</span><br><span class="line">May 4 07:56:38 localhost gnome-session: Window manager warning: Log level 16:</span><br><span class="line">STACK_OP_ADD: window 0x1e00001 already in stack</span><br><span class="line">省略............</span><br></pre></td></tr></table></figure></p><h4 id="tr"><a href="#tr" class="headerlink" title="tr"></a>tr</h4><p>tr 命令用于替换文本文件中的字符，格式为“tr [原始字符] [目标字符]”。</p><p>把某个文本内容中的英文全部替换<br>为大写:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]# cat anaconda-ks.cfg | tr [a-z] [A-Z]</span><br></pre></td></tr></table></figure></p><h4 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h4><p>wc 命令用于统计指定文本的行数、字数、字节数，格式为“wc [参数] 文本”。</p><table><thead><tr><th>参数</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td>-l</td><td style="text-align:center">只显示行数</td></tr><tr><td>-w</td><td style="text-align:center">只显示单词数</td></tr><tr><td>-c</td><td style="text-align:center">只显示字节数</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]# wc -l /etc/passwd</span><br><span class="line">38 /etc/pass</span><br></pre></td></tr></table></figure><h4 id="stat"><a href="#stat" class="headerlink" title="stat"></a>stat</h4><p>stat 命令用于查看文件的具体存储信息和时间等信息，格式为“stat 文件名称”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]# stat anaconda-ks.cfg</span><br><span class="line">File: ‘anaconda-ks.cfg’</span><br><span class="line">Size: 1213 Blocks: 8 IO Block: 4096 regular file</span><br><span class="line">Device: fd00h/64768d Inode: 68912908 Links: 1</span><br><span class="line">Access: (0600/-rw-------) Uid: ( 0/ root) Gid: ( 0/ root)</span><br><span class="line">Context: system_u:object_r:admin_home_t:s0</span><br><span class="line">Access: 2017-07-14 01:46:18.721255659 -0400</span><br><span class="line">Modify: 2017-05-04 15:44:36.916027026 -0400</span><br><span class="line">Change: 2017-05-04 15:44:36.916027026 -0400</span><br><span class="line">Birth: -</span><br></pre></td></tr></table></figure></p><h4 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h4><p>cut 命令用于按“列”提取文本字符，格式为“cut [参数] 文本”。</p><p>在 Linux 系统中，如何准确地提取出最想要的数据，这也是我们应该重点学习的内容。一般<br>而言，按基于“行”的方式来提取数据是比较简单的，只需要设置好要搜索的关键词即可。但是<br>如果按列搜索，不仅要使用-f 参数来设置需要看的列数，还需要使用-d 参数来设置间隔符号。<br>passwd 在保存用户数据信息时，用户信息的每一项值之间是采用冒号来间隔的，接下来我们使用<br>下述命令尝试提取出 passwd 文件中的用户名信息，即提取以冒号（：）为间隔符号的第一列内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]# head -n 2 /etc/passwd</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">[root@linuxprobe ~]# cut -d: -f1 /etc/passwd</span><br><span class="line">root</span><br><span class="line">bin</span><br><span class="line">daemon</span><br><span class="line">adm</span><br><span class="line">lp</span><br><span class="line">sync</span><br><span class="line">shutdown</span><br><span class="line">halt</span><br><span class="line">mail</span><br><span class="line">operator</span><br><span class="line">games</span><br><span class="line">ftp</span><br><span class="line">省略...............</span><br></pre></td></tr></table></figure></p><h4 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h4><p>用于比较多个文本文件的差异，格式为“diff [参数] 文件”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]# diff --brief diff_A.txt diff_B.t</span><br><span class="line">*** diff_A.txt 2017-08-30 18:07:45.230864626 +0800</span><br><span class="line">--- diff_B.txt 2017-08-30 18:08:52.203860389 +0800</span><br><span class="line">***************</span><br><span class="line">*** 1,5 ****</span><br><span class="line">! Welcome to linuxprobe.com</span><br><span class="line">Red Hat certified</span><br><span class="line">! Free Linux Lessons</span><br><span class="line">Professional guidance</span><br><span class="line">Linux Course</span><br><span class="line">--- 1,7 ----</span><br><span class="line">! Welcome tooo linuxprobe.com</span><br><span class="line">!</span><br><span class="line">Red Hat certified</span><br><span class="line">! Free Linux LeSSonS</span><br><span class="line">! ////////.....////////</span><br><span class="line">Professional guidance</span><br><span class="line">Linux Course</span><br></pre></td></tr></table></figure></p><h3 id="文件目录管理命令"><a href="#文件目录管理命令" class="headerlink" title="文件目录管理命令"></a>文件目录管理命令</h3><h4 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h4><p>touch 命令用于创建空白文件或设置文件的时间，格式为“touch [选项] [文件]”。</p><table><thead><tr><th>参数</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td>-a</td><td style="text-align:center">仅修改“读取时间”（atime）</td></tr><tr><td>-m</td><td style="text-align:center">仅修改“修改时间”（mtime）</td></tr><tr><td>-d</td><td style="text-align:center">同时修改 atime 与 mtime</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]# ls -l anaconda-ks.cfg</span><br><span class="line">-rw-------. 1 root root 1213 May 4 15:44 anaconda-ks.cfg</span><br><span class="line">[root@linuxprobe ~]# echo &quot;Visit the LinuxProbe.com to learn linux skills&quot; &gt;&gt;</span><br><span class="line">anaconda-ks.cfg</span><br><span class="line">[root@linuxprobe ~]# ls -l anaconda-ks.cfg</span><br><span class="line">-rw-------. 1 root root 1260 Aug 2 01:26 anaconda-ks.cfg</span><br><span class="line">[root@linuxprobe ~]# touch -d &quot;2017-05-04 15:44&quot; anaconda-ks.cfg</span><br><span class="line">[root@linuxprobe ~]# ls -l anaconda-ks.cfg</span><br><span class="line">-rw-------. 1 root root 1260 May 4 15:44 anaconda-ks.cfg</span><br></pre></td></tr></table></figure><h4 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h4><p>mkdir 命令用于创建空白的目录，格式为“mkdir [选项] 目录”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]# mkdir linuxprobe</span><br><span class="line">[root@linuxprobe ~]# cd linuxprobe</span><br><span class="line">[root@linuxprobe linuxprobe]# mkdir -p a/b/c/d/e</span><br><span class="line">[root@linuxprobe linuxprobe]# cd a</span><br><span class="line">[root@linuxprobe a]# cd b</span><br><span class="line">[root@linuxprobe b]#</span><br></pre></td></tr></table></figure><h4 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h4><p>cp 命令用于复制文件或目录，格式为“cp [选项] 源文件 目标文件”。</p><table><thead><tr><th>参数</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td>-p</td><td style="text-align:center">保留原始文件的属性</td></tr><tr><td>-d</td><td style="text-align:center">若对象为“链接文件”，则保留该“链接文件”的属性</td></tr><tr><td>-r</td><td style="text-align:center">递归持续复制（用于目录）</td></tr><tr><td>-i</td><td style="text-align:center">若目标文件存在则询问是否覆盖</td></tr><tr><td>-a</td><td style="text-align:center">相当于-pdr（p、d、r 为上述参数）</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]# touch install.log</span><br><span class="line">[root@linuxprobe ~]# cp install.log x.log</span><br><span class="line">[root@linuxprobe ~]# ls</span><br><span class="line">install.log x.log</span><br></pre></td></tr></table></figure><h4 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h4><p>mv 命令用于剪切文件或将文件重命名，格式为“mv [选项] 源文件 [目标路径|目标文件名]”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]# mv x.log linux.log</span><br><span class="line">[root@linuxprobe ~]# ls</span><br><span class="line">install.log linux.log</span><br></pre></td></tr></table></figure><h4 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h4><p>rm 命令用于删除文件或目录，格式为“rm [选项] 文件”。</p><p>想要删除一个目录，<br>需要在 rm 命令后面一个-r 参数才可以。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]# rm install.log</span><br><span class="line">rm: remove regular empty file ‘install.log’? y</span><br><span class="line">[root@linuxprobe ~]# rm -f linux.log</span><br><span class="line">[root@linuxprobe ~]# ls</span><br><span class="line">[root@linuxprobe ~]#</span><br></pre></td></tr></table></figure></p><h4 id="dd"><a href="#dd" class="headerlink" title="dd"></a>dd</h4><p>dd 命令用于按照指定大小和个数的数据块来复制文件或转换文件，格式为“dd [参数]”。</p><p>dd 命令是一个比较重要而且比较有特色的一个命令，它能够让用户按照指定大小和个数<br>的数据块来复制文件的内容。当然如果愿意的话，还可以在复制过程中转换其中的数据。Linux<br>系统中有一个名为/dev/zero 的设备文件，每次在课堂上解释它时都充满哲学理论的色彩。因<br>为这个文件不会占用系统存储空间，但却可以提供无穷无尽的数据，因此可以使用它作为 dd<br>命令的输入文件，来生成一个指定大小的文件。</p><table><thead><tr><th>参数</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td>if</td><td style="text-align:center">输入的文件名称</td></tr><tr><td>of</td><td style="text-align:center">输出的文件名称</td></tr><tr><td>bs</td><td style="text-align:center">设置每个“块”的大小</td></tr><tr><td>count</td><td style="text-align:center">设置要复制“块”的个数</td></tr></tbody></table><p>例如我们可以用 dd 命令从/dev/zero 设备文件中取出一个大小为 560MB 的数据块，然后<br>保存成名为 560_file 的文件。在理解了这个命令后，以后就能随意创建任意大小的文件了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]# dd if=/dev/zero of=560_file count=1 bs=560M</span><br><span class="line">1+0 records in</span><br><span class="line">1+0 records out</span><br><span class="line">587202560 bytes (587 MB) copied, 27.1755 s, 21.6 MB/s</span><br></pre></td></tr></table></figure></p><p>dd 命令的功能也绝不仅限于复制文件这么简单。如果您想把光驱设备中的光盘制作成 iso 格<br>式的镜像文件，在 Windows 系统中需要借助于第三方软件才能做到，但在 Linux 系统中可以直接<br>使用 dd 命令来压制出光盘镜像文件，将它变成一个可立即使用的 iso 镜像：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]# dd if=/dev/cdrom of=RHEL-server-7.0-x86_64-LinuxProbe.Com.iso</span><br><span class="line">7311360+0 records in</span><br><span class="line">7311360+0 records out</span><br><span class="line">3743416320 bytes (3.7 GB) copied, 370.758 s, 10.1 MB/s</span><br></pre></td></tr></table></figure></p><p>考虑到有些读者会纠结 bs 块大小与 count 块个数的关系，下面举一个吃货的例子进行<br>解释。假设小明的饭量（即需求）是一个固定的值，用来盛饭的勺子的大小即 bs 块大小，<br>而用勺子盛饭的次数即 count 块个数。小明要想吃饱（满足需求），则需要在勺子大小（bs 块<br>大小）与用勺子盛饭的次数（count 块个数）之间进行平衡。勺子越大，用勺子盛饭的次数就越少。由上可见，bs 与 count 都是用来指定容量的大小，只要能满足需求，可随意组合搭配方<br>式。</p><h4 id="file"><a href="#file" class="headerlink" title="file"></a>file</h4><p>file 命令用于查看文件的类型，格式为“file 文件名”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]# file anaconda-ks.cfg</span><br><span class="line">anaconda-ks.cfg: ASCII text</span><br><span class="line">[root@linuxprobe ~]# file /dev/sda</span><br><span class="line">/dev/sda: block special</span><br></pre></td></tr></table></figure></p><h3 id="打包压缩与搜索命令"><a href="#打包压缩与搜索命令" class="headerlink" title="打包压缩与搜索命令"></a>打包压缩与搜索命令</h3><h4 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h4><p>tar 命令用于对文件进行打包压缩或解压，格式为“tar [选项] [文件]”。</p><table><thead><tr><th>参数</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td>-c</td><td style="text-align:center">创建压缩文件</td></tr><tr><td>-x</td><td style="text-align:center">解开压缩文件</td></tr><tr><td>-t</td><td style="text-align:center">查看压缩包里面有哪些文件</td></tr><tr><td>-z</td><td style="text-align:center">用Gzip压缩或解压</td></tr><tr><td>-j</td><td style="text-align:center">用bzip2压缩或解压</td></tr><tr><td>-v</td><td style="text-align:center">显示压缩或解压过程</td></tr><tr><td>-f</td><td style="text-align:center">目标文件名</td></tr><tr><td>-P</td><td style="text-align:center">保存原始的权限与属性</td></tr><tr><td>-p</td><td style="text-align:center">使用绝对路径来压缩</td></tr><tr><td>-C</td><td style="text-align:center">指定解压目录</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]# tar -czvf etc.tar.gz /etc</span><br><span class="line">[root@linuxprobe ~]# mkdir /root/etc</span><br><span class="line">[root@linuxprobe ~]# tar xzvf etc.tar.gz -C /root/etc</span><br></pre></td></tr></table></figure><h4 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h4><p>grep 命令用于在文本中执行关键词搜索，并显示匹配的结果，格式为“grep [选项] [文件]”。</p><table><thead><tr><th>参数</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td>-b</td><td style="text-align:center">将可执行文件（binary）当作文本文件（text）来搜索</td></tr><tr><td>-c</td><td style="text-align:center">仅显示找到的行数</td></tr><tr><td>-i</td><td style="text-align:center">忽略大小写</td></tr><tr><td>-n</td><td style="text-align:center">显示行号</td></tr><tr><td>-v</td><td style="text-align:center">反向选择—仅列出没有“关键词”的行</td></tr></tbody></table><p>在 Linux 系统中，/etc/passwd 文件是保存着所有的用户信息，而一旦用户的登录终端被<br>设置成/sbin/nologin，则不再允许登录系统，因此可以使用 grep 命令来查找出当前系统中不允<br>许登录系统的所有用户信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]# grep /sbin/nologin /etc/passwd</span><br><span class="line">bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class="line">adm:x:3:4:adm:/var/adm:/sbin/nologin</span><br><span class="line">lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin</span><br><span class="line">mail:x:8:12:mail:/var/spool/mail:/sbin/nologin</span><br><span class="line">operator:x:11:0:operator:/root:/sbin/nologin</span><br><span class="line">………………省略部分输出过程信息………………</span><br></pre></td></tr></table></figure><h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><p>find 命令用于按照指定条件来查找文件，格式为“find [查找路径] 寻找条件 操作”。</p><p>在 Linux 系统中，搜索工作一般都是通过 find 命令来完成的，它可以使用不同的文件特性作<br>为寻找条件（如文件名、大小、修改时间、权限等信息），一旦匹配成功则默认将信息显示到<br>屏幕上。</p><table><thead><tr><th>参数</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td>-name</td><td style="text-align:center">匹配名称</td></tr><tr><td>-perm</td><td style="text-align:center">匹配权限（mode 为完全匹配，-mode 为包含即可）</td></tr><tr><td>-user</td><td style="text-align:center">匹配所有者</td></tr><tr><td>-group</td><td style="text-align:center">匹配所有组</td></tr><tr><td>-mtime -n +n</td><td style="text-align:center">匹配修改内容的时间（-n 指 n 天以内，+n 指 n 天以前）</td></tr><tr><td>-atime -n +n</td><td style="text-align:center">匹配访问文件的时间（-n 指 n 天以内，+n 指 n 天以前）</td></tr><tr><td>-ctime -n +n</td><td style="text-align:center">匹配修改文件权限的时间（-n 指 n 天以内，+n 指 n 天以前）</td></tr><tr><td>-nouser</td><td style="text-align:center">匹配无所有者的文件</td></tr><tr><td>-nogroup</td><td style="text-align:center">匹配无所有组的文件</td></tr><tr><td>-newer f1 !f2</td><td style="text-align:center">匹配比文件 f1 新但比 f2 旧的文件</td></tr><tr><td>–type b/d/c/p/l/f</td><td style="text-align:center">匹配文件类型（后面的字母参数依次表示块设备、目录、字符设备、管道、链接文件、文本文件）</td></tr><tr><td>-size</td><td style="text-align:center">匹配文件的大小（+50KB 为查找超过 50KB 的文件，而-50KB 为查找小于 50KB 的文件）</td></tr><tr><td>-prune</td><td style="text-align:center">忽略某个目录</td></tr><tr><td>-exec …… {}\;</td><td style="text-align:center">后面可跟用于进一步处理搜索结果的命令</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//获取到该目录中所有以 host 开头的文件列表</span><br><span class="line">[root@linuxprobe ~]# find /etc -name &quot;host*&quot; -print</span><br><span class="line">/etc/avahi/hosts</span><br><span class="line">/etc/host.conf</span><br><span class="line">/etc/hosts</span><br><span class="line">/etc/hosts.allow</span><br><span class="line">/etc/hosts.deny</span><br><span class="line">/etc/hostname</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//在整个文件系统中找出所有归属于linuxprobe用户的文件并复制到/root/findresults目录</span><br><span class="line">[root@linuxprobe ~]# find / -user linuxprobe -exec cp -a &#123;&#125; /root/findresults/ \;</span><br></pre></td></tr></table></figure><blockquote><p>参考书籍<a href="https://www.linuxprobe.com/chapter-00.html" target="_blank" rel="noopener">《LinuxProbe》</a></p></blockquote><h3 id="Linux命令查找"><a href="#Linux命令查找" class="headerlink" title="Linux命令查找"></a><a href="http://man.linuxde.net/xinshoumingling" target="_blank" rel="noopener">Linux命令查找</a></h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;就是做了一些整理~常用系统工作命令，系统状态检测命令，工作目录切换命令，文本文件编辑命令，文件目录管理命令，打包压缩与搜索命令~&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://liupeng.world/categories/Linux/"/>
    
    
      <category term="command" scheme="http://liupeng.world/tags/command/"/>
    
  </entry>
  
  <entry>
    <title>OSI参考模型图</title>
    <link href="http://liupeng.world/2019/02/13/OSI%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B%E5%9B%BE/"/>
    <id>http://liupeng.world/2019/02/13/OSI参考模型图/</id>
    <published>2019-02-13T13:25:29.000Z</published>
    <updated>2019-02-13T13:27:44.184Z</updated>
    
    <content type="html"><![CDATA[<p>这是一张很长很详细的图~<br><a id="more"></a><br><img src="/images/osi.gif" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一张很长很详细的图~&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ReentrantLock与锁</title>
    <link href="http://liupeng.world/2019/02/10/ReentrantLock%E4%B8%8E%E9%94%81/"/>
    <id>http://liupeng.world/2019/02/10/ReentrantLock与锁/</id>
    <published>2019-02-10T02:00:29.000Z</published>
    <updated>2019-02-10T02:14:05.128Z</updated>
    
    <content type="html"><![CDATA[<p>ReentrantLock与锁之间的区别及使用~<br><a id="more"></a></p><ul><li>ReentrantLock（重入锁）与synchronize区别<ul><li>可重入性：两个都是可以重入的进行锁的计数</li><li>锁的实现：ReentrantLock用的是程序实现（用户态），synchronized用的是JVM实现（内核态）</li><li>性能的区别：synchronized（轻量级锁，偏向锁）经过优化后和ReentrantLock性能差不多</li><li>功能区别：ReentrantLock更加的灵活（细粒度高），synchronized更加便利  </li></ul></li></ul><ul><li>ReentrantLock（重入锁）独有的功能<ul><li>可以指定是公平锁还是非公平锁</li><li>提供了一个Condition类，可以分组唤醒需要唤醒的线程</li><li>提供能够中断等待锁的线程的机制，lock.lockInterrupibly</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//ReentrantLock及Condition使用</span><br><span class="line">@Slf4j</span><br><span class="line">public class ConditionExample &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">ReentrantLock reentrantLock = new ReentrantLock();</span><br><span class="line">Condition condition = reentrantLock.newCondition();</span><br><span class="line"></span><br><span class="line">new Thread(() -&gt; &#123;</span><br><span class="line">try&#123;</span><br><span class="line">reentrantLock.lock();</span><br><span class="line">log.info(&quot;wait signal&quot;);// 1</span><br><span class="line">condition.await();</span><br><span class="line">&#125;catch(InterruptedException e)&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">log.info(&quot;get signal&quot;);// 4</span><br><span class="line">reentrantLock.unlock();</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line">new Thread(() -&gt; &#123;</span><br><span class="line">reentrantLock.lock();</span><br><span class="line">log.info(&quot;get Lock&quot;);// 2</span><br><span class="line">try&#123;</span><br><span class="line">Thread.sleep(3000);</span><br><span class="line">&#125;catch(InterruptedException e)&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">condition.signalAll();</span><br><span class="line">log.info(&quot;send signal ~&quot;);// 3</span><br><span class="line">reentrantLock.unlock();</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ReentrantLock与锁之间的区别及使用~&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java线程类测试</title>
    <link href="http://liupeng.world/2019/02/08/Java%E7%BA%BF%E7%A8%8B%E7%B1%BB%E6%B5%8B%E8%AF%95/"/>
    <id>http://liupeng.world/2019/02/08/Java线程类测试/</id>
    <published>2019-02-08T09:43:00.000Z</published>
    <updated>2019-02-08T12:59:55.435Z</updated>
    
    <content type="html"><![CDATA[<p>对java中的线程安全类及不安全的类进行测试~<br><a id="more"></a></p><ul><li>线程不安全类<ul><li>StringBuilder -&gt; StringBuffer</li><li>SimpleDateFormat -&gt; JodaTime</li></ul></li><li>同步容器<ul><li>ArrayList -&gt; Vector,Stack</li><li>HashMap -&gt; HashTable(key, value不能为null)</li><li>Collections.synchronizedXXX(List, Set, Map)</li></ul></li><li>并发容器<ul><li>ArrayList -&gt; CopyOnWriteArrayList</li><li>HashSet,TreeSet -&gt; CopyOnWriteArraySet,ConcurrentSkipListSet</li><li>HashMap,TreeMap -&gt; ConcurrentHashMap,ConcurrentSkipListMap</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//可以自行进行测试</span><br><span class="line">public class ConcurrencyTest &#123;</span><br><span class="line"></span><br><span class="line">//请求总数</span><br><span class="line">public static int clientTotal = 5000;</span><br><span class="line">//同时并发执行的线程数</span><br><span class="line">public static int threadTotal = 200;</span><br><span class="line">public static int count = 0;</span><br><span class="line">    </span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">final Semaphore semaphore = new Semaphore(threadTotal);</span><br><span class="line">final CountDownLatch countDownLatch = new CountDownLatch(clientTotal);</span><br><span class="line">for (int i = 0; i &lt; clientTotal; i++) &#123;</span><br><span class="line">executorService.execute(() -&gt; &#123;</span><br><span class="line">try&#123;</span><br><span class="line">semaphore.acquire();</span><br><span class="line">add();</span><br><span class="line">semaphore.release();</span><br><span class="line">&#125; catch (Exception e)&#123;</span><br><span class="line">log.error(&quot;exception&quot; , e);</span><br><span class="line">&#125;</span><br><span class="line">countDownLatch.countDown();</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">countDownLatch.await();</span><br><span class="line">executorService.shutdown();</span><br><span class="line">log.info(&quot;count:&#123;&#125;&quot; , count);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void add()&#123;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对java中的线程安全类及不安全的类进行测试~&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://liupeng.world/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java线程封闭</title>
    <link href="http://liupeng.world/2019/02/08/Java%E7%BA%BF%E7%A8%8B%E5%B0%81%E9%97%AD/"/>
    <id>http://liupeng.world/2019/02/08/Java线程封闭/</id>
    <published>2019-02-08T07:59:00.000Z</published>
    <updated>2019-02-08T08:10:26.750Z</updated>
    
    <content type="html"><![CDATA[<p>java是如何保持线程之间的不互相干扰？<br><a id="more"></a></p><ul><li>线程封闭<ul><li>Ad-hoc线程封闭：程序控制，最糟糕，忽略</li><li>堆栈封闭：局部变量(利用不同的虚拟机栈副本存储)</li><li>ThreadLocal线程封闭：特别好的封闭方法</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//ThreadLocal线程封闭</span><br><span class="line">public class RequestHolder &#123;</span><br><span class="line"></span><br><span class="line">private final static ThreadLocal&lt;Long&gt; requestHolder = new ThreadLocal&lt;Long&gt;();</span><br><span class="line"></span><br><span class="line">public static void add(Long id)&#123;</span><br><span class="line">requestHolder.set(id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static Long getId()&#123;</span><br><span class="line">      //自动获取key(当前线程对象地址),找出value值返回</span><br><span class="line">return requestHolder.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void remove()&#123;</span><br><span class="line">      //数据会一直存到项目重启</span><br><span class="line">      //数据一定要移除，避免产生内存溢出(oom)</span><br><span class="line">requestHolder.remove();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;java是如何保持线程之间的不互相干扰？&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://liupeng.world/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java不可变对象</title>
    <link href="http://liupeng.world/2019/02/07/java%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1/"/>
    <id>http://liupeng.world/2019/02/07/java不可变对象/</id>
    <published>2019-02-07T14:53:00.000Z</published>
    <updated>2019-02-07T15:04:12.184Z</updated>
    
    <content type="html"><![CDATA[<p>不可变对象定义，作用，使用方式详解。<br><a id="more"></a></p><ul><li>不可变对象需要满足的条件：<ul><li>对象创建以后其状态就不能修改</li><li>对象所有域都是final类型</li><li>对象时正确创建的（在对象创建期间，this引用没有逸出）</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//final关键字：类，方法，变量</span><br><span class="line">//修饰类：不能被继承</span><br><span class="line">//修饰方法：1.锁定方法不能被继承类修改（默认为private）;2.效率</span><br><span class="line">//修饰变量：基本数据类型变量，引用类型变量</span><br><span class="line">@Slf4j</span><br><span class="line">@NotThreadSafe</span><br><span class="line">public class ImmutableFinal &#123;</span><br><span class="line">private final static Integer a = 1;</span><br><span class="line">private final static String b = &quot;2&quot;;</span><br><span class="line">//guava</span><br><span class="line">private final static Map&lt;Integer, Integer&gt; map = Maps.newHashMap();</span><br><span class="line"></span><br><span class="line">static &#123;</span><br><span class="line">map.put(1, 2);</span><br><span class="line">map.put(3, 4);</span><br><span class="line">map.put(5, 6);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">//a = 2;</span><br><span class="line">//b = &quot;3&quot;;</span><br><span class="line">//map = Maps.newHashMap();</span><br><span class="line">//map引用不能修改，但是内部的值还是可以进行修改~</span><br><span class="line">map.put(1, 3);</span><br><span class="line">log.info(&quot;&#123;&#125;&quot;,map.get(1));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//final参数不能修改</span><br><span class="line">private void test(final int a)&#123;</span><br><span class="line">// a = 1</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">////利用基本的类库进行不可变Map对象的创建（内部参数也不可以改变）</span><br><span class="line">@Slf4j</span><br><span class="line">@ThreadSafe</span><br><span class="line">public class ImmutableMap &#123;</span><br><span class="line">private static Map&lt;Integer, Integer&gt; map = Maps.newHashMap();</span><br><span class="line"></span><br><span class="line">static&#123;</span><br><span class="line">map.put(1, 2);</span><br><span class="line">map.put(3, 4);</span><br><span class="line">map.put(5, 6);</span><br><span class="line">//java</span><br><span class="line">map = Collections.unmodifiableMap(map);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">//会报错哈~UnsupportedOperationException</span><br><span class="line">map.put(1, 3);</span><br><span class="line">log.info(&quot;&#123;&#125;&quot;, map.get(1));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//利用Guava的类库进行不可变Map对象的创建（内部参数也不可以改变）</span><br><span class="line">@ThreadSafe</span><br><span class="line">public class ImmutableGuava &#123;</span><br><span class="line">    private final static ImmutableList&lt;Integer&gt; list = ImmutableList.of(1, 2, 3);</span><br><span class="line"></span><br><span class="line">    private final static ImmutableSet set = ImmutableSet.copyOf(list);</span><br><span class="line"></span><br><span class="line">    private final static ImmutableMap&lt;Integer, Integer&gt; map = ImmutableMap.of(1, 2, 3, 4);</span><br><span class="line"></span><br><span class="line">    private final static ImmutableMap&lt;Integer, Integer&gt; map2 = ImmutableMap.&lt;Integer, Integer&gt;builder()</span><br><span class="line">            .put(1, 2).put(3, 4).put(5, 6).build();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(map2.get(3));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不可变对象定义，作用，使用方式详解。&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://liupeng.world/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>jdk，jre你真的懂吗？</title>
    <link href="http://liupeng.world/2019/02/07/jdk%EF%BC%8Cjre%E4%BD%A0%E7%9C%9F%E7%9A%84%E6%87%82%E5%90%97%EF%BC%9F/"/>
    <id>http://liupeng.world/2019/02/07/jdk，jre你真的懂吗？/</id>
    <published>2019-02-07T14:19:00.000Z</published>
    <updated>2019-02-07T14:40:01.384Z</updated>
    
    <content type="html"><![CDATA[<p>关于jdk和jre </p><p>大家肯定在安装JDK的时候会有选择是否安装单独的jre，一般都会一起安装，我也建议大家这样做。因为这样更能帮助大家弄清楚它们的区别：<br><a id="more"></a><br>Jre 是java runtime environment, 是java程序的运行环境。既然是运行，当然要包含jvm，也就是大家熟悉的虚拟机啦，还有所有java类库的class文件，都在lib目录下打包成了jar。大家可以自己验证。至于在windows上的虚拟机是哪个文件呢？学过MFC的都知道什么是dll文件吧，那么大家看看jre/bin/client里面是不是有一个jvm.dll呢？那就是虚拟机。 </p><p>Jdk 是java development kit，是java的开发工具包，里面包含了各种类库和工具。当然也包括了另外一个Jre. 那么为什么要包括另外一个Jre呢？而且jdk/jre/bin同时有client和server两个文件夹下都包含一个jvm.dll。说明是有两个虚拟机的。这一点不知道大家是否注意到了呢？ </p><p>相信大家都知道jdk的bin下有各种java程序需要用到的命令，与jre的bin目录最明显的区别就是jdk下才有javac，这一点很好理解，因为 jre只是一个运行环境而已。与开发无关，正因为如此，具备开发功能的jdk自己的jre下才会同时有client性质的jvm和server性质的 jvm， 而仅仅作为运行环境的jre下只需要client性质的jvm.dll就够了。 </p><p>记得在环境变量path中设置jdk/bin路径麽？这应该是大家学习Java的第一步吧，老师会告诉大家不设置的话javac和java是用不了的。确实jdk/bin目录下包含了所有的命令。可是有没有人想过我们用的java命令并不是 jdk/bin目录下的而是jre/bin目录下的呢？不信可以做一个实验，大家可以把jdk/bin目录下的java.exe剪切到别的地方再运行 java程序，发现了什么？一切OK！ </p><p>那么有人会问了？我明明没有设置jre/bin目录到环境变量中啊？ </p><p>试想一下如果java为了提供给大多数人使用，他们是不需要jdk做开发的，只需要jre能让java程序跑起来就可以了，那么每个客户还需要手动去设置环境变量多麻烦啊？所以安装jre的时候安装程序自动帮你把jre的java.exe添加到了系统变量中，验证的方法很简单，大家看到了系统环境变量的 path最前面有“%SystemRoot%system32;%SystemRoot%;”这样的配置，那么再去Windows/system32下面去看看吧，发现了什么？有一个java.exe。 </p><p>如果强行能够把jdk/bin挪到system32变量前面，当然也可以迫使使用jdk/jre里面的java，不过除非有必要，我不建议大家这么做。使用单独的jre跑java程序也算是客户环境下的一种测试。 </p><p>——————————————————————————————————————————— </p><p>通俗点来说： jdk是java的开发包，其中包括jre;jre仅仅是java的运行时环境；而JDK包括了同版本的JRE，此外还包括有编译器和其它工具 </p><p><strong>JDK是java开发工具包(java Development Kit)的缩写。它是一种构建在java平台上发布的应用程序、apple和组件的开发环境。JDK是一切java应用程序的基础，所有的java应用程序是构建在这个之上的。它是一组API，也可以说是一些java Class。要成为一个Java程序员，JDK是必不可少的最基本的工具。</strong></p><p><strong>JRE是Java运行环境(Java Runtime Enviroment)的缩写。它基本上就和Java虚拟机是同一个概念。一般来说，在谈论一个具体的产品的时候，可以说“JRE”,而说到理论中的一个模型的时候，我们常用的是“Java虚拟机”。要使用Java程序，JRE是必不可少的环境。</strong></p><p>如果机子里安装了多个版本的jdk，如下： </p><p>BEA Weblogic Server 7.0 自带一套 JDK1.3.1_02<br>下载了一套最新的JDK1.4.1_02<br>JBuilder9自带一套JKD1.4.1_02<br>Oracle8.1.7自带一套JRE1.1.7<br>Ration Rose自带一套JDK1.3<br>DreamWeaver自带一套JDK1.3 </p><p>6套JRE，每套JRE都被各自安装到不同的目录，不会互相影响。当在控制台执行java.exe，操作系统寻找JRE的方式如下：</p><p>先找当前目录下有没有JRE<br>再找父目录下有没有JRE<br>接着在PATH路径中找JRE（一般运行时从path中查找，按照path设置前后顺序，以前面为准）<br>注册表HKEY_LOCAL_MACHINE\SOFTWARE\JavaSoft\Java Runtime Environment\ 查看CurrentVersion的键值指向哪个JRE（一般XP下是这个：C:\Program Files\Java\jre6）</p><p>最常用的是在PATH路径中找JRE，一般情况下，自己的程序运行之前都会先在批处理文件里面临时设置PATH，把自己用的JRE放到PATH路径最前面，所以肯定会运行自己带的JRE，不会造成版本混乱。 </p><p>——————————————————————————————————————————————<br>JDK就是Java Development Kit.简单的说JDK是面向开发人员使用的SDK，它提供了Java的开发环境和运行环境。SDK是Software Development Kit 一般指软件开发包，可以包括函数库、编译程序等。 </p><p>JRE是Java Runtime Enviroment是指Java的运行环境，是面向Java程序的使用者，而不是开发者。 </p><p>如果安装了JDK，会发同你的电脑有两套JRE，一套位于 \jre 另外一套位于 C:\Program Files\Java\jre1.5.0_15 目录下，后面这套比前面那套少了Server端的Java虚拟机，不过直接将前面那套的Server端Java虚拟机复制过来就行了。而且在安装JDK可以选择是否安装这个位于 C:\Program Files\Java 目录下的JRE。如果你只安装JRE，而不是JDK，那么只会在 C:\Program Files\Java 目录下安装唯一的一套JRE。 </p><p>JRE的地位就象一台PC机一样，我们写好的Win32应用程序需要操作系统帮我们运行，同样的，我们编写的Java程序也必须要JRE才能运行。所以当你装完JDK后，如果分别在硬盘上的两个不同地方安装了两套JRE，那么你可以想象你的电脑有两台虚拟的Java PC机，都具有运行Java程序的功能。所以我们可以说，只要你的电脑安装了JRE，就可以正确运行Java应用程序。</p><ol><li>为什么Sun要让JDK安装两套相同的JRE？ </li></ol><p>这是因为JDK里面有很多用Java所编写的开发工具（如javac.exe、jar.exe等），而且都放置在 \lib\tools.jar 里。从下面例子可以看出，先将tools.jar改名为tools1.jar，然后运行javac.exe，显示如下结果： Exception in thread “main” java.lang.NoClassDefFoundError: com/sun/tools/javac /Main 这个意思是说，你输入javac.exe与输入 java -cp c:\jdk\lib\tools.jar com.sun.tools.javac.Main 是一样的，会得到相同的结果。从这里我们可以证明javac.exe只是一个包装器（Wrapper），而制作的目的是为了让开发者免于输入太长的指命。而且可以发现\lib目录下的程序都很小，不大于2 9K，从这里我们可以得出一个结论。就是JDK里的工具几乎是用Java所编写，所以也是Java应用程序，因此要使用JDK所附的工具来开发Java程序，也必须要自行附一套JRE才行，所以位于C:\Program Files\Java目录下的那套JRE就是用来运行一般Java程序用的。 </p><ol start="2"><li>如果一台电脑安装两套以上的JRE，谁来决定呢？ </li></ol><p>这个重大任务就落在java.exe身上。Java.exe的工作就是找到合适的JRE来运行Java程序。 Java.exe依照底下的顺序来查找JRE：自己的目录下有没有JRE；父目录有没有JRE；查询注册表： [HKEY_LOCAL_MACHINE\SOFTWARE\JavaSoft\Java Runtime Environment] 所以java.exe的运行结果与你的电脑里面哪个JRE被执行有很大的关系。 </p><p>ADD：（小小结） </p><ol><li><p>JVM – java virtual machineJVM就是我们常说的java虚拟机，它是整个java实现跨平台的最核心的部分，所有的java程序会首先被编译为.class的类文件，这种类文件可以在虚拟机上执行，也就是说class并不直接与机器的操作系统相对应，而是经过虚拟机间接与操作系统交互，由虚拟机将程序解释给本地系统执行。</p></li><li><p>JRE – java runtime environmentJRE是指java运行环境。光有JVM还不能成class的执行，因为在解释class的时候JVM需要调用解释所需要的类库lib。在JDK的安装目录里你可以找到jre目录，里面有两个文件夹bin和lib,在这里可以认为bin里的就是jvm，lib中则是jvm工作所需要的类库，而jvm和 lib和起来就称为jre。所以，在你写完java程序编译成.class之后，你可以把这个.class文件和jre一起打包发给朋友，这样你的朋友就可以运行你写程序了。（jre里有运行.class的java.exe）</p></li><li><p>JDK – java development kitJDK是java开发工具包，基本上每个学java的人都会先在机器上装一个JDK，那他都包含哪几部分呢？让我们看一下JDK的安装目录。在目录下面有六个文件夹、一个src类库源码压缩包、和其他几个声明文件。其中，真正在运行java时起作用的是以下四个文件夹：bin、include、lib、 jre。现在我们可以看出这样一个关系，JDK包含JRE，而JRE包含JVM。bin:最主要的是编译器(javac.exe)include:java和JVM交互用的头文件lib：类库jre:java运行环境（注意：这里的bin、lib文件夹和jre里的bin、lib是不同的）总的来说JDK是用于java程序的开发,而jre则是只能运行class而没有编译的功能。 </p></li><li><p>eclipse、idea等其他IDE有自己的编译器而不是用JDK bin目录中自带的，所以在安装时你会发现他们只要求你选中jre路径就ok了。 </p></li></ol><p align="right"><a href="https://ihyperwin.iteye.com/blog/1513754" target="_blank" rel="noopener">ITeye原文</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于jdk和jre &lt;/p&gt;
&lt;p&gt;大家肯定在安装JDK的时候会有选择是否安装单独的jre，一般都会一起安装，我也建议大家这样做。因为这样更能帮助大家弄清楚它们的区别：&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://liupeng.world/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>如何安全发布对象？</title>
    <link href="http://liupeng.world/2019/02/05/%E5%A6%82%E4%BD%95%E5%AE%89%E5%85%A8%E5%8F%91%E5%B8%83%E5%AF%B9%E8%B1%A1%EF%BC%9F/"/>
    <id>http://liupeng.world/2019/02/05/如何安全发布对象？/</id>
    <published>2019-02-05T15:25:00.000Z</published>
    <updated>2019-02-05T15:52:47.682Z</updated>
    
    <content type="html"><![CDATA[<p>安全发布对象详解~<br><a id="more"></a></p><ul><li>在静态初始化函数中初始化一个对象引用</li><li>将对象的引用保存到volatile类型域或者AtomicReference对象中</li><li>将对象的引用保存到某个正确构造对象的final类型域中</li><li>将对象的引用保存到一个由锁保护的域中</li></ul><p>例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 懒汉模式 -》 双重同步锁单例模式</span><br><span class="line"> * 单例实例在第一次使用时进行创建</span><br><span class="line"> */</span><br><span class="line">@ThreadSafe</span><br><span class="line">public class LazySingleton &#123;</span><br><span class="line"></span><br><span class="line">    // 私有构造函数</span><br><span class="line">    private LazySingleton() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    // 1、memory = allocate() 分配对象的内存空间</span><br><span class="line">    // 2、ctorInstance() 初始化对象</span><br><span class="line">    // 3、instance = memory 设置instance指向刚分配的内存</span><br><span class="line"></span><br><span class="line">    // 单例对象 volatile + 双重检测机制 -&gt; 禁止指令重排</span><br><span class="line">    private volatile static LazySingleton instance = null;</span><br><span class="line"></span><br><span class="line">    // 静态的工厂方法</span><br><span class="line">    public static LazySingleton getInstance() &#123;</span><br><span class="line">        if (instance == null) &#123; // 双重检测机制       </span><br><span class="line">            synchronized (LazySingleton.class) &#123; // 同步锁</span><br><span class="line">                if (instance == null) &#123;</span><br><span class="line">                    instance = new LazySingleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 饿汉模式</span><br><span class="line"> * 单例实例在类装载时进行创建</span><br><span class="line"> */</span><br><span class="line">@ThreadSafe</span><br><span class="line">public class HungrySingleton &#123;</span><br><span class="line"></span><br><span class="line">    // 私有构造函数</span><br><span class="line">    private HungrySingleton() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    // 单例对象</span><br><span class="line">    private static HungrySingleton instance = new HungrySingleton();</span><br><span class="line"></span><br><span class="line">   /*</span><br><span class="line">    private static SingletonExample6 instance = null;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        instance = new SingletonExample6();</span><br><span class="line">    &#125;*/</span><br><span class="line">    </span><br><span class="line">    // 静态的工厂方法</span><br><span class="line">    public static HungrySingleton getInstance() &#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 枚举模式：最安全</span><br><span class="line"> */</span><br><span class="line">@ThreadSafe</span><br><span class="line">@Recommend</span><br><span class="line">public class EnumSingleton &#123;</span><br><span class="line"></span><br><span class="line">    // 私有构造函数</span><br><span class="line">    private EnumSingleton() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static EnumSingleton getInstance() &#123;</span><br><span class="line">        return Singleton.INSTANCE.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private enum Singleton &#123;</span><br><span class="line">        INSTANCE;</span><br><span class="line">        </span><br><span class="line">        private EnumSingleton singleton;</span><br><span class="line">        </span><br><span class="line">        // JVM保证这个方法绝对只调用一次</span><br><span class="line">        Singleton() &#123;</span><br><span class="line">            singleton = new EnumSingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        public EnumSingleton getInstance() &#123;</span><br><span class="line">            return singleton;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;安全发布对象详解~&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://liupeng.world/categories/Java/"/>
    
    
      <category term="Concurrency" scheme="http://liupeng.world/tags/Concurrency/"/>
    
  </entry>
  
  <entry>
    <title>发布对象线程安全问题</title>
    <link href="http://liupeng.world/2019/02/05/%E5%8F%91%E5%B8%83%E5%AF%B9%E8%B1%A1%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/"/>
    <id>http://liupeng.world/2019/02/05/发布对象线程安全问题/</id>
    <published>2019-02-05T14:33:00.000Z</published>
    <updated>2019-02-05T15:53:10.825Z</updated>
    
    <content type="html"><![CDATA[<p>发布对象，对象逸出并发问题详解<br><a id="more"></a></p><h3 id="发布对象（NotThreadSafe）"><a href="#发布对象（NotThreadSafe）" class="headerlink" title="发布对象（NotThreadSafe）"></a>发布对象（NotThreadSafe）</h3><p>使一个对象能够被当前范围之外的代码所使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@NotThreadSafe</span><br><span class="line">public class UnsafePublish &#123;</span><br><span class="line">private String[] states = &#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;;</span><br><span class="line">    </span><br><span class="line">public String[] getStates()&#123;</span><br><span class="line">return states;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">UnsafePublish unsafePublish = new UnsafePublish();</span><br><span class="line">log.info(&quot;&#123;&#125;&quot;, Arrays.toString(unsafePublish.getStates()));</span><br><span class="line">unsafePublish.getStates()[0] = &quot;d&quot;;</span><br><span class="line">log.info(&quot;&#123;&#125;&quot;, Arrays.toString(unsafePublish.getStates()));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对象逸出（NotThreadSafe）"><a href="#对象逸出（NotThreadSafe）" class="headerlink" title="对象逸出（NotThreadSafe）"></a>对象逸出（NotThreadSafe）</h3><p>一种错误的发布。当一个对象还没有构建完成时，就使它被其他线程所见。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@NotThreadSafe</span><br><span class="line">@NotRecommend</span><br><span class="line">public class Escape &#123;</span><br><span class="line">private int thisCanBeEscape = 0;</span><br><span class="line"></span><br><span class="line">public Escape ()&#123;</span><br><span class="line">new InnerClass();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private class InnerClass &#123;</span><br><span class="line">public InnerClass()&#123;</span><br><span class="line">//获取的数据是未创建完的对象数据</span><br><span class="line">log.info(&quot;&#123;&#125;&quot;, Escape.this.thisCanBeEscape);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">new Escape();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;发布对象，对象逸出并发问题详解&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://liupeng.world/categories/Java/"/>
    
    
      <category term="Concurrency" scheme="http://liupeng.world/tags/Concurrency/"/>
    
  </entry>
  
  <entry>
    <title>新年快乐</title>
    <link href="http://liupeng.world/2019/02/05/%E6%96%B0%E5%B9%B4%E5%BF%AB%E4%B9%90/"/>
    <id>http://liupeng.world/2019/02/05/新年快乐/</id>
    <published>2019-02-04T16:46:00.000Z</published>
    <updated>2019-02-04T17:17:50.600Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/newYear.jpg" alt=""><br>新年深夜更博~北京四年反省总结<br><a id="more"></a></p><p>在过去一年中，发生了很多大事，家人的离世，房贷的压力，互联网环境的变更，辞职决定去杭州发展，身上的压力是越来越重，我只有不停的学习，不停的进步才能减轻担忧。</p><p>我不是本科，也不是本专业，却走上了程序猿这条路，通过培训获取了当一名程序猿的资格，进了第一家公司不停加班，学习，才让我跟上工作步伐。</p><p>很恨自己中间有一年安逸的日子没有学习，只会玩手机，导致技术的滞后。安逸真的会使人堕落，而我本就没有这样的资格堕落。</p><p>2019新的一年到了，深刻的反省。</p><p>三月份到杭州，我会做一个学习计划，到时候再发博~</p><p>在最后祝大家新年快乐，身体健康，合家团员。</p><p>best wishes:<br>努力的去拥抱生活，让自己变得更好，不要辜负自己的青春，在最灿烂的年纪，绽放最耀眼的光芒。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/newYear.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;新年深夜更博~北京四年反省总结&lt;br&gt;
    
    </summary>
    
      <category term="生活" scheme="http://liupeng.world/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>HashMap？面试？我是谁？我在哪</title>
    <link href="http://liupeng.world/2019/02/04/HashMap%EF%BC%9F%E9%9D%A2%E8%AF%95%EF%BC%9F%E6%88%91%E6%98%AF%E8%B0%81%EF%BC%9F%E6%88%91%E5%9C%A8%E5%93%AA/"/>
    <id>http://liupeng.world/2019/02/04/HashMap？面试？我是谁？我在哪/</id>
    <published>2019-02-04T09:11:44.000Z</published>
    <updated>2019-02-04T09:25:17.796Z</updated>
    
    <content type="html"><![CDATA[<p>面试经常被问到做个笔记，emmmmm<br><a id="more"></a></p><h3 id="为什么用HashMap？"><a href="#为什么用HashMap？" class="headerlink" title="为什么用HashMap？"></a>为什么用HashMap？</h3><ul><li>HashMap 是一个散列桶（数组和链表），它存储的内容是键值对 key-value 映射</li><li>HashMap 采用了数组和链表的数据结构，能在查询和修改方便继承了数组的线性查找和链表的寻址修改</li><li>HashMap 是非 synchronized，所以 HashMap 很快</li><li>HashMap 可以接受 null 键和值，而 Hashtable 则不能（原因就是 equlas() 方法需要对象，因为 HashMap 是后出的 API 经过处理才可以）</li></ul><h3 id="HashMap-的工作原理是什么？"><a href="#HashMap-的工作原理是什么？" class="headerlink" title="HashMap 的工作原理是什么？"></a>HashMap 的工作原理是什么？</h3><p><strong>HashMap 是基于 hashing 的原理</strong></p><p>我们使用 put(key, value) 存储对象到 HashMap 中，使用 get(key) 从 HashMap 中获取对象。当我们给 put() 方法传递键和值时，我们先对键调用 hashCode() 方法，计算并返回的 hashCode 是用于找到 Map 数组的 bucket 位置来储存 Node 对象。</p><p>这里关键点在于指出，HashMap 是在 bucket 中储存键对象和值对象，作为Map.Node。</p><p><img src="/images/hashMapBucket.png" alt=""></p><p><strong>以下是 HashMap 初始化</strong><br>简化的模拟数据结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Node[] table = new Node[16]; // 散列桶初始化，table</span><br><span class="line">class Node &#123;</span><br><span class="line">    hash; //hash值</span><br><span class="line">    key; //键</span><br><span class="line">    value; //值</span><br><span class="line">    node next; //用于指向链表的下一层（产生冲突，用拉链法）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以下是具体的 put 过程（JDK1.8）</p><ol><li>对 Key 求 Hash 值，然后再计算下标</li><li>如果没有碰撞，直接放入桶中（碰撞的意思是计算得到的 Hash 值相同，需要放到同一个 bucket 中）</li><li>如果碰撞了，以链表的方式链接到后面</li><li>如果链表长度超过阀值（TREEIFY THRESHOLD==8），就把链表转成红黑树，链表长度低于6，就把红黑树转回链表</li><li>如果节点已经存在就替换旧值</li><li>如果桶满了（容量16*加载因子0.75），就需要 resize（扩容2倍后重排）</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;面试经常被问到做个笔记，emmmmm&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Apache Bench</title>
    <link href="http://liupeng.world/2019/02/03/ApacheBench/"/>
    <id>http://liupeng.world/2019/02/03/ApacheBench/</id>
    <published>2019-02-03T08:43:00.000Z</published>
    <updated>2019-02-04T08:04:50.439Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Apache-Bench简介"><a href="#Apache-Bench简介" class="headerlink" title="Apache Bench简介"></a>Apache Bench简介</h4><p>ApacheBench 是 Apache 服务器自带的一个web压力测试工具，简称ab。ab又是一个命令行工具，对发起负载的本机要求很低，根据ab命令可以创建很多的并发访问线程，模拟多个访问者同时对某一URL地址进行访问，因此可以用来测试目标服务器的负载压力。总的来说ab工具小巧简单，上手学习较快，可以提供需要的基本性能指标，但是没有图形化结果，不能监控。<br><a id="more"></a></p><h4 id="Apache-Bench安装"><a href="#Apache-Bench安装" class="headerlink" title="Apache Bench安装"></a>Apache Bench安装</h4><p>首先需要安装Apache服务器，下载地址：<a href="https://www.apachelounge.com/download/" target="_blank" rel="noopener">https://www.apachelounge.com/download/</a></p><h4 id="Apache-Bench使用"><a href="#Apache-Bench使用" class="headerlink" title="Apache Bench使用"></a>Apache Bench使用</h4><p>了解参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">参数说明：</span><br><span class="line">格式：ab [options] [http://]hostname[:port]/path</span><br><span class="line"></span><br><span class="line">-n requests Number of requests to perform     //本次测试发起的总请求数</span><br><span class="line">-c concurrency Number of multiple requests to make　　 //一次产生的请求数（或并发数）</span><br><span class="line">-t timelimit Seconds to max. wait for responses　　　　//测试所进行的最大秒数，默认没有时间限制。</span><br><span class="line">-r Don&apos;t exit on socket receive errors.     // 抛出异常继续执行测试任务 </span><br><span class="line">-p postfile File containing data to POST　　//包含了需要POST的数据的文件，文件格式如“p1=1&amp;p2=2”.使用方法是 -p 111.txt</span><br><span class="line"></span><br><span class="line">-T content-type Content-type header for POSTing</span><br><span class="line">//POST数据所使用的Content-type头信息，如 -T “application/x-www-form-urlencoded” 。 （配合-p）</span><br><span class="line">-v verbosity How much troubleshooting info to print</span><br><span class="line">//设置显示信息的详细程度 – 4或更大值会显示头信息， 3或更大值可以显示响应代码(404, 200等), 2或更大值可以显示警告和其他信息。 -V 显示版本号并退出。</span><br><span class="line">-C attribute Add cookie, eg. -C “c1=1234,c2=2,c3=3” (repeatable)</span><br><span class="line">//-C cookie-name=value 对请求附加一个Cookie:行。 其典型形式是name=value的一个参数对。此参数可以重复，用逗号分割。</span><br><span class="line">提示：可以借助session实现原理传递 JSESSIONID参数， 实现保持会话的功能，如-C ” c1=1234,c2=2,c3=3, JSESSIONID=FF056CD16DA9D71CB131C1D56F0319F8″ 。</span><br><span class="line">-w Print out results in HTML tables　　//以HTML表的格式输出结果。默认时，它是白色背景的两列宽度的一张表。</span><br><span class="line">-i Use HEAD instead of GET</span><br><span class="line">-x attributes String to insert as table attributes</span><br><span class="line">-y attributes String to insert as tr attributes</span><br><span class="line">-z attributes String to insert as td or th attributes</span><br><span class="line">-H attribute Add Arbitrary header line, eg. ‘Accept-Encoding: gzip’ Inserted after all normal header lines. (repeatable)</span><br><span class="line">-A attribute Add Basic WWW Authentication, the attributes</span><br><span class="line">are a colon separated username and password.</span><br><span class="line">-P attribute Add Basic Proxy Authentication, the attributes are a colon separated username and password.</span><br><span class="line">-X proxy:port Proxyserver and port number to use</span><br><span class="line">-V Print version number and exit</span><br><span class="line">-k Use HTTP KeepAlive feature</span><br><span class="line">-d Do not show percentiles served table.</span><br><span class="line">-S Do not show confidence estimators and warnings.</span><br><span class="line">-g filename Output collected data to gnuplot format file.</span><br><span class="line">-e filename Output CSV file with percentages served</span><br><span class="line">-h Display usage information (this message)</span><br></pre></td></tr></table></figure></p><p>参数倒是挺多的不过，经常用的就是 -n -c ,记得配置path环境变量哈，不然要去bin目录下执行</p><p>例如:</p><p><img src="/images/ApacheBench详解.jpg" align="center"></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Apache-Bench简介&quot;&gt;&lt;a href=&quot;#Apache-Bench简介&quot; class=&quot;headerlink&quot; title=&quot;Apache Bench简介&quot;&gt;&lt;/a&gt;Apache Bench简介&lt;/h4&gt;&lt;p&gt;ApacheBench 是 Apache 服务器自带的一个web压力测试工具，简称ab。ab又是一个命令行工具，对发起负载的本机要求很低，根据ab命令可以创建很多的并发访问线程，模拟多个访问者同时对某一URL地址进行访问，因此可以用来测试目标服务器的负载压力。总的来说ab工具小巧简单，上手学习较快，可以提供需要的基本性能指标，但是没有图形化结果，不能监控。&lt;br&gt;
    
    </summary>
    
      <category term="工具" scheme="http://liupeng.world/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>开篇博客</title>
    <link href="http://liupeng.world/2019/02/03/%E5%BC%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <id>http://liupeng.world/2019/02/03/开篇博客/</id>
    <published>2019-02-03T01:23:00.000Z</published>
    <updated>2019-03-01T02:59:08.030Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/kaipt.jpg" width="50%" height="50%"></p><p>开个博客，写写东西。<br><a id="more"></a><br>很早之间我就想做个博客，写一些技术文档，随笔，却一直没有沉下心来做这件事。</p><p>最近过年才有时间，大概花了1天时间搭建Hexo比想象中的简单多了，之前一直觉得挺麻烦的，也许是因为知识的积累和想拥有一个自己博客的迫切希望才促使我不断的去突破困难搭建完善。</p><p>搭建博客虽然简单，但是持之以恒的去写文章就很难了。我现在开篇立个flag，一周至少更新一篇技术博客，大家监督~</p><p>我一直认为啊~技术宅真的是可以拯救世界的，大家一起加油吧~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/kaipt.jpg&quot; width=&quot;50%&quot; height=&quot;50%&quot;&gt;&lt;/p&gt;
&lt;p&gt;开个博客，写写东西。&lt;br&gt;
    
    </summary>
    
      <category term="生活" scheme="http://liupeng.world/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
  </entry>
  
</feed>
