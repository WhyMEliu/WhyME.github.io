<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>PengˇBlog</title>
  
  <subtitle>学习，生活</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://liupeng.world/"/>
  <updated>2019-02-05T15:44:26.992Z</updated>
  <id>http://liupeng.world/</id>
  
  <author>
    <name>peng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何安全发布对象？</title>
    <link href="http://liupeng.world/2019/02/05/%E5%A6%82%E4%BD%95%E5%AE%89%E5%85%A8%E5%8F%91%E5%B8%83%E5%AF%B9%E8%B1%A1%EF%BC%9F-1/"/>
    <id>http://liupeng.world/2019/02/05/如何安全发布对象？-1/</id>
    <published>2019-02-05T15:25:50.000Z</published>
    <updated>2019-02-05T15:44:26.992Z</updated>
    
    <content type="html"><![CDATA[<p>安全发布对象详解~<br><a id="more"></a></p><ul><li>在静态初始化函数中初始化一个对象引用</li><li>将对象的引用保存到volatile类型域或者AtomicReference对象中</li><li>将对象的引用保存到某个正确构造对象的final类型域中</li><li>将对象的引用保存到一个由锁保护的域中</li></ul><p>例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 懒汉模式 -》 双重同步锁单例模式</span><br><span class="line"> * 单例实例在第一次使用时进行创建</span><br><span class="line"> */</span><br><span class="line">@ThreadSafe</span><br><span class="line">public class LazySingleton &#123;</span><br><span class="line"></span><br><span class="line">    // 私有构造函数</span><br><span class="line">    private LazySingleton() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    // 1、memory = allocate() 分配对象的内存空间</span><br><span class="line">    // 2、ctorInstance() 初始化对象</span><br><span class="line">    // 3、instance = memory 设置instance指向刚分配的内存</span><br><span class="line"></span><br><span class="line">    // 单例对象 volatile + 双重检测机制 -&gt; 禁止指令重排</span><br><span class="line">    private volatile static LazySingleton instance = null;</span><br><span class="line"></span><br><span class="line">    // 静态的工厂方法</span><br><span class="line">    public static LazySingleton getInstance() &#123;</span><br><span class="line">        if (instance == null) &#123; // 双重检测机制       </span><br><span class="line">            synchronized (LazySingleton.class) &#123; // 同步锁</span><br><span class="line">                if (instance == null) &#123;</span><br><span class="line">                    instance = new LazySingleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 饿汉模式</span><br><span class="line"> * 单例实例在类装载时进行创建</span><br><span class="line"> */</span><br><span class="line">@ThreadSafe</span><br><span class="line">public class HungrySingleton &#123;</span><br><span class="line"></span><br><span class="line">    // 私有构造函数</span><br><span class="line">    private HungrySingleton() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    // 单例对象</span><br><span class="line">    private static HungrySingleton instance = new HungrySingleton();</span><br><span class="line"></span><br><span class="line">   /*</span><br><span class="line">    private static SingletonExample6 instance = null;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        instance = new SingletonExample6();</span><br><span class="line">    &#125;*/</span><br><span class="line">    </span><br><span class="line">    // 静态的工厂方法</span><br><span class="line">    public static HungrySingleton getInstance() &#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 枚举模式：最安全</span><br><span class="line"> */</span><br><span class="line">@ThreadSafe</span><br><span class="line">@Recommend</span><br><span class="line">public class EnumSingleton &#123;</span><br><span class="line"></span><br><span class="line">    // 私有构造函数</span><br><span class="line">    private EnumSingleton() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static EnumSingleton getInstance() &#123;</span><br><span class="line">        return Singleton.INSTANCE.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private enum Singleton &#123;</span><br><span class="line">        INSTANCE;</span><br><span class="line">        </span><br><span class="line">        private EnumSingleton singleton;</span><br><span class="line">        </span><br><span class="line">        // JVM保证这个方法绝对只调用一次</span><br><span class="line">        Singleton() &#123;</span><br><span class="line">            singleton = new EnumSingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        public EnumSingleton getInstance() &#123;</span><br><span class="line">            return singleton;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;安全发布对象详解~&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>发布对象线程安全问题</title>
    <link href="http://liupeng.world/2019/02/05/%E5%8F%91%E5%B8%83%E5%AF%B9%E8%B1%A1%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/"/>
    <id>http://liupeng.world/2019/02/05/发布对象线程安全问题/</id>
    <published>2019-02-05T14:33:41.000Z</published>
    <updated>2019-02-05T14:42:50.498Z</updated>
    
    <content type="html"><![CDATA[<p>发布对象，对象逸出并发问题详解<br><a id="more"></a></p><h3 id="发布对象（NotThreadSafe）"><a href="#发布对象（NotThreadSafe）" class="headerlink" title="发布对象（NotThreadSafe）"></a>发布对象（NotThreadSafe）</h3><p>使一个对象能够被当前范围之外的代码所使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@NotThreadSafe</span><br><span class="line">public class UnsafePublish &#123;</span><br><span class="line">private String[] states = &#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;;</span><br><span class="line">    </span><br><span class="line">public String[] getStates()&#123;</span><br><span class="line">return states;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">UnsafePublish unsafePublish = new UnsafePublish();</span><br><span class="line">log.info(&quot;&#123;&#125;&quot;, Arrays.toString(unsafePublish.getStates()));</span><br><span class="line">unsafePublish.getStates()[0] = &quot;d&quot;;</span><br><span class="line">log.info(&quot;&#123;&#125;&quot;, Arrays.toString(unsafePublish.getStates()));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对象逸出（NotThreadSafe）"><a href="#对象逸出（NotThreadSafe）" class="headerlink" title="对象逸出（NotThreadSafe）"></a>对象逸出（NotThreadSafe）</h3><p>一种错误的发布。当一个对象还没有构建完成时，就使它被其他线程所见。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@NotThreadSafe</span><br><span class="line">@NotRecommend</span><br><span class="line">public class Escape &#123;</span><br><span class="line">private int thisCanBeEscape = 0;</span><br><span class="line"></span><br><span class="line">public Escape ()&#123;</span><br><span class="line">new InnerClass();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private class InnerClass &#123;</span><br><span class="line">public InnerClass()&#123;</span><br><span class="line">//获取的数据是未创建完的对象数据</span><br><span class="line">log.info(&quot;&#123;&#125;&quot;, Escape.this.thisCanBeEscape);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">new Escape();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;发布对象，对象逸出并发问题详解&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>新年快乐</title>
    <link href="http://liupeng.world/2019/02/05/%E6%96%B0%E5%B9%B4%E5%BF%AB%E4%B9%90/"/>
    <id>http://liupeng.world/2019/02/05/新年快乐/</id>
    <published>2019-02-04T16:46:00.000Z</published>
    <updated>2019-02-04T17:17:50.600Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/newYear.jpg" alt=""><br>新年深夜更博~北京四年反省总结<br><a id="more"></a></p><p>在过去一年中，发生了很多大事，家人的离世，房贷的压力，互联网环境的变更，辞职决定去杭州发展，身上的压力是越来越重，我只有不停的学习，不停的进步才能减轻担忧。</p><p>我不是本科，也不是本专业，却走上了程序猿这条路，通过培训获取了当一名程序猿的资格，进了第一家公司不停加班，学习，才让我跟上工作步伐。</p><p>很恨自己中间有一年安逸的日子没有学习，只会玩手机，导致技术的滞后。安逸真的会使人堕落，而我本就没有这样的资格堕落。</p><p>2019新的一年到了，深刻的反省。</p><p>三月份到杭州，我会做一个学习计划，到时候再发博~</p><p>在最后祝大家新年快乐，身体健康，合家团员。</p><p>best wishes:<br>努力的去拥抱生活，让自己变得更好，不要辜负自己的青春，在最灿烂的年纪，绽放最耀眼的光芒。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/newYear.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;新年深夜更博~北京四年反省总结&lt;br&gt;
    
    </summary>
    
      <category term="生活" scheme="http://liupeng.world/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>HashMap？面试？我是谁？我在哪</title>
    <link href="http://liupeng.world/2019/02/04/HashMap%EF%BC%9F%E9%9D%A2%E8%AF%95%EF%BC%9F%E6%88%91%E6%98%AF%E8%B0%81%EF%BC%9F%E6%88%91%E5%9C%A8%E5%93%AA/"/>
    <id>http://liupeng.world/2019/02/04/HashMap？面试？我是谁？我在哪/</id>
    <published>2019-02-04T09:11:44.000Z</published>
    <updated>2019-02-04T09:25:17.796Z</updated>
    
    <content type="html"><![CDATA[<p>面试经常被问到做个笔记，emmmmm<br><a id="more"></a></p><h3 id="为什么用HashMap？"><a href="#为什么用HashMap？" class="headerlink" title="为什么用HashMap？"></a>为什么用HashMap？</h3><ul><li>HashMap 是一个散列桶（数组和链表），它存储的内容是键值对 key-value 映射</li><li>HashMap 采用了数组和链表的数据结构，能在查询和修改方便继承了数组的线性查找和链表的寻址修改</li><li>HashMap 是非 synchronized，所以 HashMap 很快</li><li>HashMap 可以接受 null 键和值，而 Hashtable 则不能（原因就是 equlas() 方法需要对象，因为 HashMap 是后出的 API 经过处理才可以）</li></ul><h3 id="HashMap-的工作原理是什么？"><a href="#HashMap-的工作原理是什么？" class="headerlink" title="HashMap 的工作原理是什么？"></a>HashMap 的工作原理是什么？</h3><p><strong>HashMap 是基于 hashing 的原理</strong></p><p>我们使用 put(key, value) 存储对象到 HashMap 中，使用 get(key) 从 HashMap 中获取对象。当我们给 put() 方法传递键和值时，我们先对键调用 hashCode() 方法，计算并返回的 hashCode 是用于找到 Map 数组的 bucket 位置来储存 Node 对象。</p><p>这里关键点在于指出，HashMap 是在 bucket 中储存键对象和值对象，作为Map.Node。</p><p><img src="/images/hashMapBucket.png" alt=""></p><p><strong>以下是 HashMap 初始化</strong><br>简化的模拟数据结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Node[] table = new Node[16]; // 散列桶初始化，table</span><br><span class="line">class Node &#123;</span><br><span class="line">    hash; //hash值</span><br><span class="line">    key; //键</span><br><span class="line">    value; //值</span><br><span class="line">    node next; //用于指向链表的下一层（产生冲突，用拉链法）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以下是具体的 put 过程（JDK1.8）</p><ol><li>对 Key 求 Hash 值，然后再计算下标</li><li>如果没有碰撞，直接放入桶中（碰撞的意思是计算得到的 Hash 值相同，需要放到同一个 bucket 中）</li><li>如果碰撞了，以链表的方式链接到后面</li><li>如果链表长度超过阀值（TREEIFY THRESHOLD==8），就把链表转成红黑树，链表长度低于6，就把红黑树转回链表</li><li>如果节点已经存在就替换旧值</li><li>如果桶满了（容量16*加载因子0.75），就需要 resize（扩容2倍后重排）</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;面试经常被问到做个笔记，emmmmm&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Apache Bench</title>
    <link href="http://liupeng.world/2019/02/03/ApacheBench/"/>
    <id>http://liupeng.world/2019/02/03/ApacheBench/</id>
    <published>2019-02-03T08:43:00.000Z</published>
    <updated>2019-02-04T08:04:50.439Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Apache-Bench简介"><a href="#Apache-Bench简介" class="headerlink" title="Apache Bench简介"></a>Apache Bench简介</h4><p>ApacheBench 是 Apache 服务器自带的一个web压力测试工具，简称ab。ab又是一个命令行工具，对发起负载的本机要求很低，根据ab命令可以创建很多的并发访问线程，模拟多个访问者同时对某一URL地址进行访问，因此可以用来测试目标服务器的负载压力。总的来说ab工具小巧简单，上手学习较快，可以提供需要的基本性能指标，但是没有图形化结果，不能监控。<br><a id="more"></a></p><h4 id="Apache-Bench安装"><a href="#Apache-Bench安装" class="headerlink" title="Apache Bench安装"></a>Apache Bench安装</h4><p>首先需要安装Apache服务器，下载地址：<a href="https://www.apachelounge.com/download/" target="_blank" rel="noopener">https://www.apachelounge.com/download/</a></p><h4 id="Apache-Bench使用"><a href="#Apache-Bench使用" class="headerlink" title="Apache Bench使用"></a>Apache Bench使用</h4><p>了解参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">参数说明：</span><br><span class="line">格式：ab [options] [http://]hostname[:port]/path</span><br><span class="line"></span><br><span class="line">-n requests Number of requests to perform     //本次测试发起的总请求数</span><br><span class="line">-c concurrency Number of multiple requests to make　　 //一次产生的请求数（或并发数）</span><br><span class="line">-t timelimit Seconds to max. wait for responses　　　　//测试所进行的最大秒数，默认没有时间限制。</span><br><span class="line">-r Don&apos;t exit on socket receive errors.     // 抛出异常继续执行测试任务 </span><br><span class="line">-p postfile File containing data to POST　　//包含了需要POST的数据的文件，文件格式如“p1=1&amp;p2=2”.使用方法是 -p 111.txt</span><br><span class="line"></span><br><span class="line">-T content-type Content-type header for POSTing</span><br><span class="line">//POST数据所使用的Content-type头信息，如 -T “application/x-www-form-urlencoded” 。 （配合-p）</span><br><span class="line">-v verbosity How much troubleshooting info to print</span><br><span class="line">//设置显示信息的详细程度 – 4或更大值会显示头信息， 3或更大值可以显示响应代码(404, 200等), 2或更大值可以显示警告和其他信息。 -V 显示版本号并退出。</span><br><span class="line">-C attribute Add cookie, eg. -C “c1=1234,c2=2,c3=3” (repeatable)</span><br><span class="line">//-C cookie-name=value 对请求附加一个Cookie:行。 其典型形式是name=value的一个参数对。此参数可以重复，用逗号分割。</span><br><span class="line">提示：可以借助session实现原理传递 JSESSIONID参数， 实现保持会话的功能，如-C ” c1=1234,c2=2,c3=3, JSESSIONID=FF056CD16DA9D71CB131C1D56F0319F8″ 。</span><br><span class="line">-w Print out results in HTML tables　　//以HTML表的格式输出结果。默认时，它是白色背景的两列宽度的一张表。</span><br><span class="line">-i Use HEAD instead of GET</span><br><span class="line">-x attributes String to insert as table attributes</span><br><span class="line">-y attributes String to insert as tr attributes</span><br><span class="line">-z attributes String to insert as td or th attributes</span><br><span class="line">-H attribute Add Arbitrary header line, eg. ‘Accept-Encoding: gzip’ Inserted after all normal header lines. (repeatable)</span><br><span class="line">-A attribute Add Basic WWW Authentication, the attributes</span><br><span class="line">are a colon separated username and password.</span><br><span class="line">-P attribute Add Basic Proxy Authentication, the attributes are a colon separated username and password.</span><br><span class="line">-X proxy:port Proxyserver and port number to use</span><br><span class="line">-V Print version number and exit</span><br><span class="line">-k Use HTTP KeepAlive feature</span><br><span class="line">-d Do not show percentiles served table.</span><br><span class="line">-S Do not show confidence estimators and warnings.</span><br><span class="line">-g filename Output collected data to gnuplot format file.</span><br><span class="line">-e filename Output CSV file with percentages served</span><br><span class="line">-h Display usage information (this message)</span><br></pre></td></tr></table></figure></p><p>参数倒是挺多的不过，经常用的就是 -n -c ,记得配置path环境变量哈，不然要去bin目录下执行</p><p>例如:</p><p><img src="/images/ApacheBench详解.jpg" align="center"></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Apache-Bench简介&quot;&gt;&lt;a href=&quot;#Apache-Bench简介&quot; class=&quot;headerlink&quot; title=&quot;Apache Bench简介&quot;&gt;&lt;/a&gt;Apache Bench简介&lt;/h4&gt;&lt;p&gt;ApacheBench 是 Apache 服务器自带的一个web压力测试工具，简称ab。ab又是一个命令行工具，对发起负载的本机要求很低，根据ab命令可以创建很多的并发访问线程，模拟多个访问者同时对某一URL地址进行访问，因此可以用来测试目标服务器的负载压力。总的来说ab工具小巧简单，上手学习较快，可以提供需要的基本性能指标，但是没有图形化结果，不能监控。&lt;br&gt;
    
    </summary>
    
      <category term="工具" scheme="http://liupeng.world/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>开篇博客</title>
    <link href="http://liupeng.world/2019/02/03/%E5%BC%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <id>http://liupeng.world/2019/02/03/开篇博客/</id>
    <published>2019-02-03T01:23:00.000Z</published>
    <updated>2019-02-04T06:35:31.340Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/kaipt.jpg" width="50%" height="50%"></p><p>开个博客，写写东西。<br><a id="more"></a><br>很早之间我就想做个博客，写一些技术文档，随笔，却一直没有沉下心来做这件事。</p><p>最近过年才有时间，大概花了1天时间搭建Hexo比想象中的简单多了，之前一直觉得挺麻烦的，也许是因为知识的积累和想拥有一个自己博客的迫切希望才促使我不断的去突破困难搭建完善。</p><p>搭建博客虽然简单，但是持之以恒的去写文章就很难了。我现在开篇立个flag，一周至少更新一篇技术博客，大家监督~</p><p>我一直认为啊~技术宅真的是可以拯救世界的，大家一起加油吧！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/kaipt.jpg&quot; width=&quot;50%&quot; height=&quot;50%&quot;&gt;&lt;/p&gt;
&lt;p&gt;开个博客，写写东西。&lt;br&gt;
    
    </summary>
    
      <category term="生活" scheme="http://liupeng.world/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
  </entry>
  
</feed>
